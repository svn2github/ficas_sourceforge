\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{computation related mathematical structures}
\author{Martin J Baker}
\maketitle
\begin{abstract}
In this pamphlet are implementations of various mathematical
structures related to computation. These are:
* lambda.spad
* ski.spad
* ILogic.spad

The aim here is to model and study lambda-calculus, Combinators and
Intuitionistic logic as abstract mathematical structures which were
discovered before modern computers and are worthy of study in their
own right.

The arguments of these 'computation' domains are functions and
combinators and the operation is function composition. For
combinators the number of arguments is variable and so function
composition is non-associative hence it is represented by binary
tree structure. For Lambda calculus we have bound and unbound
variables so again non-associative and represented by binary
tree structure.

These domains all represent systems of logic and are constructed from
tree structures and act on tree structures. These 'tree logics' seem
to 'generate' other algebras, for instance, below, we see that
this lambda structure:

\x.\y.y x

can be converted to this SKI structure:

S(K(SI))(S(KK)I)

This allows us to 'abstract' the definition, in that it takes a
definition in terms of arbitrary variables and it converts to a
definition without arbitrary variables. So these structures are
equivalent and they both reverse two operands. That is they generate
an n-ary to n-ary function, in this case:

(x,y) -> (y,x)

This seems to be a 'monad' and it would be interesting to see if
these domains could be implemented as instances of a monad (a
monad in category theory terms, not the current FriCAS monad
category).

For more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/
Tutorial for lambda calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
Tutorial for SKI calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/
Tutorial for Intuitionistic Logic
http://www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/
Tutorial for utilities to coerce between computation domains
http://www.euclideanspace.com/maths/standards/program/mycode/computation/utility/
\end{abstract}
\eject
\tableofcontents
\eject
\section{To Do}

There are improvements and corrections required for later versions
of this software.

1) Overall architecture:
   - Investigate possibility of basing implementation on Kernel or
     SExpression domains. Or we could extend some non-associative or
     binary tree structure class?

2)  Possible generalisations:
   - If I could find a way to do it, it would be good to have a
     function composition (hom-set) domain and to implement these
     as a special (non-associative) version of that.
   - It would be interesting to see if these domains could be implemented
     as instances of a monad.
   - I would also like to extend this to investigate abstract structures
     such as 'tree automata'.

3) Need to improve and correct intuitionistic logic domain.
   - investigate change of meaning of '=' for intuitionistic logic to
     represent equivalence rather than equality.
   - implement more complete algorithm to decide if two (quantifier-free)
     intuitionistic formulas are equivalent.
   - add remaining simplifications.

4) Representation by symbols. Make code more maintainable by changing
   encoding of distinct literal elements to use symbols rather than
   specific strings or integers.

5) Notation. At the moment, for compatibility reasons, Unicode cannot be
   used to show:
   - lambda symbol
   - alpha (as in alpha-substitution)
   - beta (as in beta-equivalence)
   When the restrictions on using Unicode are lifted then use of the
   Unicode lambda symbol and other Unicode characters would improve
   readability.

\section{Variables}

Before we get on to the main domains we have some code to represent
variables in Lambda and Ski domains.
Since we are working in terms of functions then a variable will be a
function (possibly a constant function).

There is a category to represent these function variables and there are
two implementations of this category so far:
* Untyped - Untyped represents an untyped variable in Lambda and Ski
            domains, a variable has a name represented by a String.
* Typed - Typed represents an typed variable in Lambda and Ski
          domains, a variable has a name represented by a String
          and a type represented by a tree of strings.

There may be possibly be other implementations in the future. For instance
we could introduce a typed variable which could have FriCAS types instead
of abstract types represented by strings. This might allow more interaction
with other domains, although as already stated, the main aim is to
implement these as abstract structures like any other mathematical
structure.

The two implementations: Untyped and Typed which can be constructed as
follows:

(1) -> var("x")$Untyped

   (1)  "x"
                                                            Type: Untyped

(2) -> var("x",varTyp("a"))$Typed

   (2)  "x:a"
                                                              Type: Typed

(3) -> parseVar("x:a->b",1)$Typed

   (3)  [rft= "x:a->b",pout= 7]
                        Type: Record(rft: Typed,pout: NonNegativeInteger)

In (3) we are entering a variable with a more complicated type (in
this case 'a->b') so it is easier to use parseVar to construct from
a string although this could have been built from raw types.

parseVar also requires '1' which means: start parsing at position 1
in the string. It returns x:a->b which means variable 'x' from type
'a' to type 'b' and 7 which is the position of the pointer after
this term has been parsed.

Variables are not usually constructed directly by the user but instead
are used by lambda and ski domains.
\section{Types}

If we are using Typed variables then the type will be represented by
the following domain:

\section{domain VTYP VarTyp}
<<domain VTYP VarTyp>>=
)abbrev domain VTYP VarTyp
++ Author: Martin Baker
++ Date Created: April 2011
++ Date Last Updated: April 2011
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/

VarTyp(): Exports == Implementation where

 NNI==> NonNegativeInteger
 PR ==> Record(rft:%,pout:NNI)
   ++ parse result includes term returned and new index

 Exports == with
  varTyp:(x:%,y:%) -> %
    ++ Constructs a compound type
  varTyp:(t1:String) -> %
    ++ Constructs an individual type
  parseVarTyp:(t1: String) -> %
    ++ Constructs a type from a string
  parseTyp:(t1: String,pin:NNI) -> PR
    ++ construct a type by parsing a string t1
    ++ pin is index to string at start of parse
  children:(n: %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  name:(n: %) -> String
    ++ returns the name if this is a simple type otherwise
    ++ return ""
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal (deep search) that is: all terms
    ++ at all levels in tree must be equal to return true
  toString: (n: %) -> String
    ++ output
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         nm:String,_
         nd:Record(c1:%, c2:%)_
         )

  -- Constructs a compound type
  varTyp(x:%,y:%): % == [[x,y]]

  -- Constructs an individual type
  varTyp(t1:String):% ==
    [t1]

  -- construct a type by parsing a string t1
  -- pin is index to string at start of parse
  parseTypName(t1: String,pin:NNI):PR ==
    vnm:String := ""
    pt:NNI := pin
    ch := qelt(t1,pt)
    --sayTeX$Lisp concat("st ch=",ch::String)
    while alphanumeric?(ch) repeat
      vnm := concat(vnm,ch)
      pt := pt + (1::NNI)
      if pt > maxIndex(t1) then
        return [varTyp(vnm),pt]
      ch := qelt(t1,pt)
    [varTyp(vnm),pt]

  parseBracketTerm(t1: String,pin:NNI):PR ==
    p1 := pin
    ch := qelt(t1,p1)
    if not (ch = char("(")) then
      error "bracket term must start with ("
      return [[""],p1]
    p1 := p1 + (1::NNI)
    if p1 > maxIndex(t1) then
      error "opening but no closing bracket"
      return [[""],p1]
    r2 := parseTyp(t1,p1)
    trm := r2.rft
    p1 := r2.pout
    ch := qelt(t1,p1)
    if not (ch = char(")")) then
      error "can't find closing bracket"
      return [[""],p1]
    p1 := p1 + (1::NNI)
    [trm,p1]

  parseTyp(t1: String,pin:NNI):PR ==
    p1 := pin
    res:% := [""]
    ch := qelt(t1,p1)
    -- first remove leading spaces
    while ch = char(" ") repeat
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        return [res,p1]
      ch := qelt(t1,p1)
    r:PR:= [res,p1]
    if ch = char("(") then r := parseBracketTerm(t1,p1)
    if alphabetic?(ch) then r := parseTypName(t1,p1)
    res := r.rft
    p1 := r.pout
    -- now check for compound term
    if p1 > maxIndex(t1) then
      return [res,p1]
    ch := qelt(t1,p1)
    if ch = char(" ") then
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        return [res,p1]
    if ch = char("-") then
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        return [res,p1]
      ch := qelt(t1,p1)
      if not ch = char(">") then
        error "unexpected - found"
        return [res,p1]
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        return [res,p1]
      r := parseTyp(t1,p1)
      p1 := r.pout
      res := varTyp(res,r.rft)
    [res,p1]

  parseVarTyp(t1: String): % ==
    r := parseTyp(t1,minIndex(t1)::NNI)
    --sayTeX$Lisp concat(["parseLambda(",t1,") giving:",toString(tm)])
    r.rft

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  children(n: %):List % ==
    if atom?(n) then return []
    [n.nd.c1,n.nd.c2]

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n: %):Boolean == (n case nm)

  -- returns the name if this is a simple type otherwise
  -- return ""
  name(n: %):String ==
    if n case nm then
      return n.nm
    ""

  -- return string representation
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  toString(n: %):String ==
    s:String := ""
    if n case nm then
      return n.nm
    if n case nd then
      if atom?(n.nd.c2) then
        s := concat([s,toString(n.nd.c1),"->",toString(n.nd.c2)])
      else
        s := concat([s,toString(n.nd.c1),"->","(",toString(n.nd.c2),")"])
    s

  -- return true if equal (deep search) that is: all terms
  -- at all levels in tree must be equal to return true
  x = y ==
    if (x case nm) and (y case nm) then
      if x.nm = y.nm then return true
      return false
    if (x case nd) and (y case nd) then
      -- binary node which has two subnodes c1 and c2
      if (x.nd.c1 = y.nd.c1) and (x.nd.c2 = y.nd.c2) then return true
      return false
    false

  -- output
  coerce(n: %):OutputForm ==
    toString(n)::OutputForm
@

Now we will implement variables:

First a common category for the various variable types:
\section{category VARCAT VarCat}
<<domain VARCAT VarCat>>=
)abbrev category VARCAT VarCat
++ Author: Martin Baker
++ Date Created: April 2011
++ Date Last Updated: April 2011
++ Basic Operations:
++ Related Constructors: lambda, ski
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/
++ Description: VarCat represents a variable in Lambda and Ski domains.
++ Since we are working in terms of functions then a variable will be a
++ function (possibly a constant function)
++ a variable has a name represented by a String. If the Lambda or Ski
++ calculas is typed then the variable will also have a type.

VarCat() : Category == Type with
  var:(n:String) -> %
    ++ constructs variable with a name but no type.
  var:(n:String,t:VarTyp) -> %
    ++ constructs variable with a name and also a type.
  name:(v:%) -> String
    ++ returns the name of the variable.
  type:(v:%) -> VarTyp
    ++ returns the type of the variable. This may be a compund type, for
    ++ instance ["a","b"] represents a->b a function from type a to type b
    ++ untyped implementations return []
  toString:(v:%) -> String
    ++ returns the name and the type in string form.
  parseVar:(t1: String,pin:NonNegativeInteger)-> Record(rft:%,pout:NonNegativeInteger)
    ++ construct a variable by parsing a string
    ++ pin is index to string at start of parse
    ++ pout is index to string at end of parse
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal, that is names are equal and if there is
    ++ a type then tey mast also be equal
  coerce: (n: %) -> OutputForm
    ++ output
@

Next an implenetation of the above category which is intended to work with
untyped variables:

\section{domain UNTYPED Untyped}
<<domain UNTYPED Untyped>>=
)abbrev domain UNTYPED Untyped
++ Author: Martin Baker
++ Date Created: April 2011
++ Date Last Updated: April 2011
++ Basic Operations:
++ Related Constructors: lambda, ski
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/
++ Description: Untyped represents an untyped variable in Lambda and Ski
++ domains, a variable has a name represented by a String.

Untyped() : Exports == Implementation where

  NNI==> NonNegativeInteger
  PR ==> Record(res:%,pout:NNI)
    ++ parse result includes string returned and new index

  Exports ==> VarCat()

  Implementation ==> Type add

    Rep := Record(nme:String)

    -- constructs variable with a name but no type
    var(n:String):% ==
      [n]

    -- since this is an untyped implementation the type value
    -- is ignored
    var(n:String,t:VarTyp):% ==
      [n]

    -- returns the name of the variable.
    name(v:%):String ==
      v.nme

    -- returns the type of the variable. This may be a compund type, for
    -- instance ["a","b"] represents a->b a function from type a to type b
    -- untyped implementations return []
    type(v:%):VarTyp ==
      varTyp("")

    -- returns the name and the type in string form.
    toString(v:%):String ==
      v.nme

    -- construct a variable by parsing a string
    -- pin is index to string at start of parse
    -- pout is index to string at end of parse
    parseVar(t1: String,pin:NNI):Record(rft:%,pout:NNI) ==
      vnm:String := ""
      pt:NNI := pin
      ch := qelt(t1,pt)
      --sayTeX$Lisp concat("st ch=",ch::String)
      while alphanumeric?(ch) repeat
        vnm := concat(vnm,ch)
        pt := pt + (1::NNI)
        if pt > maxIndex(t1) then
          return [var(vnm),pt]
        ch := qelt(t1,pt)
      if ch = char(":") then
        -- read type
        --sayTeX$Lisp concat("st ch=",ch::String)
        r := parseTyp(t1,pt)$VarTyp
        pt:= r.pout
        -- since this instance is untyped we ignore result
      [var(vnm),pt]

    -- return true if equal, that is names are equal (since there are
    -- no types that is all that is required) in the case of typed
    -- implementations then they would also have to be equal.
    x = y ==
      x.nme = y.nme

    -- output
    coerce(n: %):OutputForm ==
      toString(n)::OutputForm
@

Next an implementation of the VarCat category which is intended to work with
typed variables:

\section{domain TYPED Typed}
<<domain TYPED Typed>>=
)abbrev domain TYPED Typed
++ Author: Martin Baker
++ Date Created: April 2011
++ Date Last Updated: April 2011
++ Basic Operations:
++ Related Constructors: lambda, ski
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/
++ Description: Typed represents an typed variable in Lambda and Ski
++ domains, a variable has a name represented by a String and a type
++ represented by a list of strings.

Typed() : Exports == Implementation where

  NNI==> NonNegativeInteger
  PR ==> Record(res:%,pout:NNI)
    ++ parse result includes string returned and new index

  Exports ==> VarCat()

  Implementation ==> Type add

    Rep := Record(nme:String,typ:VarTyp)

    -- constructs variable with a name but no type
    var(n:String):% ==
      [n,varTyp("")]

    -- since this is an untyped implementation the type value
    -- is ignored
    var(n:String,t:VarTyp):% ==
      [n,t]

    -- returns the name of the variable.
    name(v:%):String ==
      v.nme

    -- returns the type of the variable. This may be a compound type, for
    -- instance ["a","b"] represents a->b a function from type a to type b
    type(v:%):VarTyp ==
      v.typ

    -- returns the name and the type in string form. This may be a compound
    -- type, for instance ["a","b"] represents a->b a function from type a
    -- to type b
    toString(v:%):String ==
      s:String := concat([v.nme,":",toString(v.typ)])
      s

    -- construct a variable by parsing a string
    -- pin is index to string at start of parse
    -- pout is index to string at end of parse
    parseVar(t1: String,pin:NNI):Record(rft:%,pout:NNI) ==
      vnm:String := ""
      pt:NNI := pin
      ch := qelt(t1,pt)
      --sayTeX$Lisp concat("st ch=",ch::String)
      while alphanumeric?(ch) repeat
        vnm := concat(vnm,ch)
        pt := pt + (1::NNI)
        if pt > maxIndex(t1) then
          return [var(vnm),pt]
        ch := qelt(t1,pt)
      if ch = char(":") then
        -- read type
        --sayTeX$Lisp concat("st ch=",ch::String)
        pt := pt + (1::NNI)
        if pt > maxIndex(t1) then
          return [var(vnm),pt]
        r := parseTyp(t1,pt)$VarTyp
        pt:= r.pout
        return [var(vnm,r.rft),pt]
      [var(vnm),pt]

    -- return true if equal, that is names are equal (since there are
    -- no types that is all that is required) in the case of typed
    -- implementations then they would also have to be equal.
    x = y ==
      (x.nme = y.nme) and (x.typ = y.typ)

    -- output
    coerce(n: %):OutputForm ==
      toString(n)::OutputForm
@

\section{Intuitionistic Logic}
The intuitionisticLogic domain implements a Heyting algebra implied
by intuitionistic logic similar to boolean algebra.

Intuitionistic or constructive logic is similar to classical logic
but where the law of excluded middle is not used.

Note: Please be aware that changes may be made in the future to improve
      and correct intuitionistic logic domain, such as:
   - investigate change of meaning of '=' for intuitionistic logic to
     represent equivalence rather than equality.
   - implement more complete algorithm to decide if two (quantifier-free)
     intuitionistic formulas are equivalent.
\section{Intuitionistic Logic Tutorial}
Intuitionistic logic has mant possible values: true "T", false "_|_" and
infinitely many other values generated by constructs such as inverse.
These can be constructed as follows:

(1) -> logicF()

   (1)  "_|_"
                                                             Type: ILogic
(2) -> logicT()

   (2)  "T"
                                                             Type: ILogic
(3) -> ~logicT()

   (3)  "_|_"
                                                             Type: ILogic

This logic has different rules from boolean algebra and all constructions
do not reduce to true or false. To test out our constructs we will use
the following list:

(4) -> l:List ILogic := [logicF(),logicT(),proposition("a"),~proposition("a"),proposition("b"),~proposition("b")]

 LISP output:
((0 0) (0 1) (1 a) (3 0 1 a) (1 b) (3 0 1 b))
                                                       Type: List(ILogic)

First we will try 'not':

(5) -> [(~j)::OutputForm for j in l]

   (5)  ["~(_|_)","_|_","~(a)","~(~(a))","~(b)","~(~(b))"]
                                                   Type: List(OutputForm)

We can print a truth table for 'and' and 'or'. This is the same as
boolean logic for true/false values and extended for the unproven case.

(6) -> matrix[ [(k /\ j)::OutputForm for j in l] for k in l]

     (6)
    SUB
       matrix
       ["_|_","_|_","_|_","_|_","_|_","_|_"]
       ["_|_","T","(T/\a)","(T/\~(a))","(T/\b)","(T/\~(b))"]
       ["_|_","(a/\T)","a","_|_","(a/\b)","(a/\~(b))"]
       ["_|_","(~(a)/\T)","_|_","~(a)","(~(a)/\b)","(~(a)/\~(b))"]
       ["_|_","(b/\T)","(b/\a)","(b/\~(a))","b","_|_"]
       ["_|_","(~(b)/\T)","(~(b)/\a)","(~(b)/\~(a))","_|_","~(b)"]
                                                               Type: Symbol

(7) -> matrix[ [(k \/ j)::OutputForm for j in l] for k in l]

     (7)
    SUB
       matrix
       ["(_|_\/_|_)","T","(_|_\/a)","(_|_\/~(a))","(_|_\/b)","(_|_\/~(b))"]
       ["T","T","T","T","T","T"]
       ["(a\/_|_)","T","(a\/a)","(a\/~(a))","(a\/b)","(a\/~(b))"]
       ["(~(a)\/_|_)","T","(~(a)\/a)","(~(a)\/~(a))","(~(a)\/b)","(~(a)\/~(b))"]
       ["(b\/_|_)","T","(b\/a)","(b\/~(a))","(b\/b)","(b\/~(b))"]
       ["(~(b)\/_|_)","T","(~(b)\/a)","(~(b)\/~(a))","(~(b)\/b)","(~(b)\/~(b))"]
                                                               Type: Symbol

'implies' produces the following truth table.

(8) -> matrix[ [implies(k,j)::OutputForm for j in l] for k in l]


   (8)
    SUB
       matrix
       ["T","T","(_|_->a)","(_|_->~(a))","(_|_->b)","(_|_->~(b))"]
       ["_|_","T","(T->a)","(T->~(a))","(T->b)","(T->~(b))"]
       ["(a->_|_)","(a->T)","(a->a)","(a->~(a))","(a->b)","(a->~(b))"]
       ["(~(a)->_|_)", "(~(a)->T)", "(~(a)->a)", "(~(a)->~(a))", "(~(a)->b)",
        "(~(a)->~(b))"]
       ["(b->_|_)","(b->T)","(b->a)","(b->~(a))","(b->b)","(b->~(b))"]
       ["(~(b)->_|_)", "(~(b)->T)", "(~(b)->a)", "(~(b)->~(a))", "(~(b)->b)",
        "(~(b)->~(b))"]
                                                               Type: Symbol


Now that we can do intuitionistic logic with constant values we can
go on to represent theories. We can enter a symbolic value as follows:


(9) -> proposition("p1")

   (9)  "p1"
                                                             Type: ILogic

When applying a symbolic value, then it may not possible to compress
as a single node, so the result remains as a tree. So (13) can be
reduced to a single value _|_ because the result does not depend
on 'a', however in (12) we cannot reduce to a single value.

(10) -> proposition("a") /\ proposition("b")

   (10)  "(a/\b)"
                                                             Type: ILogic
(11) -> implies(proposition("a"),proposition("b"))

   (11)  "(a->b)"
                                                             Type: ILogic
(12) -> proposition("a") /\ logicT()

   (12)  "(a/\T)"
                                                             Type: ILogic
(13) -> proposition("a") /\ logicF()

   (13)  "_|_"
                                                             Type: ILogic

\section{domain ILOGIC ILogic}
<<domain ILOGIC ILogic>>=
)abbrev domain ILOGIC ILogic
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: June 2011
++ Basic Operations:
++ Related Constructors:
++ Keywords: intuitionisticLogic
++ Description: ILogic is an algebra with
++ true, false and other 'unproven' values
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/

ILogic(): Exports == Implementation where

 NNI==> NonNegativeInteger

 Exports == with
  logicT:() -> %
    ++ true is a logical constant.
  logicF:() -> %
    ++ false (contradiction) is a logical constant.
  proposition:(s:String) -> %
    ++ Constructs a proposition
  implies: (%, %) -> %
    ++ implies(a,b) returns the logical implication
    ++ of ILogic a and b.
    ++ a is premise, b is conclusion, result is false (contradiction)
    ++ if premise=true and conclusion=false
    ++ does not mean there is a causal connection
  _~: % -> %
    ++ ~(x) returns the logical complement of x.
  _/_\: (a:%, b:%) -> %
    ++ /\ returns the logical 'meet', e.g. 'and'.
  _\_/: (a:%, b:%) -> %
    ++  \/ returns the logical 'join', e.g. 'or'.
  redux:(n: %) -> %
    ++ attempt to simplify theory
    ++ apply recursively to subnodes
    ++ normally this should not be necessary since logic values are
    ++ interpreted when constructed
  "=": (a:%, b:%) -> Boolean
    ++ returns true (boolean true) if intuitionisticLogic values
    ++ are the same.
    ++ Translates from Intuitionistic Logic to Boolean Logic
  children:(n: %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  value:(n: %) -> NNI
    ++ returns:
    ++ 0=false
    ++ 1=true
    ++ 3=proposition
    ++ 4=compound
  toString: (n: %) -> String
    ++ output
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         const:Record(val:NNI),_
         var:Record(str:String),_
         binaryOp:Record(typ:NNI,c1:%, c2:%),_
         unaryOp:Record(typ:NNI,c1:%)_
         )

  -- Constructs a proposition
  proposition(s:String): % == [[s]]

  -- literal constructors
  logicT() == [[1::NNI]]
  logicF() == [[0::NNI]]

  -- not operator: returns the logical complement
  -- in general case 'x' this will generate a new element '~x'
  -- but for specific cases we can apply the simplification rules:
  -- ~T -> F
  -- ~(~T) -> T
  ~ b ==
    -- apply rule: ~T -> F
    if (b case const) then
      if (b.const.val = 1::NNI) then return [[0::NNI]]
    -- apply rule: ~(~T) -> T
    if (b case unaryOp) then
      c:% := b.unaryOp.c1
      if (c case unaryOp) then
        d:% := c.unaryOp.c1
        if (d.const.val = 1::NNI) then return [[0::NNI]]
    [[0::NNI,b]]

  -- /\ returns the logical 'meet', e.g. 'and'.
  --
  -- simplification rules:
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  --
  _/_\(a:%, b:%) ==
    -- apply rule: F /\ x -> F
    if (a case const) then
      if (a.const.val = 0::NNI) then return [[0::NNI]]
    -- apply rule: x /\ F -> F
    if (b case const) then
      if (b.const.val = 0::NNI) then return [[0::NNI]]
    -- apply rule: x /\ x -> x
    if a=b then
      return a
    -- apply rule: x /\ ~x -> F
    if a=(~b) then
      return [[0::NNI]]
    -- apply rule: ~x /\ x -> F
    if (~a)=b then
      return [[0::NNI]]
    [[1::NNI,a,b]]


  -- \/ returns the logical 'join', e.g. 'or'.
  --
  -- simplification rules:
  -- T \/ x -> T
  -- x \/ T -> T
  --
  _\_/(a:%, b:%) ==
    if (a case const) then
      if (a.const.val = 1::NNI) then return [[1::NNI]]
    if (b case const) then
      if (b.const.val = 1::NNI) then return [[1::NNI]]
    [[2::NNI,a,b]]

  -- implies(a,b) returns the logical implication
  -- of ILogic a and b.
  -- a is premise, b is conclusion, result is false (contradiction)
  -- if premise=true and conclusion=false
  -- does not mean there is a causal connection
  implies(a:%, b:%) ==
    if (a case const) and (b case const) then
      --if (a.const.val = 1::NNI) and (b.const.val = 2::NNI) then return [[2::NNI]]
      if (a.const.val ~= 0::NNI) and (b.const.val = 0::NNI) then return [[0::NNI]]
      return [[1::NNI]]
    [[0::NNI,a,b]]

  -- attempt to simplify theory
  -- apply recursively to subnodes
  -- normally this should not be necessary since logic values are
  -- interpreted when constructed
  --
  -- simplification rules:
  -- ~T -> F
  -- ~(~T) -> T
  -- ~x /\ x -> F
  -- x /\ ~x -> F
  -- x /\ x -> x
  -- F /\ x -> F
  -- x /\ F -> F
  -- T \/ x -> T
  -- x \/ T -> T
  --
  redux(n: %):% ==
    if n case const then
      return n
    if n case var then
      return n
    if n case binaryOp then
      if n.binaryOp.typ=0::NNI then return implies(n.binaryOp.c1,n.binaryOp.c2)
      if n.binaryOp.typ=1::NNI then return _/_\(n.binaryOp.c1,n.binaryOp.c2)
      if n.binaryOp.typ=2::NNI then return _\_/(n.binaryOp.c1,n.binaryOp.c2)
    if n case unaryOp then
      return ~(n.unaryOp.c1)
    n

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n: %):Boolean == (n case var) or (n case const)

  -- returns:
  -- 0=false
  -- 1=true
  -- 3=proposition
  -- 4=compound
  value(n: %):NNI ==
    if n case const then
      if (n.const.val = 0::NNI) then return 0::NNI
      if (n.const.val = 1::NNI) then return 1::NNI
      return 2::NNI
    if n case var then
      return 3::NNI
    4::NNI

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  children(n: %):List % ==
    if atom?(n) then return []
    if n case binaryOp then
      return [n.binaryOp.c1,n.binaryOp.c2]
    if n case unaryOp then
      return [n.unaryOp.c1]

  -- returns true (boolean true) if intuitionisticLogic values
  -- are the same. The terms must match exactly not just be
  -- equivalent, that is x /\ 1 is not equal to x
  -- Translates from Intuitionistic Logic to Boolean Logic
  a = b ==
    if (a case const) and (b case const) then
      if (a.const.val = 0::NNI) and (b.const.val = 0::NNI) then return true
      if (a.const.val = 1::NNI) and (b.const.val = 1::NNI) then return true
      --if (a.const.val = 2::NNI) and (b.const.val = 2::NNI) then return true
      return false
    if (a case var) and (b case var) then
      -- variable node so compare names
      if a.var.str = b.var.str then return true
      return false
    if (a case binaryOp) and (b case binaryOp) then
      -- binary node which has two subnodes c1 and c2
      if (a.binaryOp.typ ~= b.binaryOp.typ) then return false
      if (a.binaryOp.c1 = b.binaryOp.c1) and (a.binaryOp.c2 = b.binaryOp.c2) then return true
      return false
    if (a case unaryOp) and (b case unaryOp) then
      -- unary node which has a subnode c1
      if (a.unaryOp.typ ~= b.unaryOp.typ) then return false
      if a.unaryOp.c1 = b.unaryOp.c1 then return true
      return false
    false

  -- return string representation
  toString(n: %):String ==
    if n case const then
      if (n.const.val = 0::NNI) then return "__|__"
      if (n.const.val = 1::NNI) then return "T"
      return "?"
    if n case var then
      return n.var.str
      --sayTeX$Lisp concat(["toString case i1=",s])
      --sayTeX$Lisp n
    if n case binaryOp then
      -- binary node which has two subnodes c1 and c2
      s1:String := "->"
      if n.binaryOp.typ = 1::NNI then s1:="/\"
      if n.binaryOp.typ = 2::NNI then s1:="\/"
      return concat(["(",toString(n.binaryOp.c1),s1,toString(n.binaryOp.c2),")"])
    if n case unaryOp then
      -- unary node which has a subnode c1
     return concat(["~(",toString(n.unaryOp.c1),")"])
    "error"

  -- output
  coerce(n: %):OutputForm ==
    toString(n)::OutputForm

@

\section{lambda-Calculus}
for more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/

\section{Notation}

Externally a fairly standard notation is used, as may be familiar to
someone using a textbook to study lambda-calculus, or as close as we can get
without using unicode. I have used the '\' symbol to stand for lambda. At
some stage in the future it may be possible to use unicode lambda symbol
but not yet due to compatibility issues.

Internally the domain stores bound variables using De Bruijn index,
in most cases this should not concern the user as I/O uses string
names for variables. Converting bound variables internally to index
values means that the same variable name can be used, in different
lambda terms, without ambiguity and without the need for
alpha-substitution.

De Bruijn index which is a integer where

    0=inside current (inner) lambda term
    1= next outer lambda term
    2= next outer and so on
    ...

We will see how this works in the tutorial below.

So internally the lambda-calculus is stored as a binary tree structure
using the following syntax:

<term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"

where:

    \ = lambda
    n = De Bruijn index which is a integer where,
        0=inside inner lambda term,
        1= next outer lambda term,
        2= next outer and so on.
    var = a string representation of variable (this form is used for
          unbound variables)
    brackets can be used around whole terms.

\section{Tutorial}

On this page we will be working with 'untyped' variables so we create
an instance called UNTYP to simplify notation:

(1) -> UNTYP := Lambda Untyped

   (1)  Lambda(Untyped)
                                                           Type: Type

\section{Constructors}

First we can enter some variables, at the moment they are not inside
a lambda-term so they can't yet be bound, but later we can put them into
a lambda-term..

A numeric name is interpreted as a De Bruijn index when put inside
a lambda-term, although we don't need this notation for I/O unless we are
trying to avoid some ambiguity, because free and bound variables can
be constructed by giving the variable name as a string. So in (4) is
not yet a valid term on its own but it will be when put inside a
lambda-term, when this is done it will be given the name of the bound
variable rather than "0".

Internally a string name will be converted to a De Bruijn index when
put inside a matching lambda-term, otherwise it will be interpreted as a
free variable.

(2) -> v1 := lambda(var("x")$Untyped)$UNTYP

   (2)  "x"
                                                    Type: Lambda(Untyped)

(3) -> v2 := lambda(var("y")$Untyped)$UNTYP

   (3)  "y"
                                                    Type: Lambda(Untyped)

(4) -> v3 := lambda(0)$UNTYP

   (4)  "0"
                                                    Type: Lambda(Untyped)

This can be built up into more complex lambda terms by using compound
terms (as in (5)) and the lambda-term itself (as in (6)).

Each lambda-term can only have one bound variable, if more than one bound
variable is required then lambda-terms can be nested. lambda-term requires that
the bound variable be given a name.

(5) -> n1 := lambda(v1,v2)$UNTYP

   (5)  "(x y)"
                                                    Type: Lambda(Untyped)

(6) -> n2 := lambda(n1,var("x")$Untyped)$UNTYP

   (6)  "(\x.(x y))"
                                                    Type: Lambda(Untyped)

In (7) 'x' is a the bound variable and so, when the lambda-term was created,
this will be converted to De Bruijn index, in (7) we call toString to
see the internal representation:

In (8) we see that when entered as a numeric index the bound variable
will still be displayed as a string.

In (9) and (10) we can see that the 'unbind' function can be used to
unbind the bound variable 'x' that is, although 'x' has the same string
value as the lambda term, it is treated as though it were different.
We can see this because the toString output does not have a index value.
In (11) we call 'bind' to re-bind it.

(7) -> toString(n2)$UNTYP

   (7)  "(\x.(0 y))"
                                                             Type: String
(8) -> n3 := lambda(v3,var("x")$Untyped)$UNTYP

   (8)  "(\x.x)"
                                                    Type: Lambda(Untyped)
(9) -> u2 := unbind(n2)$UNTYP

   (9)  "(\x.(x y))"
                                                    Type: Lambda(Untyped)
(10) -> toString(u2)$UNTYP

   (10)  "(\x.(x y))"
                                                             Type: String
(11) -> toString(bind(u2))$UNTYP

   (11)  "(\x.(0 y))"
                                                             Type: String

So we can already construct any type of lambda term, however its a bit
tedious to construct complex lambda terms in this way, an easier way is
to use 'parseLambda' to construct the lambda term from a string. Again
we can enter variables as either alpha or numeric characters depending
on whether we want to specify the index value directly or allow the
code to generate it.

In (14) we can see the use of numeric terms to avoid the ambiguity
caused by nested lambda-terms with the same name.

(12) -> n4 := parseLambda("\x.\y. y x")$UNTYP

   (12)  "(\x.(\y.(x y)))"
                                                    Type: Lambda(Untyped)
(13) -> toString(n4)$UNTYP

   (13)  "(\x.(\y.(0 1)))"
                                                             Type: String
(14) -> n4a := parseLambda("\x.\x. 0 1")$UNTYP

   (14)  "(\x.(\x'.(x x')))"
                                                    Type: Lambda(Untyped)
(15) -> toString(n4a)$UNTYP

   (15)  "(\x.(\x.(0 1)))"
                                                             Type: String
(16) -> unbind(n4a)$UNTYP

   (16)  "(\x.(\x'.(x x)))"
                                                    Type: Lambda(Untyped)

\section{beta-substitution}

The command: subst:(n,a,b) substitutes 'a' for 'b' in 'n' as follows:

(17) -> subst(n2,v2,v1)$UNTYP

   (17)  "(\x.(x y))"
                                                    Type: Lambda(Untyped)
(18) -> subst(n2,v1,v2)$UNTYP

   (18)  "(\x.(x x))"
                                                    Type: Lambda(Untyped)

\section{Issues}

I realise that Axiom/FriCAS already has a way to create anonymous
functions using +-> in a lambda-calculus sort of way. But the aim here
is to represent lambda-calculus as a pure mathematical structure so that
we can experiment with the properties of this structure without the
messy features that are required for a practical computer language.
I also need a domain structure which is related to SKI combinators
and IntuitionisticLogic domain and can be coerced to and from these
other domain types as demonstrated on this page.

I also realise that this is written in SPAD which is written in
Lisp which is based on lambda-Calculus (perhaps it could later be
optimised by having direct calls to Lisp?)
Relationship to Other Domains

\section{Relationship to Other Domains}

lambda-calculus can be coerced to and from SKI combinators. For a tutorial
about how to coerce to/from this algebra see below.


\section{domain LAMBDA Lambda}
<<domain LAMBDA Lambda>>=
)abbrev domain LAMBDA Lambda
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: April 2011
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
++ An implementation of untyped lambda-calculus

Lambda(UT): Exports == Implementation where

 UT:VarCat
 NNI==> NonNegativeInteger
 PR ==> Record(rft:%,pout:NNI)
   ++ parse result includes term returned and new index

 Exports == with
  lambda:(deBruijn:NNI) -> %
    ++ Constructs a reference to a bound variable from its deBruijn
    ++ index
  lambda:(varNme:UT) -> %
    ++ Constructs a reference to a free variable
  lambda:(x:%,y:%) -> %
    ++ Constructs a node containing multiple terms
  lambda:(x:%,t1: UT) -> %
    ++ Constructs lambda term and bind any variables with the name provided
  parseLambda:(t1: String) -> %
    ++ Constructs nested lambda terms from a string
    ++ notation assumes format like this:
    ++ <term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"
    ++ where:
    ++ \ = lambda (I would like to use unicode lambda symbol but
    ++             I would also like to keep maximum compatibility
    ++             with non-unicode versions of Lisp)
    ++ n = De Bruijn index which is a integer where, 1=inside inner
    ++             lambda term, 2= next outer lambda term, 3= next
    ++             outer and so on.
    ++ brackets can be used around whole terms.
    ++ This requires the user to work out the De Bruijn index values
    ++ perhaps this could be improved later.
  parseTerm:(t1: String,pin:NNI) -> PR
    ++ parseTerm is used by parseLambda. It would rarely be called
    ++ externally but it is here to allow it to call parseLambda
    ++ that is to allow circular calls
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is free or bound variable
    ++ otherwise return false if this is a compound or lambda definition
  isCompound?:(n: %) -> Boolean
    ++ returns true if this is a compound term containing two nodes
  isLambda?:(n: %) -> Boolean
    ++ returns true if this is a lambda definition
  free?:(n: %) -> Boolean
    ++ if this is a lambda term then is it free, that is does
    ++ its variable appear in its expression
  children:(n: %) -> List %
    ++ returns 2 child nodes if this is a compound term
    ++ returns 1 child node if this is a lamda term
    ++ otherwise returns []
  variable:(n: %) -> UT
    ++ if this is a lambda term then return the bound variable
  subst:(n: %,a: %,b: %) -> %
    ++ substitution of 'a' for 'b' in 'n'
  bind:(n: %) -> %
    ++ if this is a lambda term then replace string name in sub-nodes
    ++ with De Bruijn index
  unbind:(n: %) -> %
    ++ if this is a lambda term then replace De Bruijn index in sub-nodes
    ++ with string name
  redux:(n: %) -> %
    ++ beta reduction - apply beta reduction recusivly to all subnodes
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal (deep search) that is: all terms
    ++ at all levels in tree must be alpha-equivalent to return true
    ++ That is the names, but not the deBruijn index, of the
    ++ bound variables can be different.
    ++ beta-equivalenty is not implemented because it is not decidable.
  toStringConven: (n:%,boundL: List String) -> String
    ++ return string representation using conventional notation, that is
    ++ deBruijn index is replaced by name using String value for bound variables.
    ++ notation assumes association to the left, in the absence of
    ++ brackets, the term to the left binds more tightly than the
    ++ one on the right.
  toString: (n: %) -> String
    ++ return string representation using deBruijn index for
    ++ bound variables.
    ++ notation assumes association to the left, in the absence of
    ++ brackets, the term to the left binds more tightly than the
    ++ one on the right.
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         boundTerm:Record(varBound:NNI),_
         freeTerm:UT,_
         compoundTerm:Record(c1:%, c2:%),_
         lambdaTerm:Record(c3:%, nm:UT)_
         )

  -- Constructs a reference to a bound variable from its deBruijn
  -- index
  lambda(n1:NNI): % == [[n1]]

  -- Constructs a reference to a free variable from its name
  lambda(var:UT): % == [var]

  -- Constructs a node containing multiple terms
  lambda(x:%,y:%): % == [[x,y]]

  -- Constructs lambda term and bind any variables with the name provided
  lambda(x:%,t1: UT): % ==
    lt:% := [[x,t1]]
    --sayTeX$Lisp concat(["creating lambda(",toString(x),",",t1") giving:",toString(lt)])
    --sayTeX$Lisp concat(["bound ver=",toString(bind(lt))])
    bind(lt)

  -- returns 2 child nodes if this is a compound term
  -- returns 1 child node if this is a lamda term
  -- otherwise returns []
  children(n: %):List % ==
    if atom?(n) then return []
    if n case compoundTerm then
      return [n.compoundTerm.c1,n.compoundTerm.c2]
    if n case lambdaTerm then
      return [n.lambdaTerm.c3]
    []

  -- if this is a lambda term then return the name of the bound variable
  variable(n: %):UT ==
    if n case lambdaTerm then
      return n.lambdaTerm.nm
    var("error")$UT

  parseLambdaTerm(t1: String,pin:NNI):PR ==
    --sayTeX$Lisp concat(["parseLambdaTerm(",t1,",",string(pin),")"])$String
    p1 := pin
    ch := qelt(t1,p1)
    if not (ch = char("\")) then
      error "lambda term must start with \"
      return [[[0::NNI]],p1]
    p1 := p1 + (1::NNI)
    if p1 > maxIndex(t1) then
      error "lambda term not complete"
      return [[[0::NNI]],p1]
    r := parseVar(t1,p1)$UT
    p1 := r.pout
    ch := qelt(t1,p1)
    --sayTeX$Lisp concat(["parseLambdaTerm'(",t1,",",string(p1),")"])$String
    if not (ch = char(".")) then
      error "lambda term must have ."
      return [[[0::NNI]],p1]
    p1 := p1 + (1::NNI)
    --sayTeX$Lisp concat(["parseLambdaTerm''(",t1,",",string(p1),")"])$String
    if p1 > maxIndex(t1) then
      error "lambda term must contain something"
      return [[[0::NNI]],p1]
    --sayTeX$Lisp concat(["parseLambdaTerm'''(",t1,",",string(p1),")"])$String
    r2 := parseTerm(t1,p1)
    ex:% := r2.rft
    p1 := r2.pout
    [lambda(ex,r.rft),p1]

  parseBracketTerm(t1: String,pin:NNI):PR ==
    p1 := pin
    ch := qelt(t1,p1)
    if not (ch = char("(")) then
      error "bracket term must start with ("
      return [[[0::NNI]],p1]
    p1 := p1 + (1::NNI)
    if p1 > maxIndex(t1) then
      error "opening but no closing bracket"
      return [[[0::NNI]],p1]
    r2 := parseTerm(t1,p1)
    trm := r2.rft
    p1 := r2.pout
    ch := qelt(t1,p1)
    if not (ch = char(")")) then
      error "can't find closing bracket"
      return [[[0::NNI]],p1]
    p1 := p1 + (1::NNI)
    [trm,p1]

  parseVariableTerm(t1: String,pin:NNI):PR ==
    p1 := pin
    inx:NNI := 0 -- holds De Bruijn index while its being read
    ch := qelt(t1,p1)
    --sayTeX$Lisp concat("pv ch=",ch::String)
    while digit?(ch) repeat
      if ch = char("0") then inx := inx*10
      if ch = char("1") then inx := inx*10 + 1
      if ch = char("2") then inx := inx*10 + 2
      if ch = char("3") then inx := inx*10 + 3
      if ch = char("4") then inx := inx*10 + 4
      if ch = char("5") then inx := inx*10 + 5
      if ch = char("6") then inx := inx*10 + 6
      if ch = char("7") then inx := inx*10 + 7
      if ch = char("8") then inx := inx*10 + 8
      if ch = char("9") then inx := inx*10 + 9
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then return [lambda(inx),p1]
      ch := qelt(t1,p1)
    [lambda(inx),p1]

  parseTerm(t1: String,pin:NNI):PR ==
    p1 := pin
    res:% := [[0::NNI]]
    ch := qelt(t1,p1)
    --sayTeX$Lisp concat(["parseTerm ch=",ch::String," p1=",string(p1)])$String
    -- first remove leading spaces
    while ch = char(" ") repeat
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayTeX$Lisp concat(["parseTerm(",t1,") 1 giving:",toString(res)])
        return [res,p1]
      ch := qelt(t1,p1)
    r:PR:= [res,p1]
    if ch = char("\") then r := parseLambdaTerm(t1,p1)
    if ch = char("(") then r := parseBracketTerm(t1,p1)
    if digit?(ch) then r := parseVariableTerm(t1,p1)
    res := r.rft
    p1 := r.pout
    if alphabetic?(ch) then
      r2 := parseVar(t1,p1)$UT
      res := lambda(r2.rft)
      p1 := r2.pout
    -- now check for compound term
    if p1 > maxIndex(t1) then
      --sayTeX$Lisp concat(["parseTerm(",t1,") 2 giving:",toString(res)])
      return [res,p1]
    ch := qelt(t1,p1)
    if ch = char(" ") then
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayTeX$Lisp concat(["parseTerm(",t1,") 3 giving:",toString(res)])
        return [res,p1]
      r := parseTerm(t1,p1)
      p1 := r.pout
      res := lambda(res,r.rft)
    --sayTeX$Lisp concat(["parseTerm(",t1,") 4 giving:",toString(res)])
    [res,p1]

  -- Constructs nested lambda terms from a string
  -- notation assumes format like this:
  -- <term> ::= "\" var "."<term> | n | <term><term> | "("<term>")"
  -- where:
  -- \ = lambda (I would like to use unicode lambda symbol but
  --             I would also like to keep maximum compatibility
  --             with non-unicode versions of Lisp)
  -- n = De Bruijn index which is a integer where, 1=inside inner
  --             lambda term, 2= next outer lambda term, 3= next
  --             outer and so on.
  -- brackets can be used around whole terms.
  -- This requires the user to work out the De Bruijn index values
  -- perhaps this could be improved later.
  parseLambda(t1: String): % ==
    r := parseTerm(t1,minIndex(t1)::NNI)
    --sayTeX$Lisp concat(["parseLambda(",t1,") giving:",toString(tm)])
    r.rft

  -- returns true if this is an atom, that is free or bound variable
  -- otherwise return false if this is a compound or lambda definition
  atom?(n: %):Boolean == (n case boundTerm) or (n case freeTerm)

  -- returns true if this is a compound term containing two nodes
  isCompound?(n: %):Boolean == (n case compoundTerm)

  -- returns true if this is a lambda definition
  isLambda?(n: %):Boolean == (n case lambdaTerm)

  -- does s not appear in n
  freeVariable?(n: %,s:UT):Boolean ==
    if n case freeTerm then
      if n.freeTerm=s then return false
    if n case lambdaTerm then
      if not freeVariable?(n.lambdaTerm.c3,s) then return false
    if n case compoundTerm then
      if not freeVariable?(n.compoundTerm.c1,s) or _
         not freeVariable?(n.compoundTerm.c2,s) then return false
    true

  -- return false if any bound terms
  freeVariable?(n: %,i:NNI):Boolean ==
    if n case boundTerm then
      if n.boundTerm.varBound=i then return false
    if n case lambdaTerm then
      if not freeVariable?(n.lambdaTerm.c3,(i+1)::NNI) then return false
    if n case compoundTerm then
      if (not freeVariable?(n.compoundTerm.c1,i)) or _
         (not freeVariable?(n.compoundTerm.c2,i)) then return false
    true

  -- if this is a lambda term then is it free, that is does
  -- its variable appear in its expression
  free?(n: %):Boolean ==
    if n case lambdaTerm then
      --s1:String := name(n.lambdaTerm.nm)$UT
      return freeVariable?(n.lambdaTerm.c3,0::NNI)
    sayTeX$Lisp concat("warning free called on non-lambda term",toString(n))
    false

  -- return string representation using conventional notation, that is
  -- deBruijn index is replaced by name using String value for bound variables.
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  toStringConven(n:%,boundL: List String):String ==
    s:String := ""
    --sayTeX$Lisp concat(["toStringConven(",toString(n),")"])
    if n case boundTerm then
      i:NNI := n.boundTerm.varBound + 1
      --sayTeX$Lisp concat(["toStringConven(",toString(n),") i=",string(i)," #boundL=",string(#boundL)])
      if i > 0 and i <= #boundL then return boundL.i
      s := string(n.boundTerm.varBound)
      --sayTeX$Lisp s
    if n case freeTerm then
      s := name(n.freeTerm)$UT
    if n case compoundTerm then
      s := concat(["(",toStringConven(n.compoundTerm.c1,boundL)," ",toStringConven(n.compoundTerm.c2,boundL),")"])
    if n case lambdaTerm then
      -- variable node so print name
      varName:String := name(n.lambdaTerm.nm)$UT
      while member?(varName,boundL) repeat
        varName := concat(varName,"'")
      boundL2: List String := concat(boundL,varName)
      s := concat(["(\",varName,".",toStringConven(n.lambdaTerm.c3,boundL2),")"])
    s

  -- return string representation using deBruijn index for
  -- bound variables.
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  -- boundTerm:Record(varBound:NNI, ck:NNI),
  -- freeTerm:Record(varUnbound:String),_
  -- compoundTerm:Record(c1:%, c2:%),
  -- lambdaTerm:Record(c3:%, nm:String)
  toString(n:%):String ==
    s:String := ""
    if n case boundTerm then
      s := string(n.boundTerm.varBound)
      --sayTeX$Lisp s
    if n case freeTerm then
      s := toString(n.freeTerm)$UT
    if n case compoundTerm then
      s := concat(["(",toString(n.compoundTerm.c1)," ",toString(n.compoundTerm.c2),")"])
    if n case lambdaTerm then
      -- variable node so print name
      s := concat(["(\",toString(n.lambdaTerm.nm)$UT,".",toString(n.lambdaTerm.c3),")"])
    s

  -- substitution of 'a' for 'b' in 'n'
  subst(n: %,a: %,b: %):% ==
    if n = b then return a
    if (n case compoundTerm) then
      return lambda(subst(n.compoundTerm.c1,a,b),subst(n.compoundTerm.c2,a,b))
    if (n case lambdaTerm) then
      return lambda(subst(n.lambdaTerm.c3,a,b),n.lambdaTerm.nm)
    n

  -- used by bind to replace a given string name in sub-nodes
  -- with De Bruijn index
  bindTerm(n:%,i:NNI,s:UT):% ==
    --sayTeX$Lisp concat(["bindTerm(",toString(n)," map:",string(i)," to ",name(s)$UT,")"])
    if n case boundTerm then
      return lambda(n.boundTerm.varBound)
    if n case freeTerm then
      if n.freeTerm=s then
        --sayTeX$Lisp concat(["convert:",name(s)$UT," to ",string(i)])
        return lambda(i)
      return lambda(n.freeTerm)
    if n case lambdaTerm then
      --sayTeX$Lisp concat(["bindTerm generating lambda(",toString(bindTerm(n.lambdaTerm.c3,i+1,s)),",",name(n.lambdaTerm.nm)$UT,")"])
      return [[bindTerm(n.lambdaTerm.c3,i+1,s),n.lambdaTerm.nm]]
    if n case compoundTerm then
      return lambda(bindTerm(n.compoundTerm.c1,i,s),_
                    bindTerm(n.compoundTerm.c2,i,s))
    n

  -- if this is a lambda term then replace string name in sub-nodes
  -- with De Bruijn index
  bind(n: %):% ==
    --sayTeX$Lisp concat(["bind(",toString(n),")"])
    if (n case lambdaTerm) then
      return [[bindTerm(n.lambdaTerm.c3,0,n.lambdaTerm.nm),n.lambdaTerm.nm]]
    n

  -- used by unbind to replace a given De Bruijn index in sub-nodes
  -- with string name
  unbindTerm(n:%,i:NNI,s:UT):% ==
    --sayTeX$Lisp concat(["unbindTerm(",toString(n)," map:",string(i)," to ",name(s)$UT,")"])
    if n case boundTerm then
      if n.boundTerm.varBound=i then
        --sayTeX$Lisp concat(["convert:",string(i)," to ",name(s)$UT])
        return lambda(s)
      return lambda(n.boundTerm.varBound)
    if n case freeTerm then
      return lambda(n.freeTerm)
    if n case lambdaTerm then
      --sayTeX$Lisp concat(["unbindTerm generating lambda(",toString(unbindTerm(n.lambdaTerm.c3,i+1,s)),",",name(n.lambdaTerm.nm),")"])
      return [[unbindTerm(n.lambdaTerm.c3,i+1,s),n.lambdaTerm.nm]]
    if n case compoundTerm then
      return lambda(unbindTerm(n.compoundTerm.c1,i,s),_
                    unbindTerm(n.compoundTerm.c2,i,s))
    n

  -- if this is a lambda term then replace De Bruijn index in sub-nodes
  -- with string name
  unbind(n: %):% ==
    --sayTeX$Lisp concat(["unbind(",toString(n),")"])
    if (n case lambdaTerm) then
      return [[unbindTerm(n.lambdaTerm.c3,0,n.lambdaTerm.nm),n.lambdaTerm.nm]]
    n

  -- beta reduction - apply beta reduction recusivly to all subnodes
  redux(n: %):% ==
    if atom?(n) then return n -- atom cant be reduced
    if n case compoundTerm then
      -- we are looking for a compound term where the first term is
      -- a lambda expression being applied to the second term.
      term1:% := n.compoundTerm.c1
      term2:% := n.compoundTerm.c2
      if isLambda?(term1) then
        -- apply term1 to term2
        boundVarName:String := name(term1.lambdaTerm.nm)$UT
        return subst(term1,term2,lambda(0::NNI))
      return lambda(redux(term1),redux(term2))
    if n case lambdaTerm then
      return lambda(redux(n.lambdaTerm.c3),n.lambdaTerm.nm)
    n

  -- return true if equal (deep search) that is: all terms
  -- at all levels in tree must be alpha-equivalent to return true
  -- That is the names, but not the deBruijn index, of the
  -- bound variables can be different.
  x = y ==
    if (x case boundTerm) and (y case boundTerm) then
      -- boundTerm so compare deBruijn index
      if x.boundTerm.varBound = y.boundTerm.varBound then return true
      return false
    if (x case freeTerm) and (y case freeTerm) then
      -- freeTerm so compare variables
      if x.freeTerm = y.freeTerm then return true
      return false
    if (x case compoundTerm) and (y case compoundTerm) then
      -- compoundTerm so compare both terms
      if (x.compoundTerm.c1 = y.compoundTerm.c1) and_
         (x.compoundTerm.c2 = y.compoundTerm.c2) then return true
      return false
    if (x case lambdaTerm) and (y case lambdaTerm) then
      -- lambdaTerm only compare body not variable name
      if x.lambdaTerm.c3 = y.lambdaTerm.c3 then return true
      return false
    false

  -- output
  coerce(n: %):OutputForm ==
    toStringConven(n,[])::OutputForm
    --toString(n)::OutputForm
@

\section{SKI Combinators}
for more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/

Ski combinators were introduced by Moses Schoenfinkel and Haskell
Curry with the aim of eliminating the need for variables in
mathematical logic. It is equivalent to lambda calculus but
it can be used for doing, without variables, anything that
would require variables in other systems.

The structure is a self-modifying binary tree.
\section{Tutorial}

On this page we will be working with 'untyped' SKI combinators
so we create an instance called UNTYP to simplify notation:

(1) -> UNTYP := Ski Untyped

   (1)  Ski(Untyped)
                                                           Type: Type

\section{Constructing SKI combinators}

SKI combinators consist of a binary tree structure where the leaves
of the tree are either I, K or S combinators or variables.

The I, K and S combinators can be constructed by using the I(),
K() and S() functions.

Variables (representing functions) can be constructed by
var("x")$Untyped, where x is the name of the variable, we can then
pass this variable to a ski constructor to create a SKI term:

(2) -> m1 := I()$UNTYP

   (2)  "I"
                                                       Type: Ski(Untyped)

(3) -> m2 := K()$UNTYP

   (3)  "K"
                                                       Type: Ski(Untyped)

(4) -> m3 := S()$UNTYP

   (4)  "S"
                                                       Type: Ski(Untyped)

(5) -> v1 := ski(var("x")$Untyped)$UNTYP

   (5)  "x"
                                                       Type: Ski(Untyped)

Compound combinator terms can be constructed by ski(node1,node2) where
node1 and node2 are other combinator terms. Internally combinators are
stored as a binary tree. The notation assumes association to the left,
in the absence of brackets, the term to the left binds more tightly
than the one on the right. So, in the following, we can see that:

    In n2 the second term is an atom so brackets are not required.
    In n3 the second term is compound so brackets are required.

(6) -> n1 := ski(m1,m2)$UNTYP

   (6)  "IK"
                                                       Type: Ski(Untyped)

(7) -> n2 := ski(n1,m3)$UNTYP

   (7)  "IKS"
                                                       Type: Ski(Untyped)
(8) -> n3 := ski(m3,n1)$UNTYP

   (8)  "S(IK)"
                                                       Type: Ski(Untyped)

In addition, to avoid having to build up this node by node, there is a
quicker way to construct SKI combinators. We can construct the whole
binary tree from a single string using the parseSki constructor as
follows. Again the notation assumes association to the left, in the
absence of brackets, the term to the left binds more tightly than the
one on the right.

When we are using parseSki and we have two variables next to each other
(such as 'x y') then we must put a space between the variables, this is
so that we can gave a variable a name consisting of multiple characters.
So 'xy' is a single variable but 'x y' is a two variables. All variables
must start with a lower case letter. The combinators I,K and S do not
need to be separated with a space since they always consist of 1
character.

(9) -> n4 := parseSki("IKS")$UNTYP

   (9)  "IKS"
                                                       Type: Ski(Untyped)
(10) -> n5 := parseSki("S(IK)")$UNTYP

   (10)  "S(IK)"
                                                       Type: Ski(Untyped)

\section{redux}

Now that we have constructed our SKI combinator we can apply the
combinators using the redux function. This allows us to apply the
self-modifing binary tree.

The first combinator to investigate is 'I'. This is a do nothing
combinator:

(11) -> s1 := parseSki("Ix")$UNTYP

   (11)  "I x"
                                                       Type: Ski(Untyped)
(12) -> redux(s1)$UNTYP

x

   (12)  "x"
                                                       Type: Ski(Untyped)

The next combinator to investigate is 'K'. This removes the final
variable:

(13) -> s2 := parseSki("Kx y")$UNTYP

   (13)  "K x y"
                                                       Type: Ski(Untyped)
(14) -> redux(s2)$UNTYP

x

   (14)  "x"
                                                       Type: Ski(Untyped)

The next combinator to investigate is 'S' This applies the first two
functions to the third:

(15) -> s3 := parseSki("Sx y z")$UNTYP

   (15)  "S x y z"
                                                       Type: Ski(Untyped)
(16) -> redux(s3)$UNTYP

x z(y z)

   (16)  "x z(y z)"
                                                       Type: Ski(Untyped)

\section{Secondary Combinators}

Any calculation can be done by some combination of K and S. However
some sequences occur frequently so it is worth assigning them special
letters:

Operator        What it does    SKI equivalent
(normal form)
I       Identity (leave unchanged)      I or SKK or SKS
B       Function composition            S(KS)K
B'      Reverse function composition
C       Swap functions                  S(K(SI))K
K       Form constant function          K
S       Generalized composition         S
W       Doubling or diagonalizing

So we can see in the 3 examples below :

    In 17 that "SKKxy" is equivalent to "xy", that is SKK is identity,
equivalent to I
    In 19 that "S(K(SI))Kxy" is equivalent to "yx", so "S(K(SI))K"
reverses its operands.

(17) -> redux(parseSki("SKKx y")$UNTYP)$UNTYP

K x(K x)y
x y

   (17)  "x y"
                                                       Type: Ski(Untyped)
(18) -> redux(parseSki("S(KS)x y")$UNTYP)$UNTYP

KS y(x y)
S(x y)

   (18)  "S(x y)"
                                                       Type: Ski(Untyped)
(19) -> redux(parseSki("S(K(SI))Kx y")$UNTYP)$UNTYP

K(SI)x(K x)y
Iy(Kx y)
y x

   (19)  "y x"
                                                       Type: Ski(Untyped)

SKI combinators can be coerced to and from lambda-calculus and
intuitionistic logic. For a tutorial about how to coerce to/from these
algebras see this page.
\section{To Do}

These are issues to think about for longer term development of this domain.
Issue 1

Currently this only works with variables, this means that:

    redux applied to 'SKKx y' gives 'x y'
    but redux applied to 'SKK' does not give 'I'

That is, I am looking for a way to 'lift' from working in terms operators
acting on variables to working in terms of operators only.
Issue 2

It would be good to be able to use these combinators to operate on
Axiom/FriCAS functions.
See also

I also have Axiom/FriCAS coding for lambda-caculus, as explained on this
page, where there is explanation and tutorial.


\section{domain SKICOMB SKICombinators}
<<domain SKICOMB SKICombinators>>=
)abbrev domain SKICOMB SKICombinators
++ Author: Martin Baker
++ Date Created: March 2011
++ Date Last Updated: March 2011
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/

SKICombinators(UT): Exports == Implementation where

 UT:VarCat
 NNI==> NonNegativeInteger
 PR ==> Record(rft:%,pout:NNI)
   ++ parse result includes term returned and new index

 Exports == with
  ski:(x:%,y:%) -> %
    ++ Constructs a node combinator over combinators
  ski:(t1:UT) -> %
    ++ Constructs variable combinator
  I:() -> %
    ++ Constructs a I combinator
  K:() -> %
    ++ Constructs a K combinator
  S:() -> %
    ++ Constructs a S combinator
  parseSki:(t1: String) -> %
    ++ Constructs combinators from a string
  parseTerm:(t1: String,pin:NNI) -> PR
    ++ parseTerm is used by parseSki. It would rarely be called
    ++ externally but it is here to allow it to call parseSki
    ++ that is to allow circular calls
  children:(n: %) -> List %
    ++ returns child nodes if this is a compound term
    ++ otherwise returns []
  atom?:(n: %) -> Boolean
    ++ returns true if this is an atom, that is a leaf node
    ++ otherwise return false if this is a compound term
  variable?:(n: %) -> Boolean
    ++ returns true if this is an variable
  isI?:(n: %) -> Boolean
    ++ returns true if this is an I combinator node
  isK?:(n: %) -> Boolean
    ++ returns true if this is a K combinator node
  isS?:(n: %) -> Boolean
    ++ returns true if this is a S combinator node
  variable:(n: %) -> UT
    ++ returns the variable, if this is not a
    ++ variable then return I
  freeVariable?:(n: %,s:UT) -> Boolean
    ++ the variable indicated by 's' is free if it does
    ++ not appear in node 'n' or any of its subnodes.
  redux:(n: %) -> %
    ++ weak reduction - apply this combinator to rearange its
    ++ subnodes then apply recusivly to its subnodes
  "=":(x:%, y:%) -> Boolean
    ++ return true if equal (deep search) that is: all terms
    ++ at all levels in tree must be equal to return true
    ++ all terms must be exactly equal, not just equivalent, that is
    ++ SKK=I will return false even though 'SKK' and 'I' have the
    ++ same effect
  toString: (n: %) -> String
    ++ output
  coerce: (n: %) -> OutputForm
    ++ output

 Implementation == add

  Rep := Union(_
         lf:NNI,_
         nd:Record(c1:%, c2:%),_
         vr:UT_
         )

  -- Constructs a node combinator over another combinators
  ski(x:%,y:%): % == [[x,y]]

  -- Constructs variable combinator
  ski(t1:UT):% ==
    [t1]

  -- Constructs a I combinator
  I(): % == [1::NNI]

  -- Constructs a K combinator
  K(): % == [2::NNI]

  -- Constructs a S combinator
  S(): % == [3::NNI]

  parseBracketTerm(t1: String,pin:NNI):PR ==
    p1 := pin
    ch := qelt(t1,p1)
    if not (ch = char("(")) then
      error "bracket term must start with ("
      return [[1::NNI],p1]
    p1 := p1 + (1::NNI)
    if p1 > maxIndex(t1) then
      error "opening but no closing bracket"
      return [[1::NNI],p1]
    r2 := parseTerm(t1,p1)
    trm := r2.rft
    p1 := r2.pout
    ch := qelt(t1,p1)
    if not (ch = char(")")) then
      error "can't find closing bracket"
      return [[1::NNI],p1]
    p1 := p1 + (1::NNI)
    [trm,p1]

  parseCombinatorTerm(t1: String,pin:NNI):PR ==
    p1 := pin
    ch := qelt(t1,p1)
    if ch = char("I") then
      return [[1::NNI],p1 + (1::NNI)]
    if ch = char("K") then
      return [[2::NNI],p1 + (1::NNI)]
    if ch = char("S") then
      return [[3::NNI],p1 + (1::NNI)]
    error "invalid combinator"
    [[1::NNI],p1 + (1::NNI)]

  parseOneTerm(t1: String,pin:NNI):PR ==
    p1 := pin
    res:% := [1::NNI]
    ch := qelt(t1,p1)
    --sayTeX$Lisp concat(["parseTerm ch=",ch::String," p1=",string(p1)])$String
    -- first remove leading spaces
    while ch = char(" ") repeat
      p1 := p1 + (1::NNI)
      if p1 > maxIndex(t1) then
        --sayTeX$Lisp concat(["parseTerm(",t1,") 1 giving:",toString(res)])
        return [res,p1]
      ch := qelt(t1,p1)
    if alphabetic?(ch) then
      if upperCase?(ch) then
        r := parseCombinatorTerm(t1,p1)
        res := r.rft
        p1 := r.pout
        --sayTeX$Lisp concat(["parseTerm(",t1,") 4 giving:",toString(res)])
      if lowerCase?(ch) then
        --sayTeX$Lisp concat(["parseTerm(",t1,") 4 giving:",toString(res)])
        r2 := parseVar(t1,p1)$UT
        res := ski(r2.rft)
        p1 := r2.pout
    if ch = char("(") then
      r := parseBracketTerm(t1,p1)
      res := r.rft
      p1 := r.pout
    [res,p1]

  parseTerm(t1: String,pin:NNI):PR ==
    p1 := pin
    r := parseOneTerm(t1,p1)
    res:% := r.rft
    p1 := r.pout
    -- now check for compound term
    if p1 > maxIndex(t1) then
      --sayTeX$Lisp concat(["parseTerm(",t1,") 2 giving:",toString(res)])
      return [res,p1]
    ch := qelt(t1,p1)
    stck:List % := []
      ++ in order to get association to the left we will put terms
      ++ in a list
    while alphabetic?(ch) or ch = char(" ") or ch = char("(") repeat
      r := parseOneTerm(t1,p1)
      p1 := r.pout
      stck := concat(stck,r.rft)
      --sayTeX$Lisp concat(["parseTerm(",t1,") 4 giving:",toString(res)])
      if p1 > maxIndex(t1)
        then ch := char("*")
        else ch := qelt(t1,p1)
    for i in 1..#stck repeat
      res := ski(res,stck.i)
    [res,p1]


  -- Constructs combinators from a string
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  parseSki(t1: String): % ==
    r := parseTerm(t1,minIndex(t1)::NNI)
    --sayTeX$Lisp concat(["parseSki(",t1,") giving:",toString(tm)])
    r.rft

  -- returns child nodes if this is a compound term
  -- otherwise returns []
  children(n: %):List % ==
    if atom?(n) then return []
    [n.nd.c1,n.nd.c2]

  -- returns true if this is an atom, that is a leaf node
  -- otherwise return false if this is a compound term
  atom?(n: %):Boolean == (n case lf) or (n case vr)

  -- returns true if this is an variable
  variable?(n: %):Boolean == (n case vr)

  -- returns true if this is an I combinator node
  isI?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf = 1 then return true
    false

  -- returns true if this is a K combinator node
  isK?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf = 2 then return true
    false

  -- returns true if this is a S combinator node
  isS?(n: %):Boolean ==
    if not (n case lf) then return false
    if n.lf = 3 then return true
    false

  -- returns the name of this variable, if this is not a
  -- variable then return " "
  variable(n: %):UT ==
    if n case vr then
      return n.vr
    var(" ")$UT

  -- the variable indicated by 's' is free if it does
  -- not appear in node 'n' or any of its subnodes.
  freeVariable?(n: %,s:UT):Boolean ==
    if n case vr then
      if n.vr=s then return false
    if n case nd then
      if not freeVariable?(n.nd.c1,s) or _
         not freeVariable?(n.nd.c2,s) then return false
    true

  -- return string representation
  -- notation assumes association to the left, in the absence of
  -- brackets, the term to the left binds more tightly than the
  -- one on the right.
  toString(n: %):String ==
    s:String := ""
    if n case lf then
      -- leaf node so print I,K or S
      if n.lf = 1 then s := "I"
      if n.lf = 2 then s := "K"
      if n.lf = 3 then s := "S"
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      if atom?(n.nd.c2) then
        if variable?(n.nd.c2)
          then
            s := concat([s,toString(n.nd.c1)," ",toString(n.nd.c2)])
          else
            s := concat([s,toString(n.nd.c1),toString(n.nd.c2)])
      else
        s := concat([s,toString(n.nd.c1),"(",toString(n.nd.c2),")"])
    if n case vr then
      -- variable node so print name
      s := toString(n.vr)$UT
    s

  -- weak reduction - apply this combinator to rearrange its
  -- subnodes then apply recursively to its subnodes
  redux1(n: %):% ==
    if n case nd then
      -- binary node which has two subnodes c1 and c2
      left := redux1(n.nd.c1)
      right := redux1(n.nd.c2)
      --sayTeX$Lisp concat(["left=",toString(left),_
      --                    " right=",toString(right)])$String
      if isI?(left) then return right
      if not (left case nd) then return ski(left,right)
      leftleft := left.nd.c1
      leftright := left.nd.c2
      --sayTeX$Lisp concat(["leftleft=",toString(leftleft),_
      --                    " leftright=",toString(leftright)])$String
      if isK?(leftleft) then return leftright
      if not (leftleft case nd) then return ski(left,right)
      leftleftleft := leftleft.nd.c1
      leftleftright := leftleft.nd.c2
      --sayTeX$Lisp concat(["leftleftleft=",toString(leftleftleft),_
      --                    " leftleftright=",toString(leftleftright)])$String
      if isS?(leftleftleft) then
        return ski(ski(leftleftright,right),ski(leftright,right))
      return ski(left,right)
    n

  -- weak reduction - apply this combinator to rearrange its
  -- subnodes then apply recursively to its subnodes
  redux(n: %):% ==
    lastResult := [1::NNI]
    thisResult := redux1(n)
    triesLeft:NNI := 20::NNI -- limit tries in case of loop
    while (lastResult ~= thisResult) and (triesLeft > (1::NNI)) repeat
      lastResult := thisResult
      thisResult := redux1(lastResult)
      triesLeft := (triesLeft - 1)::NNI
      sayTeX$Lisp toString(lastResult)
    thisResult

  -- return true if equal (deep search) that is: all terms
  -- at all levels in tree must be equal to return true
  -- all terms must be exactly equal, not just equivalent, that is
  -- SKK=I will return false even though 'SKK' and 'I' have the
  -- same effect
  x = y ==
    if (x case lf) and (y case lf) then
      -- leaf node so compare I,K or S
      if x.lf = y.lf then return true
      return false
    if (x case vr) and (y case vr) then
      -- variable node so compare names
      if x.vr = y.vr then return true
      return false
    if (x case nd) and (y case nd) then
      -- binary node which has two subnodes c1 and c2
      if (x.nd.c1 = y.nd.c1) and (x.nd.c2 = y.nd.c2) then return true
      return false
    false

  -- output
  coerce(n: %):OutputForm ==
    toString(n)::OutputForm
@

\section{Logic Utility Package}

The compUtil package provides utilities to convert between the
computational domains: Lambda, Ski and ILogic.

Both Lambda are Ski are Turing complete and can be coerced to
each other. Lambda and Ski are not equal and they are only
equivalent upto beta-equivalence and beta-equivalence is
undecidable so there is not a direct correspondance between
the nodes in their trees. Also the names of bound variables
and other such constructions may be lost in
Lambda -> Ski -> Lambda round trip.

An element of ILogic cannot be coerced to the other types.
However ILogic can be used to produce a theory which can be
concerted to/from the other domains using Curry-Howard
isomorphism.
\section{Tutorial}

On this page we will be working with 'untyped' variables
in lambda and SKI terms so we create instances called LU and
SU to simplify notation:

(1) -> LU := Lambda Untyped

   (1)  Lambda(Untyped)
                                                               Type: Type
(2) -> SU := Ski Untyped

   (2)  Ski(Untyped)
                                                               Type: Type

\section{SKI combinators to lambda functions}

We can then create SKI combinators and convert them to lambda functions.

    For a tutorial about working with SKI combinators see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/
    For a tutorial about working with lambda functions see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/

If the combinators don't have the required parameters then you
will get a warning as follows. The code will attempt to add parameters
as required but this will not work in complicated situations.

Ideally when working with 'abstract' combinatiors we need to add the
required number of parameters, do the convertion then remove the
parameters just added.

(3) -> I()$SU::LU

util coerce rule SL1: Ski[I] = \v0.0

   (3)  "(\v0.v0)"
                                                    Type: Lambda(Untyped)

(4) -> K()$SU::LU

util coerce rule SL2: Ski[K] = \v0.\v1.1

   (4)  "(\v0.(\v1.v1))"
                                                    Type: Lambda(Untyped)
(5) -> S()$SU::LU

util coerce rule SL3: Ski[S] = \v0.\v1.\v2.(2 0 (1 0))

   (5)  "(\v0.(\v1.(\v2.(v2 (v0 (v1 v0))))))"
                                                    Type: Lambda(Untyped)

In the following examples the combinators are provided with the required
parameters. This conversion works by applying the following rules:

    rule SL1: Ski[I] = \x.0
    rule SL2: Ski[K] = \x.\y.1
    rule SL3: Ski[S] = \x.\y.\z.(2 0 (1 0))
    rule SL4: Ski[(E1 E2)] = (Ski[E1] Ski[E2])

So here are some examples:

parseSki("Ia")$SU::LU

util coerce apply rule SL1 in:I a
util coerce pass unbound variable a unchanged

   (6)  "a"
                                                    Type: Lambda(Untyped)
parseSki("Ka b")$SU::LU

util coerce apply rule SL2 in:K a b
util coerce pass unbound variable a unchanged

   (7)  "a"
                                                    Type: Lambda(Untyped)
parseSki("K(a b)c")$SU::LU

util coerce apply rule SL2 in:K(a b) c
util coerce rule SL4: Ski[(a b)] = (Ski[a] Ski[b])
util coerce pass unbound variable a unchanged
util coerce pass unbound variable b unchanged

   (8)  "(a b)"
                                                    Type: Lambda(Untyped)
parseSki("Sa b c")$SU::LU

util coerce apply rule SL3 in:S a b c
util coerce pass unbound variable a unchanged
util coerce pass unbound variable c unchanged
util coerce pass unbound variable b unchanged
util coerce pass unbound variable c unchanged

   (9)  "((a c) (b c))"
                                                    Type: Lambda(Untyped)
parseSki("S(K(SI))(S(KK)I)")$SU::LU

util coerce rule SL4: Ski[(S(K(SI)) S(KK)I)] = (Ski[S(K(SI))] Ski[S(KK)I])
util coerce rule SL4: Ski[(S K(SI))] = (Ski[S] Ski[K(SI)])
util coerce rule SL3: Ski[S] = \v0.\v1.\v2.(2 0 (1 0))
util coerce rule SL4: Ski[(K SI)] = (Ski[K] Ski[SI])
util coerce rule SL2: Ski[K] = \v3.\v4.1
util coerce rule SL4: Ski[(S I)] = (Ski[S] Ski[I])
util coerce rule SL3: Ski[S] = \v5.\v6.\v7.(2 0 (1 0))
util coerce rule SL1: Ski[I] = \v8.0
util coerce rule SL4: Ski[(S(KK) I)] = (Ski[S(KK)] Ski[I])
util coerce rule SL4: Ski[(S KK)] = (Ski[S] Ski[KK])
util coerce rule SL3: Ski[S] = \v9.\v10.\v11.(2 0 (1 0))
util coerce rule SL4: Ski[(K K)] = (Ski[K] Ski[K])
util coerce rule SL2: Ski[K] = \v12.\v13.1
util coerce rule SL2: Ski[K] = \v14.\v15.1
util coerce rule SL1: Ski[I] = \v16.0

   (10)
  "(((\v0.(\v1.(\v2.(v2 (v0 (v1 v0)))))) ((\v3.(\v4.v4)) ((\v5.(\v6.(\v7.(v7 (v
  5 (v6 v5)))))) (\v8.v8)))) (((\v9.(\v10.(\v11.(v11 (v9 (v10 v9)))))) ((\v12.(
  \v13.v13)) (\v14.(\v15.v15)))) (\v16.v16)))"
                                                    Type: Lambda(Untyped)

\section{lambda functions to SKI combinators}

We can then create lambda functions and convert them to SKI combinators.

    For a tutorial about working with SKI combinators see this page.
    For a tutorial about working with lambda functions see this page.

This process is known as abstraction elimination. it is done by
applying the following rules until all lambda terms have been
eliminated.

    rule LS1: Lam[x] => x
    rule LS2: Lam[(E1 E2)] => (Lam[E1] Lam[E2])
    rule LS3: Lam[\x.E] => (K Lam[E]) (if x does not occur free in E)
    rule LS4: Lam[\x.x] => I
    rule LS5: Lam[\x.\y.E] => Lam[\x.Lam[\y.E]] (if x occurs free in E)
    rule LS6: Lam[\x.(E1 E2)] => (S Lam[\x.E1] Lam[\x.E2])

Here are some examples:

(11) -> parseLambda("x")$LU::SU

util coerce rule LS1 applied to:x giving x

   (11)  "x"
                                                       Type: Ski(Untyped)
(12) -> parseLambda("x y")$LU::SU

util coerce rule LS2 applied to:(x y) giving (x y)
util coerce rule LS1 applied to:x giving x
util coerce rule LS1 applied to:y giving y

   (12)  "x y"
                                                       Type: Ski(Untyped)
(13) -> parseLambda("\x.1")$LU::SU

util coerce rule LS3 applied to:(\x.1) giving K 1
util coerce rule LS1 applied to:1 giving 1

   (13)  "K 1"
                                                       Type: Ski(Untyped)
(14) -> parseLambda("\x.0")$LU::SU

util coerce warning could not match any rule to:(\x.0)

   (14)  "I"
                                                       Type: Ski(Untyped)
(15) -> parseLambda("\x.\y.0 1")$LU::SU

util coerce rule LS5 applied to:(\x.(\y.(0 1))) giving \x.(\y.(0 x))
util coerce rule LS6 applied to:(\y.(0 x)) giving S \y.y \y.x
util coerce rule LS1 applied to:y giving y
util coerce rule LS4' applied to: \y.y giving I
util coerce rule LS1 applied to:x giving x
util coerce rule LS3' applied to: \y.x giving K x
util coerce rule LS5' applied to: \x.SI(Kx) giving S \x.SI \x.Kx
util coerce rule LS3' applied to: \x.SI giving K \x.S \x.I
util coerce rule LS5' applied to: \x.Kx giving S \x.K \x.x
util coerce rule LS3' applied to: \x.K giving K K
util coerce rule LS4' applied to: \x.x giving I

   (15)  "S(K(SI))(S(KK)I)"
                                                       Type: Ski(Untyped)

\section{SKI combinators to Intuitionistic Logic}

We can then create SKI combinators and convert them to intuitionistic
logic.

    For a tutorial about working with SKI combinators see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/
    For a tutorial about working with intuitionistic logic see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/


This is known as the Curry-Howard isomorphism it uses the following rules:

    rule SI1: Ski[Kab] => a -> (b -> a)
    rule SI2: Ski[Sabc] => (a -> (b -> c)) -> ((a -> b) -> (a -> c))
    rule SI3: Ski[a a->b] => b

The last rule is function application (modus ponens). Here are some
examples:

(16) -> parseSki("Ia")$SU::ILogic

util coerce apply rule SI1 in:Ia
warning I does not have a parameter to act on
creating x

   (16)  "((x->x)->(x->x))"
                                                             Type: ILogic
(17) -> parseSki("Ka b")$SU::ILogic

util coerce apply rule SI2 in:K a b

   (17)  "(b->(a->b))"
                                                             Type: ILogic
(18) -> parseSki("K(a b)c")$SU::ILogic

util coerce apply rule SI2 in:K(a b) c

   (18)  "(c->((a\/b)->c))"
                                                             Type: ILogic
(19) -> parseSki("Sa b c")$SU::ILogic

util coerce apply rule SI3 in:S a b c

   (19)  "((c->(b->a))->((c->b)->(c->a)))"
                                                             Type: ILogic

\section{package COMPUTIL compUtil}
<<package COMPUTIL compUtil>>=
)abbrev package COMPUTIL compUtil
++ Author: Martin Baker
++ Date Created: April 2011
++ Date Last Updated: April 2011
++ Basic Operations:
++ Related Constructors:
++ Also See:
++ AMS Classifications:
++ Keywords:
++ References:
++ http://www.euclideanspace.com/maths/standards/program/mycode/computation/utility/
++ Description:
++ The compUtil package provides utilities to convert between the
++ computational domains: Lambda, Ski and ILogic.
++ Both Lambda are Ski are Turing complete and can be coerced
++ to each other. Lambda and Ski are not equal and they are only
++ isomorphic upto beta-equivalence and beta-equivalence is
++ undecidable so there is not a direct correspondence
++ between the nodes in their trees.
++ Also the names of bound variables and other such constructions
++ may be lost in Lambda -> Ski -> Lambda round trip.
++ An element of ILogic cannot be coerced to the other types.
++ However ILogic can be used to produce a theory which can
++ be concerted to/from the other domains using Curry-Howard
++ isomorphism.

compUtil(UT): Exports == Implementation where

 UT:VarCat
 LU ==> Lambda UT
 SU ==> SKICombinators UT
 NNI==> NonNegativeInteger

 Exports ==> with
    coerce: (s: SU) -> LU
      ++ coerce SKI combinators to Lambda term.
      ++ this conversion is done by applying the following rules
      ++ rule SL1: Ski[I] = \x.0
      ++ rule SL2: Ski[K] = \x.\y.1
      ++ rule SL3: Ski[S] = \x.\y.\z.(2 0 (1 0))
      ++ rule SL4: Ski[(E1 E2)] = (Ski[E1] Ski[E2])
    coerce: (lam: LU) -> SU
      ++ coerce Lambda term to SKI combinators.
      ++ this process is known as abstraction elimination.
      ++ it is done by applying the following rules until
      ++ all lambda terms have been eliminated.
      ++ rule LS1: Lam[x] => x
      ++ rule LS2: Lam[(E1 E2)] => (Lam[E1] Lam[E2])
      ++ rule LS3: Lam[\x.E] => (K Lam[E]) (if x does not occur free in E)
      ++ rule LS4: Lam[\x.x] => I
      ++ rule LS5: Lam[\x.\y.E] => Lam[\x.Lam[\y.E]] (if x occurs free in E)
      ++ rule LS6: Lam[\x.(E1 E2)] => (S Lam[\x.E1] Lam[\x.E2])
    coerce: (s: SU) -> ILogic
      ++ coerce combinators to intuitionistic logic
      ++ this is known as the Curry-Howard isomorphism
      ++ it uses the following rules:
      ++ rule SI1: Ski[Kab] => a -> (b -> a),
      ++ rule SI2: Ski[Sabc] => (a -> (b -> c)) -> ((a -> b) -> (a -> c)),
      ++ rule SI3: Ski[a a->b] => b
      ++ the last rule is function application (modus ponens)

 Implementation ==> add

  -- Keeps count of index number of variables created in Ski2Lambda.
  -- I am wary of defining a variable outside of a function but
  -- can't find another non-messy way to update it from several
  -- functions.
  varNum:NNI :=0::NNI

  -- used by coerce SKI combinators to Lambda term.
  Ski2Lambda(s: SU):LU ==
    -- if s is an atom then this means that there are no
    -- parameters for this combinator. If there had been
    -- they would have been found when this was called on
    -- the nodes above it.
    -- sayTeX$Lisp concat(["util coerce called for:",toString(s)$SU])$String
    if atom?(s)$SU then
      --sayTeX$Lisp concat(["util coerce atom:",toString(s)$SU])$String
      if isI?(s)$SU then
        strVar:String := concat("v",string(varNum))
        sayTeX$Lisp concat["util coerce rule SL1: Ski[I] = \",strVar,".0"]
        varNum := varNum +1
        return parseLambda(concat["\",strVar,".0"])$LU
      if isK?(s)$SU then
        strVar1:String := concat("v",string(varNum))
        strVar2:String := concat("v",string(varNum+1))
        sayTeX$Lisp concat["util coerce rule SL2: Ski[K] = \",strVar1,".\",strVar2,".1"]
        varNum := varNum +2
        return parseLambda(concat["\",strVar1,".\",strVar2,".1"])$LU
      if isS?(s)$SU then
        strVar1:String := concat("v",string(varNum))
        strVar2:String := concat("v",string(varNum+1))
        strVar3:String := concat("v",string(varNum+2))
        sayTeX$Lisp concat["util coerce rule SL3: Ski[S] = \",strVar1,".\",strVar2,".\",strVar3,".(2 0 (1 0))"]
        varNum := varNum +3
        return parseLambda(concat["\",strVar1,".\",strVar2,".\",strVar3,".(2 0 (1 0))"])$LU
      sayTeX$Lisp ["util coerce pass unbound variable ",name(variable(s)$SU)$UT," unchanged"]
      return lambda(variable(s)$SU)$LU
    subnodes:List SU := children(s)$SU
    c1:SU := first subnodes
    c2:SU := second subnodes
    s1:String := toString(c1)$SU
    s2:String := toString(c2)$SU
    --sayTeX$Lisp concat(["util coerce c1=",toString(c1)$SU," c2=",toString(c2)])$String
    -- look for I x, if found translate x
    if isI?(c1)$SU then
      sayTeX$Lisp concat(["util coerce apply rule SL1 in:",toString(s)$SU])$String
      return Ski2Lambda(c2)
    if atom?(c1)$SU then
      sayTeX$Lisp concat(["util coerce rule SL4: Ski[(",s1," ",s2,")] = (Ski[",s1,"] Ski[",s2,"])"])
      return lambda(Ski2Lambda(c1),Ski2Lambda(c2))$LU
    -- look for K x y, if found translate x
    subsubnodes:List SU := children(c1)$SU
    c11:SU := first subsubnodes
    c12:SU := second subsubnodes
    --sayTeX$Lisp concat(["util coerce c1=",toString(c1)$SU," c2=",toString(c2)$SU," c11=",toString(c11)$SU," c12=",toString(c12)$SU])$String
    if isK?(c11)$SU then
      s12:String := name(variable(c12)$SU)$UT
      sayTeX$Lisp concat(["util coerce apply rule SL2 in:",toString(s)$SU])$String
      return Ski2Lambda(c12)
    if atom?(c11)$SU then
      sayTeX$Lisp concat(["util coerce rule SL4: Ski[(",s1," ",s2,")] = (Ski[",s1,"] Ski[",s2,"])"])
      return lambda(Ski2Lambda(c1),Ski2Lambda(c2))$LU
    -- look for S x y z, if found translate (x z)(y z)
    subsubnodes2:List SU := children(c11)$SU
    c111:SU := first subsubnodes2
    c112:SU := second subsubnodes2
    --sayTeX$Lisp concat(["util coerce c11=",toString(c11)$SU," c12=",toString(c12)$SU," c111=",toString(c111)$SU," c112=",toString(c112)$SU])$String
    -- look for K x y, if found translate x
    if isS?(c111)$SU then
      s2:String := name(variable(c2)$SU)$UT
      s12:String := name(variable(c12)$SU)$UT
      s112:String := name(variable(c112)$SU)$UT
      sayTeX$Lisp concat(["util coerce apply rule SL3 in:",toString(s)$SU])$String
      return lambda(lambda(Ski2Lambda(c112),Ski2Lambda(c2))$LU,lambda(Ski2Lambda(c12),Ski2Lambda(c2))$LU)$LU
    sayTeX$Lisp concat(["util coerce rule SL4: Ski[(",s1," ",s2,")] = (Ski[",s1,"] Ski[",s2,"])"])
    lambda(Ski2Lambda(c1),Ski2Lambda(c2))$LU

  -- coerce SKI combinators to Lambda term.
  -- this conversion is done by applying the following rules
  -- rule SL1: Ski[I] = \x.0
  -- rule SL2: Ski[K] = \x.\y.1
  -- rule SL3: Ski[S] = \x.\y.\z.(2 0 (1 0))
  -- rule SL4: Ski[(E1 E2)] = (Ski[E1] Ski[E2])
  coerce(s: SU):LU ==
    varNum := 0
    term:LU := Ski2Lambda(s)
    term

  -- when we are coercing Lambda to Ski and we apply rule LS5
  -- we call this
  lambdaOverSki(var:UT,sk:SU):SU ==
    --sayTeX$Lisp concat(["gives \",toString(var)$UT,".",toString(sk)])$String
    if atom?(sk) then
      if freeVariable?(sk,var)$SU then
        sayTeX$Lisp concat(["util coerce rule LS3' applied to: \",toString(var)$UT,".",toString(sk)," giving K ",toString(sk)])$String
        return ski(K(),sk)
      sayTeX$Lisp concat(["util coerce rule LS4' applied to: \",toString(var)$UT,".",toString(sk)," giving I"])$String
      return I()$SU
    ch: List SU := children(sk)$SU
    left:SU := first ch
    right:SU := second ch
    --sayTeX$Lisp concat(["left=",toString(left),_
    --                    " right=",toString(right)])$String
    if freeVariable?(sk,var)$SU then
      sayTeX$Lisp concat(["util coerce rule LS3' applied to: \",toString(var)$UT,".",toString(sk)," giving K \",toString(var)$UT,".",toString(left)," \",toString(var)$UT,".",toString(right)])$String
      --return ski(ski(K(),left),right)
      return ski(K(),ski(left,right))
    sayTeX$Lisp concat(["util coerce rule LS5' applied to: \",toString(var)$UT,".",toString(sk)," giving S \",toString(var)$UT,".",toString(left)," \",toString(var)$UT,".",toString(right)])$String
    return ski(ski(S()$SU,lambdaOverSki(var,left)),lambdaOverSki(var,right))

  -- coerce Lambda term to SKI combinators.
  -- this process is known as abstraction elimination.
  -- it is done by applying the following rules until
  -- all lambda terms have been eliminated.
  -- rule LS1: Lam[x] => x
  -- rule LS2: Lam[(E1 E2)] => (Lam[E1] Lam[E2])
  -- rule LS3: Lam[\x.E] => (K Lam[E]) (if x does not occur free in E)
  -- rule LS4: Lam[\x.x] => I
  -- rule LS5: Lam[\x.\y.E] => Lam[\x.Lam[\y.E]] (if x occurs free in E)
  -- rule LS6: Lam[\x.(E1 E2)] => (S Lam[\x.E1] Lam[\x.E2])
  coerce(lam: LU):SU ==
    -- test for rule 1
    if atom?(lam)$LU then
      sayTeX$Lisp concat(["util coerce rule LS1 applied to:",toString(lam)$LU," giving ",toString(lam)$LU])$String
      return ski(var(toString(lam)$LU)$UT)$SU
    if isCompound?(lam)$LU then
      ch:List LU := children(lam)$LU
      c1:LU := first ch
      c2:LU := second ch
      sayTeX$Lisp concat(["util coerce rule LS2 applied to:",toString(lam)$LU," giving (",toString(c1)$LU," ",toString(c2)$LU,")"])$String
      return ski(c1::SU,c2::SU)$SU
    if isLambda?(lam)$LU then
      lamUn:LU := unbind(lam)$LU
      c3:LU := first children(lamUn)$LU
      s3:UT := variable(lam)$LU
      if atom?(c3)$LU then
        if toString(c3)$LU="0" then
          sayTeX$Lisp concat(["util coerce rule LS4 applied to:",toString(lam)$LU," giving I"])$String
          return I()$SU
      if free?(lam)$LU then
        sayTeX$Lisp concat(["util coerce rule LS3 applied to:",toString(lam)$LU," giving K ",toString(c3)])$String
        return ski(K(),c3::SU)$SU
      if isLambda?(c3)$LU then
        c33:LU := first children(c3)$LU
        cxx:LU := lambda(c33,variable(c3)$LU)$LU
        sayTeX$Lisp concat(["util coerce rule LS5 applied to:",toString(lam)$LU," giving \",toString(s3)$UT,".",toString(cxx)])$String
        return lambdaOverSki(s3,cxx::SU)
      if isCompound?(c3) then
        ch3:List LU := children(c3)$LU
        c31:LU := first ch3
        c32:LU := second ch3
        sayTeX$Lisp concat(["util coerce rule LS6 applied to:",toString(lam)$LU," giving S \",toString(s3)$UT,".",toString(c31)$LU," \",toString(s3)$UT,".",toString(c32)$LU])$String
        return ski(ski(S()$SU,lambdaOverSki(s3,c31::SU)),lambdaOverSki(s3,c32::SU))$SU
    sayTeX$Lisp concat(["util coerce warning could not match any rule to:",toString(lam)$LU])$String
    I()$SU

  -- coerce combinators to intuitionistic logic
  -- this is known as the Curry-Howard isomorphism
  -- it uses the following rules:
  -- rule SI1: Ski[Ia] => a -> a,
  -- rule SI2: Ski[Kab] => a -> (b -> a),
  -- rule SI3: Ski[Sabc] => (a -> (b -> c)) -> ((a -> b) -> (a -> c)),
  -- rule SI4: Ski[a a->b] => b
  -- the last rule is function application (modus ponens)
  coerce(s: SU):ILogic ==
    -- if s is an atom then this means that there are no
    -- parameters for this combinator. If there had been
    -- they would have been found when this was called on
    -- the nodes above it.
    -- I don't know the best way to hanle this, really we
    -- need to add the required number of parameters, do
    -- the convertion then remove the parameters just added.
    -- sayTeX$Lisp concat(["util coerce called for:",toString(s)$SU])$String
    if atom?(s) then
      --sayTeX$Lisp concat(["util coerce atom:",toString(s)$SU])$String
      if isI?(s) then
        sayTeX$Lisp "warning I does not have a parameter to act on"
        sayTeX$Lisp "creating x"
        a :ILogic  := proposition("x")
        return implies(a,a)
      if isK?(s) then
        sayTeX$Lisp "warning K does not enough parameters to act on"
        sayTeX$Lisp "creating x and y"
        a :ILogic  := proposition("x")
        b :ILogic  := proposition("y")
        return implies(a,implies(b,a))
      if isS?(s) then
        sayTeX$Lisp "warning S does not enough parameters to act on"
        sayTeX$Lisp "creating x,y an z"
        a :ILogic  := proposition("x")
        b :ILogic  := proposition("y")
        c :ILogic  := proposition("z")
        ab :ILogic  := implies(a,b)
        ac :ILogic  := implies(a,c)
        bc :ILogic  := implies(b,c)
        return implies(implies(a,bc),implies(ab,ac))
      return proposition(name(variable(s)$SU)$UT)
    subnodes:List SU := children(s)$SU
    c1:SU := first subnodes
    c2:SU := second subnodes
    --sayTeX$Lisp concat(["util coerce c1=",toString(c1)$SU," c2=",toString(c2)])$String
    -- look for I x, if found translate x
    if isI?(c1) then
      sayTeX$Lisp concat(["util coerce apply rule SI1 in:",toString(s)$SU])$String
      a :ILogic  := c1::ILogic
      return implies(a,a)
    if atom?(c1) then return _\_/(c1::ILogic,c2::ILogic)
    -- look for K x y, if found translate x
    subsubnodes:List SU := children(c1)
    c11:SU := first subsubnodes
    c12:SU := second subsubnodes
    --sayTeX$Lisp concat(["util coerce c1=",toString(c1)$SU," c2=",toString(c2)," c11=",toString(c11)$SU," c12=",toString(c12)$SU])$String
    if isK?(c11) then
      sayTeX$Lisp concat(["util coerce apply rule SI2 in:",toString(s)$SU])$String
      a :ILogic  := c2::ILogic
      b :ILogic  := c12::ILogic
      return implies(a,implies(b,a))
    if atom?(c11) then return _\_/(c1::ILogic,c2::ILogic)
    -- look for S x y z, if found translate (x z)(y z)
    subsubnodes2:List SU := children(c11)
    c111:SU := first subsubnodes2
    c112:SU := second subsubnodes2
    --sayTeX$Lisp concat(["util coerce c11=",toString(c11)$SU," c12=",toString(c12)$SU," c111=",toString(c111)$SU," c112=",toString(c112)$SU])$String
    -- look for K x y, if found translate x
    if isS?(c111) then
      sayTeX$Lisp concat(["util coerce apply rule SI3 in:",toString(s)$SU])$String
      a :ILogic  := c2::ILogic
      b :ILogic  := c12::ILogic
      c :ILogic  := c112::ILogic
      ab :ILogic  := implies(a,b)
      ac :ILogic  := implies(a,c)
      bc :ILogic  := implies(b,c)
      return implies(implies(a,bc),implies(ab,ac))
    _\_/(c1::ILogic,c2::ILogic)

@

\section{License}
<<license>>=
--Copyright (c) 2011, Martin J Baker.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of Martin J Baker. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@
<<*>>=
<<license>>
@
\eject
\begin{thebibliography}{99}
For more details see:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/
Tutorial for lambda calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/lambda/
Tutorial for SKI calculus:
http://www.euclideanspace.com/maths/standards/program/mycode/computation/ski/
Tutorial for Intuitionistic Logic
http://www.euclideanspace.com/maths/standards/program/mycode/computation/intuitionistic/
Tutorial for utilities to coerce between computation domains
http://www.euclideanspace.com/maths/standards/program/mycode/computation/utility/
\end{thebibliography}
\end{document}
