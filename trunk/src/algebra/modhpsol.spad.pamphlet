\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/algebra modhpsol.spad}
\author{Waldek Hebisch}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\section{Solver over machine-sized finite fields}

<<package NBLM NaiveBeckermannLabahnModular>>=

)abbrev package NBLM NaiveBeckermannLabahnModular
++ Description: This package solves (multipoint) Hermite-Pade
++  interpolation problem over $Z_p$, where $p$ is machine
++  sized prime.  We use quadratic algorithm from 94
++  Beckermann and Labahn paper (with modification to handle
++  multipoint case).

K ==> Integer
VUP ==> Vector SparseUnivariatePolynomial K
-- PA ==> PrimitiveArray K
PA ==> U32Vector
VPA ==> Vector PA
MPA ==> TwoDimensionalArray PA
VI ==> Vector Integer
NBR ==> Record(basis : MPA, defects : VI, cinds : VI)

NaiveBeckermannLabahnModular: with
  naiveBeckermannLabahn : (VPA, VI, NonNegativeInteger, Integer) _
                         -> List Any
    ++ naiveBeckermannLabahn(f, degs, sigma, p) solves modulo $p$
    ++ Hermite-Pade interpolation problem of order $sigma$.  $degs$
    ++ specifies degree bounds for solution.  The first element of
    ++ result contains sigma-basis.  The second gives defects
    ++ of elements of sigma-basis.  The third one contains residuals
    ++ -- we stop updating solution if this would violate degree
    ++ bounds, so residual is zero for elements of sigma-basis
    ++ which are within bounds, but non-zero otherwise.

  naiveBeckermannLabahn : (VUP, VI, NonNegativeInteger, Integer) _
                         -> List Any
    ++ naiveBeckermannLabahn(f, degs, sigma, p) solves modulo $p$
    ++ Hermite-Pade interpolation problem of order $sigma$.  $degs$
    ++ specifies degree bounds for solution.  The first element of
    ++ result contains sigma-basis.  The second gives defects
    ++ of elements of sigma-basis.  The third one contains residuals
    ++ -- we stop updating solution if this would violate degree
    ++ bounds, so residual is zero for elements of sigma-basis
    ++ which are within bounds, but non-zero otherwise.

  naiveBeckermannLabahnMultipoint : (VPA, VI, PA, Integer) _
                         -> List Any
    ++ naiveBeckermannLabahn(f, degs, sigma, p) solves modulo $p$
    ++ multipoint Hermite-Pade interpolation problem of order $sigma$.
    ++ $degs$ specifies degree bounds for solution.  The first element of
    ++ result contains sigma-basis.  The second gives defects
    ++ of elements of sigma-basis.  The third one contains residuals
    ++ -- we stop updating solution if this would violate degree
    ++ bounds, so residual is zero for elements of sigma-basis
    ++ which are within bounds, but non-zero otherwise.

  naiveBeckermannLabahnMultipoint : (VUP, VI, PA, Integer) _
                         -> List Any
    ++ naiveBeckermannLabahn(f, degs, sigma, p) solves modulo $p$
    ++ multipoint Hermite-Pade interpolation problem of order $sigma$.
    ++ $degs$ specifies degree bounds for solution.  The first element of
    ++ result contains sigma-basis.  The second gives defects
    ++ of elements of sigma-basis.  The third one contains residuals
    ++ -- we stop updating solution if this would violate degree
    ++ bounds, so residual is zero for elements of sigma-basis
    ++ which are within bounds, but non-zero otherwise.

  naiveBeckermannLabahn1 : (VUP, VI, NonNegativeInteger, _
                            Integer, Integer -> K, _
                            (PA, K, Integer) -> Void, _
                            (PA, K, Integer) -> Void) -> List Any

  naiveBeckermannLabahn1 : (VPA, VI, NonNegativeInteger, _
                            Integer, Integer -> K, _
                            (PA, K, Integer) -> Void, _
                            (PA, K, Integer) -> Void) -> List Any

  naiveBeckermannLabahn0 : (VPA, VPA, VI, NonNegativeInteger, _
                            Integer, Integer -> K, _
                            (PA, K, Integer) -> Void, _
                            (PA, K, Integer) -> Void) -> Void
    ++ main solver routine

  reduceBasis0 :(MPA, VI, VI, Integer) -> NBR

  reduceBasis : (VPA, VI, VI, Integer) -> NBR
    ++ Skips elements of sigma basis which does not satisfy degree
    ++ bounds and puts sigma-basis into canonical form.

 == add

  import U32VectorPolynomialOperations

  muladdmod ==> QSMULADDMOD64_-32$Lisp
  mulmod ==> QSMULMOD32$Lisp

  vector__shift: PA -> Void

  mul__by__binomial__pointwise : (PA, K, PA, Integer) -> Void

  naiveBeckermannLabahn(vp : VUP, vn : Vector Integer, _
                        sigma : NonNegativeInteger, prime : Integer) ==
      naiveBeckermannLabahn1(vp, vn, sigma, prime, _
                             x +-> 0,
                             (x, pt, p) +-> vector__shift(x),
                             (x, pt, p) +-> vector__shift(x))

  naiveBeckermannLabahn(vp : VPA, vn : Vector Integer, _
                        sigma : NonNegativeInteger, prime : Integer) ==
      naiveBeckermannLabahn1(vp, vn, sigma, prime, _
                             x +-> 0,
                             (x, pt, p) +-> vector__shift(x),
                             (x, pt, p) +-> vector__shift(x))

  naiveBeckermannLabahnMultipoint(vp : VUP, vn : Vector Integer, pts : PA, _
                                  prime : Integer) ==
      naiveBeckermannLabahn1(vp, vn, #pts, prime, _
                             x +-> QSDIFFERENCE(prime, pts(x))$Lisp,
                             (x, pt, p) +-> _
                                mul__by__binomial__pointwise(x, pt, pts, p), _
                             mul__by__binomial)

  naiveBeckermannLabahnMultipoint(vp : VPA, vn : Vector Integer, pts : PA, _
                                  prime : Integer) ==
      naiveBeckermannLabahn1(vp, vn, #pts, prime, _
                             x +-> QSDIFFERENCE(prime, pts(x))$Lisp,
                             (x, pt, p) +-> _
                                mul__by__binomial__pointwise(x, pt, pts, p), _
                             mul__by__binomial)

  naiveBeckermannLabahn1(vp : VUP, vn : Vector Integer, _
                         sigma : NonNegativeInteger, prime : Integer, _
                         pts : Integer-> K, _
                         up__residual : (PA, K, Integer) -> Void, _
                         up__poly : (PA, K, Integer) -> Void) : List Any ==
    import PA
    k : NonNegativeInteger
    m : NonNegativeInteger
    (m := #vp) ~= #vn =>
          error "Number of polynomials and number of degrees do not agree"
    vpa :VPA := vector([new(sigma, 0$K)$PA for k in 1..m])
    for k in 1..m repeat
        p := vp(k)
        vk := vpa(k)
        while not(zero? p) repeat
            l : NonNegativeInteger := degree(p)
            if l < sigma then
                vk(l) := leadingCoefficient(p)
            p := reductum p
    naiveBeckermannLabahn1(vpa, vn, sigma, prime, pts, up__residual, _
                           up__poly)

  naiveBeckermannLabahn1(vpa : VPA, vn : Vector Integer, _
                         sigma : NonNegativeInteger, prime : Integer, _
                         pts : Integer-> K, _
                         up__residual : (PA, K, Integer) -> Void, _
                         up__poly : (PA, K, Integer) -> Void) : List Any ==
    k : NonNegativeInteger
    m : NonNegativeInteger
    (m := #vpa) ~= #vn =>
          error "Number of polynomials and number of degrees do not agree"

    m1 : Integer := 0
    for k in 1..m repeat
        m1 := m1 + vn(k) + 1
    mp := new(m, empty()$PA)$VPA
    m2 : Integer := 0
    for k in 1..m repeat
        mp(k) := new(m1 pretend NonNegativeInteger, 0)$PA
        vk := mp(k)
        vk(m2) := 1
        m2 := m2 + vn(k) + 1
    vd : Vector Integer := vector([vn(k) for k in 1..m])
    naiveBeckermannLabahn0(mp, vpa, vd, sigma, prime, pts, up__residual, _
                           up__poly)
    [coerce(mp)$AnyFunctions1(VPA), _
     coerce(vpa)$AnyFunctions1(VPA), _
     coerce(vd)$AnyFunctions1(Vector Integer)]

  vector__shift(v : PA): Void ==
    n := #v
    i : SingleInteger := (n - 1)::SingleInteger
    while i > 0 repeat
        v(i pretend NonNegativeInteger) := v((i - 1) pretend NonNegativeInteger)
        i := i - 1
    v(0) := 0

  mul__by__binomial__pointwise(v : PA, pt : K, pts : PA,_
       p : Integer) : Void ==
    n := #v
    for i in 0..(n - 1) repeat
        pp := QSADDMOD(pts(i), pt, p)$Lisp
        v(i) := mulmod(v(i), pp, p)

  naiveBeckermannLabahn0(mp : VPA, vp : VPA, vd : Vector Integer,_
                       sigma : NonNegativeInteger, p : Integer,
                       pts : Integer-> K, _
                       up__residual : (PA, K, Integer) -> Void, _
                       up__poly : (PA, K, Integer) -> Void):Void ==
    m := #vd
    vc := new(m, 0)$(Vector K)
    maxd : Integer
    pi : Integer
    m1 := #mp(1) - 1
    s1 := sigma-1
    for l in 0..(s1::NonNegativeInteger) repeat
        pt := pts(l)
        maxd := -1
        pi := 0
        for k in 1..m repeat
            vc(k) := vp(k)(l)
            if vc(k) ~= 0 and maxd < vd(k) then
                pi := k
                cpi := vc(k)
                maxd := vd(k)
        pi = 0 =>
             "iterate"
        vcinv := mulmod(p-1, invmod(vc(pi), p pretend SingleInteger), _
                            p)
        for k in 1..m repeat
            if vc(k) ~= 0 and vd(k) >= 0 and k ~= pi then
                vckinv : Integer := mulmod(vcinv, vc(k), p)
                vector__add__mul(vp(k), vp(pi), l, s1, vckinv, p)
                vector__add__mul(qelt(mp, k), qelt(mp, pi), 0, m1, vckinv, p)
        vd(pi) := vd(pi) - 1
        if vd(pi) >= 0 then
            up__residual(vp(pi), pt, p)
            up__poly(qelt(mp, pi), pt, p)

  critical__index(m : MPA, i : Integer, d : Integer, _
                  vn : Vector Integer) : Integer ==
      nc := #vn
      for j in 1..nc repeat
          nj := vn(j) - d
          nj < 0 => "iterate"
          pa := qelt(m, i, j)
          pa(nj) ~= 0 => return j
      error "Incorrect defect"

  swap__rows(m : MPA, i : Integer, j : Integer) : Void ==
      i = j => "nothing"::Void
      mp := m pretend PrimitiveArray PrimitiveArray PA
      tmp := mp(i - 1)
      mp(i - 1) := mp(j - 1)
      mp(j - 1) := tmp

  mult__vector(v : PA, c : K, p : Integer) : Void ==
      n := #v
      for i in 0..(n - 1) repeat
          v(i) := mulmod(c, v(i), p)

  mult__row(r : PrimitiveArray PA, c : K, p : Integer) : Void ==
      m := #r
      for i in 0..(m - 1) repeat mult__vector(r(i), c, p)

  add__vector(v1 : PA, v2 : PA, c : K, k : Integer, p : Integer) : Void ==
      n := #v1
      for i in k..(n - 1) repeat
          v1(i) := muladdmod(c, v2(i - k), v1(i), p)

  add__row(r1 : PrimitiveArray PA, r2 : PrimitiveArray PA, _
           c : K, k : Integer, p : Integer) : Void ==
      m := #r1
      for i in 0..(m - 1) repeat add__vector(r1(i), r2(i), c, k, p)

  reduce__row__by__row1(rj : PrimitiveArray PA, ri : PrimitiveArray PA, _
                        ci : Integer, cdeg : Integer, vdiff : Integer, _
                        p : Integer) : Void ==
      rj0 := rj(ci - 1)
      vdiff < 0 =>
          error "Internal error : vdiff < 0 in reduce__row__by__row1"
      k := vdiff + cdeg
      c := rj0(k)
      c ~= 0 =>
          add__row(rj, ri, (p - c)::K, vdiff, p)

  top__reduce__by__row(m : MPA, i : Integer, ci : Integer, _
                  vn : Vector Integer, vd : Vector Integer, _
                  p : Integer) : Void ==
      nr := #vd
      mp := m pretend PrimitiveArray PrimitiveArray PA
      ri := mp(i - 1)
      mdeg := vn(ci)
      cdeg := mdeg - vd(i)
      mcoeff := ri(ci - 1)(cdeg)
      minv := invmod(mcoeff, p)::K
      mult__row(ri, minv, p)
      for j in (i + 1)..nr repeat
          reduce__row__by__row1(mp(j - 1), ri, ci, cdeg, vd(i) - vd(j), p)

  final__reduce(m : MPA, civ : VI, vn : VI, vd : VI, p : Integer) : Void ==
      ns := #vd
      mvd := vd(1)
      mp := m pretend PrimitiveArray PrimitiveArray PA
      for j in 1..ns repeat
          vdj := vd(j)
          rj := mp(j - 1)
          for d in 0..(mvd - vdj) repeat
              for i in 1..ns repeat
                  i = j => "iterate"
                  vdi := vd(i)
                  vdi < vdj + d => break
                  ri := mp(i - 1)
                  ci := civ(i)
                  reduce__row__by__row1(rj, ri, ci, vn(ci) - vdi, d, p)

  reduceBasis0(m : MPA, vn : Vector Integer, vd : Vector Integer, _
              p : Integer) : NBR ==
      nc := #vn
      ns := #vd
      civ := new(ns, 0)$Vector(Integer)
      ci : Integer
      for i in 1..ns repeat
          maxd : Integer := -1
          maxj : Integer
          for j in i..ns repeat
              cd := vd(j)
              cd > maxd =>
                  maxd := cd
                  ci := critical__index(m, j, maxd, vn)
                  maxj := j
              cd = maxd =>
                  nci := critical__index(m, j, maxd, vn)
                  nci < ci =>
                      ci := nci
                      maxj := j
          swap__rows(m, i, maxj)
          tmp := vd(i)
          vd(i) := vd(maxj)
          vd(maxj) := tmp
          civ(i) := ci
          top__reduce__by__row(m, i, ci, vn, vd, p)
      final__reduce(m, civ, vn, vd, p)
      [m, vd, civ]

  reduceBasis(m : VPA, vn : Vector Integer, vd : Vector Integer, _
              p : Integer) : NBR ==
      nr := #vd
      nc := #vn
      ns := 0
      for i in 1..nr repeat
          if vd(i) >= 0 then
              ns := ns + 1
      res := new(ns, nc, empty()$PA)$MPA
      nvd := new(ns, 0)$Vector(Integer)
      civ := new(ns, 0)$Vector(Integer)
      j := 1
      for i in 1..nr repeat
          mi := m(i)
          m2 : SingleInteger := 0
          if vd(i) >= 0 then
              nvd(j) := vd(i)
              for k in 1..nc repeat
                  vnk1 := (vn(k) + 1) pretend SingleInteger
                  resjk := new(vnk1 pretend NonNegativeInteger, 0)$PA
                  for i1 in 0..(vnk1 - 1) repeat
                      resjk(i1) := mi(m2 + i1)
                  m2 := m2 + vnk1
                  qsetelt!(res, j, k, resjk)
              j := j + 1
      reduceBasis0(res, vn, nvd, p)

@

\section{Modular solver for polynomials}

<<package IMODHP InnerModularHermitePade>>=

)abbrev package IMODHP InnerModularHermitePade
++ Description: This package solves Hermite-Pade interpolation problem
++  over ring of integer polynomials.  We use reduction modulo primes
++  and modular reconstruction to reduce problem to polynomials modulo
++  $Z_p$.  Then we use evaluation and Lagrange interpolation to
++  reduce problem to solving over $Z_p$.

VI ==> Vector Integer
PA ==> U32Vector
PPA ==> PrimitiveArray PA
VPA ==> Vector PA
MP ==> Polynomial Integer
PMP ==> PrimitiveArray Fraction MP
F ==> Fraction MP
PAF ==> PrimitiveArray F
PAI ==> PrimitiveArray Integer
VPAF ==> Vector PrimitiveArray F
MPA ==> TwoDimensionalArray PA
NBR ==> Record(basis : MPA, defects : VI, cinds : VI)

PBR ==> Record(defects : VI, cinds : VI, _
               rowlen : Integer, offsetdata : VI, _
               expdata : SortedExponentVector, _
               coeffdata : PA)

PBRI ==> Record(defects : VI, cinds : VI, _
               rowlen : Integer, offsetdata : VI, _
               expdata : SortedExponentVector, _
               coeffdata : PAI)

PDR ==> Record(nvars : Integer, offsetdata : VI, _
               expdata : SortedExponentVector, _
               coeffdata : PA)

-- part of solver state shared between recursion levels
PSS ==> Record(degree__bounds : VI, pss__sigma : NonNegativeInteger, _
               points : PA, pss__qvar : Symbol, pss__qval : Integer, _
               prime : Integer, pss__kind : Symbol, _
               oldva : VI, oldciv : VI, pss__m : Integer, sol__cnt : Integer,
               eval1coeffbuf : PA, _
               eval1expbuf : SortedExponentVector)

GEN ==> (U32Vector, Integer, Integer) -> Vector U32Vector

InnerModularHermitePade: with
    do__modular__solve : (VPA, Vector Integer, NonNegativeInteger, _
                          PA, Integer, Symbol) -> Union(NBR, "no__solution")

    do__poly__modular : (List Symbol, PMP, PSS, GEN) _
                 -> Union(PBR, "failed", "no__solution")

    do__poly__integer : (List Symbol, PMP, Vector Integer, _
                         NonNegativeInteger, PA, Symbol, Symbol, GEN) _
                 -> Union(PBRI, "no__solution")

    merge__exponents : (Integer, VI, SortedExponentVector, VI, _
                        SortedExponentVector) -> List List Integer

    merge2 : (Integer, List Integer, List Integer, VI, _
              SortedExponentVector, VI, SortedExponentVector) _
              -> Record(offsetdata : VI, expdata : SortedExponentVector)

    eval__and__solve : (Integer,  List Symbol, PMP, _
                     PSS, GEN) -> Union(PBR, "failed", "no__solution")

    modpeval : (MP, List Symbol, List Integer, Integer) -> Integer

 == add

    MS ==> NaiveBeckermannLabahnModular
    VMR ==> VectorModularReconstructor
    VIR ==> VectorIntegerReconstructor
    K1 ==> SingleInteger

    Qmul ==> QSMULMOD32$Lisp
    Qmuladd ==> QSMULADDMOD64_-32$Lisp

    import U32VectorPolynomialOperations

    SmpTerm ==> Record(k : NonNegativeInteger, c : MP)
    VPoly ==>  Record(v: Symbol, ts: List SmpTerm)
    SmpRep ==>  Union(Integer, VPoly)


    eval1a(pol : MP, pt : Integer, pss : PSS) : Integer ==
        p := pss.prime
        polr := pol pretend SmpRep
        polr case Integer =>
            return polr
        polu : List SmpTerm := polr.ts
        i : SingleInteger := 0
        coeffs := pss.eval1coeffbuf
        exps := pss.eval1expbuf
        n := #coeffs
        ns := n pretend SingleInteger
        for t0 in polu repeat
            if i >= n then
                nn := 2*n
                ncoeffs := new(nn, 0)$PA
                copy__first(ncoeffs, coeffs, n)
                coeffs := ncoeffs
                pss.eval1coeffbuf := coeffs
                nexps := new(nn, 0)$SortedExponentVector
                copy__first(nexps pretend PA, exps pretend PA, n)
                exps := nexps
                pss.eval1expbuf := exps
                n := nn
            t1 := t0.c pretend SmpRep
            exps(i) := t0.k
            if t1 case Integer then
                coeffs(i) := t1
            else
                error "More than one variable in eval1a"
            i := i + 1
        res : Integer := 0
        ptk : Integer := 1
        pk : Integer := 0
        for j in (i - 1)..0 by -1 repeat
            ki := exps(j)
            while pk < ki repeat
                ptk := Qmul(ptk, pt, p)
                pk := pk + 1
            res := Qmuladd(ptk, coeffs(j), res, p)
        res

    eval1s(gv0 : PMP, pt : Integer, var : Symbol, _
           pss : PSS) : Union(PA, "failed") ==
        n := #gv0
        p := pss.prime
        ress := new(n , 0)$PA
        for j in 0..(n - 1) repeat
            nlcq := gv0(j)
            nm := eval1a(numer(nlcq), pt, pss)
            dm := eval1a(denom(nlcq), pt, pss)
            dm = 0 => return "failed"
            dms := dm pretend K1
            nlc := Qmul(nm, invmod(dms, p pretend K1), p)
            ress(j) := nlc
        ress

    modpreduction(x : MP, p : Integer) : MP ==
      xr : SmpRep := x pretend SmpRep
      c0 : Integer
      xr case Integer =>
         c0 := positiveRemainder(xr, p)
         xr := c0
         (SETF$Lisp)(xr, xr) pretend MP
      vx : Symbol := xr.v
      xu : List SmpTerm := xr.ts
      yu : List SmpTerm := []
      c1 : MP
      for t0 in xu repeat
        t1 := t0.c pretend SmpRep
        t1 case Integer =>
          c0 := positiveRemainder(t1, p)
          c0 = 0 => 0
          xr := c0
          yu := cons([t0.k, (SETF$Lisp)(xr, xr) pretend MP], yu)
        c1 := modpreduction(t0.c, p)
        c1 = 0 => 0
        yu := cons([t0.k, c1], yu)
      xr :=
         yu = [] => 0
         [vx, reverse yu]
      (SETF$Lisp)(xr, xr) pretend MP

    modpeval(x : MP, vars : List Symbol, pts : List Integer, _
             p : Integer) : Integer ==
        xr : SmpRep := x pretend SmpRep
        xr case Integer =>
            return positiveRemainder(xr, p)
        vx : Symbol := xr.v
        vx ~= first(vars) =>
            return modpeval(x, rest vars, rest pts, p)
        vxval := first pts
        vars := rest vars
        pts := rest pts
        xu : List SmpTerm := xr.ts
        yu : List SmpTerm := []
        ptk : Integer := 1
        kk : Integer := 0
        res : Integer := 0
        xu := reverse(xu)
        for t0 in xu repeat
            t1 := t0.c pretend SmpRep
            kk1 := t0.k
            while kk < kk1 repeat
                  ptk := Qmul(vxval, ptk, p)
                  kk := kk + 1
            c0 :=
                  t1 case Integer => positiveRemainder(t1, p)
                  modpeval(t0.c, vars, pts, p)
            res := Qmuladd(ptk, c0, res, p)
        res

    eval2s(gv0 : PMP, pt : Integer, var : Symbol, _
           p : Integer) : Union(PMP, "failed") ==
        n := #gv0
        ress := new(n , 0)$PMP
        vars := [var]@List(Symbol)
        pts := [pt]@List(Integer)
        for j in 0..(n - 1) repeat
            nlcq := gv0(j)
            nmp := eval(numer(nlcq), vars, pts)
            dmp := eval(denom(nlcq), vars, pts)
            nm := modpreduction(nmp, p)
            dm := modpreduction(dmp, p)
            dm = 0 => return "failed"
            ress(j) := nm/dm
        ress

    eval3s(gv0 : PMP, p : Integer) : Union(PMP, "failed") ==
        n := #gv0
        ress := new(n , 0)$PMP
        for j in 0..(n - 1) repeat
            nlcq := gv0(j)
            nmp := numer(nlcq)
            dmp := denom(nlcq)
            nm := modpreduction(nmp, p)
            dm := modpreduction(dmp, p)
            dm = 0 => return "failed"
            ress(j) := nm/dm
        ress

    do__modular__solve0(gv : VPA, ve : Vector Integer, _
                       sigma : NonNegativeInteger, _
                       pts : PA, _
                       prime : Integer, kind : Symbol) : List Any ==
        kind = 'diffHP or kind = qdiffHP =>
            naiveBeckermannLabahn(gv, ve, sigma, prime)$MS
        kind = 'shiftHP or kind = 'qshiftHP or kind = 'qmixed =>
            naiveBeckermannLabahnMultipoint(gv, ve, pts, prime)$MS
        error "kind must be diffHP, qdiffHP, shiftHP, qshiftHP or qmixed"

    do__modular__solve(gv : VPA, ve : Vector Integer, _
                       sigma : NonNegativeInteger, _
                       pts : PA, _
                       prime : Integer, kind : Symbol) _
                      : Union(NBR, "no__solution") ==
        blr := do__modular__solve0(gv, ve, sigma, pts, prime, kind)
        dva := blr(3)
        va := retract(dva)$AnyFunctions1(Vector Integer)
        ok := false
        m := #va
        for i in 1..m repeat
            ok := ok or va(i) >= 0
        not(ok) => return "no__solution"
        dbm := blr(1)
        bm := retract(dbm)$AnyFunctions1(Vector PA)
        return reduceBasis(bm, ve, va, prime)$MS

    compute__blocks(offsets : VI, rowlen : Integer, nsols : Integer) : VI ==
        block__offsets := new(nsols pretend NonNegativeInteger, 0)$VI
        for i in 1..nsols repeat
            block__offsets(i) := offsets((i - 1)*rowlen + 1)
        block__offsets

    merge__exponents(nvars : Integer, offsets : VI, _
                     exps : SortedExponentVector, noffsets : VI, _
                     nexps : SortedExponentVector) : _
              List List Integer ==
        n := #exps quo nvars
        m := #nexps quo nvars
        oc := #offsets
        -- i0 and j0 count exponents in exps and nexps respectively
        i0 : Integer := 0
        j0 : Integer := 0
        -- ci counts exponents in merged exponent vector
        ci : Integer := 0
        -- i = nvars*i0, j = nvars*j
        i : Integer := 0
        j : Integer := 0
        -- limits of polynomials
        li : Integer := 0
        lj : Integer := 0
        -- result lists
        il : List Integer := []
        jl : List Integer := []
        -- kk counts trough polynomials
        kk : Integer := 1
        nn := nvars - 1
        repeat
            i0i : Integer := 1
            j0i : Integer := 1
            ii : Integer := nvars
            ji : Integer := nvars
            i0 = li or j0 = lj =>
                kk := kk + 1
                if i0 < li then
                    for jj in i0..(li - 1) repeat
                        jl := cons(ci, jl)
                        ci := ci + 1
                if j0 < lj then
                    for jj in j0..(lj - 1) repeat
                        il := cons(ci, il)
                        ci := ci + 1
                li = n =>
                    return [reverse! il, reverse! jl]
                i0 := li
                j0 := lj
                i := i0*nvars
                j := j0*nvars
                kk <= oc =>
                    li := offsets(kk)
                    lj := noffsets(kk)
                li := n
                lj := m
            for k in 0..nn repeat
                exps(i + k) ~= nexps(j + k) =>
                    exps(i + k) > nexps(j + k) =>
                        il := cons(ci, il)
                        ii := 0
                        i0i := 0
                        break
                    jl := cons(ci, jl)
                    ji := 0
                    j0i := 0
                    break
            ci := ci + 1
            i := i + ii
            j := j + ji
            i0 := i0 + i0i
            j0 := j0 + j0i

    merge2(nvars : Integer, odl : List Integer, ndl : List Integer, _
           ov1 : VI, exps1 : SortedExponentVector, ov2 : VI, _
           exps2 : SortedExponentVector) : _
           Record(offsetdata : VI, expdata : SortedExponentVector) ==
        n0 := #exps1
        nn := #odl
        n1 := (n0 quo nvars) + nn
        nn1 := n1*nvars
        nexps := new(nn1 :: NonNegativeInteger, 0)$SortedExponentVector
        m := #ov2
        noffsets := new(m, 0)$VI
        nv1 := nvars - 1
        i0 : Integer := 0
        j0 : Integer := 0
        ci0 : Integer := 0
        i : Integer := 0
        j : Integer := 0
        ci : Integer := 0
        j00 : Integer :=
            empty?(ndl) => n1
            first(ndl)
        i00 := first(odl)
        li := ov1(1)
        lj := ov2(1)
        kk : Integer := 1
        for ci0 in 0..(n1 - 1) repeat
            while i0 = li and j0 = lj repeat
                noffsets(kk) := ci0
                kk := kk + 1
                if kk <= m then
                    li := ov1(kk)
                    lj := ov2(kk)
                else
                    li := n1
                    lj := n1
            if ci0 = j00 then
                for k in 0..nv1 repeat
                    nexps(ci + k) := exps1(i + k)
                ndl := rest ndl
                j00 :=
                    empty?(ndl) => n1
                    first(ndl)
            else
                for k in 0..nv1 repeat
                    nexps(ci + k) := exps2(j + k)
                j := j + nvars
                j0 := j0 + 1
            if ci0 ~= i00 then
                i := i + nvars
                i0 := i0 + 1
            else
                odl := rest odl
                i00 :=
                    empty?(odl) => n1
                    first(odl)
            ci := ci + nvars
        for i in kk..m repeat
            noffsets(i) := n1
        [noffsets, nexps]

    check__defects(va : VI, civ : VI, pss : PSS) : _
         Union("OK", "failed", "all__bad") ==
        -- Check for bad reduction
        nsols := pss.sol__cnt
        is__bad : Boolean := #va > nsols
        all__bad : Boolean := #va < nsols
        if #va = nsols then
            ova  := pss.oldva
            ociv := pss.oldciv
            for i in 1..nsols repeat
                va(i) < ova(i) =>
                    all__bad := true
                    break
                va(i) > ova(i) =>
                    is__bad := true
                    break
                civ(i) < ociv(i) =>
                    all__bad := true
                    break
                civ(i) > ociv(i) =>
                    is__bad := true
                    break
        is__bad => return "failed"
        all__bad => return "all__bad"
        return "OK"

    eval__and__solve(pt : Integer, vars : List Symbol, gv0 : PMP, _
                     pss : PSS, gen: GEN) : Union(PBR, "failed", "no__solution") ==
        p := pss.prime
        nvars := #vars
        nvars = 1 =>
            ngv10p := eval1s(gv0, pt, first vars, pss)
            ngv10p case "failed" => return "failed"
            ngv10 := ngv10p :: PA
            ngv2 := gen(ngv10, p, pss.pss__qval)
            ve := pss.degree__bounds
            blr := do__modular__solve(ngv2, ve, pss.pss__sigma,
                                      pss.points, p, pss.pss__kind)
            blr case "no__solution" => return "no__solution"
            rblr := blr::NBR
            bm := rblr.basis
            va := rblr.defects
            civ := rblr.cinds
            nsols := #va
            r__cnt : Integer := 0
            m := #ve
            for j in 1..m repeat r__cnt := r__cnt + ve(j) + 1
            r__cnt := r__cnt*nsols
            cv := new(r__cnt :: NonNegativeInteger, 0)$PA
            ev := new(r__cnt :: NonNegativeInteger, 0)$SortedExponentVector
            ov := new(nsols*m, 0)$VI
            k : Integer := 0
            k1 : Integer := 1
            for i in 1..nsols repeat
                for j in 1..m repeat
                    ov(k1) := k
                    k1 := k1 + 1
                    mm := ve(j)
                    cp := bm(i, j)
                    for l in 0..mm repeat
                        cpl := cp(l)
                        if cpl ~= 0 then
                            cv(k) := cpl
                            ev(k) := l
                            k := k + 1
            ncv := new(k ::NonNegativeInteger, 0)$PA
            nev := new(k ::NonNegativeInteger, 0)$SortedExponentVector
            for i in 0..(k - 1) repeat
                ncv(i) := cv(i)
                nev(i) := ev(i)
            return [va, civ, m, ov, nev, ncv]
        ngv0p := eval2s(gv0, pt, first vars, p)
        ngv0p case "failed" => return "failed"
        ngv0 := ngv0p::PMP
        return do__poly__modular(rest vars, ngv0, pss, gen)

    do__poly__modular(vars : List Symbol, gv0 : PMP, pss : PSS, gen: GEN) : _
          Union(PBR, "failed", "no__solution") ==
        lpt : List Integer := []
        bad__cnt : Integer := 0
        good__cnt : Integer := 0
        rstate : VMR
        exps := empty()$SortedExponentVector
        offsets := empty()$VI
        all__bad := true
        update__points :=
             pss.pss__kind = 'qshiftHP and pss.pss__qvar = first vars
        update__qval :=
             (pss.pss__kind = 'qshiftHP or pss.pss__kind = 'qdiffHP or _
              pss.pss__kind = 'qmixed) and pss.pss__qvar = first vars
        p := pss.prime
        m := pss.pss__m
        nvars := #vars
        nsols : Integer := m + 1
        repeat
            -- choose point
            ok := false
            for k in 1..100 while not(ok) repeat
                pt := random(p)
                member?(pt, lpt) => "iterate"
                lpt := cons(pt, lpt)
                ok := true
            if positiveRemainder((npt := #lpt), 100) = 0 then
                print("Number of evaluation points"::OutputForm)
                print(npt::OutputForm)
            not(ok) => error "Run out of evaluation points"

            if update__points then
                pts := pss.points
                qn : Integer := 1
                for k in 0..(pss.pss__sigma - 1) repeat
                    pts(k) := qn
                    qn := positiveRemainder(pt*qn, p)
            if update__qval then
                pss.pss__qval := pt

            -- eval and solve reduced system
            pprp := eval__and__solve(pt, vars, gv0, pss, gen)
            pprp case "no__solution" => return "no__solution"
            pprp case "failed" =>
                bad__cnt := bad__cnt + 1
                bad__cnt > good__cnt + 2 => return "failed"
                "iterate"
            ppr := pprp::PBR

            -- check for bad reduction and other loosage
            va := ppr.defects
            civ := ppr.cinds
            nexps := ppr.expdata
            noffsets := ppr.offsetdata
            coeffs := ppr.coeffdata
            chk__ress := check__defects(va, civ, pss)
            chk__ress case "failed" =>
                bad__cnt := bad__cnt + 1
                bad__cnt > good__cnt + 2 => return "failed"
                "iterate"
            if chk__ress case "all__bad" then
                all__bad := true
            if all__bad then
                nsols := #va
                pss.sol__cnt := nsols
                pss.oldva := va
                pss.oldciv := civ
                exps := nexps
                offsets := noffsets
                rstate := empty(#coeffs, p)$VMR
            all__bad := false

            good__cnt := good__cnt + 1

            -- merge exponents
            dl := merge__exponents(nvars, offsets, exps, noffsets, nexps)
            odl := dl(1)
            ndl := dl(2)
            if odl ~= [] then
                oer := merge2(nvars, odl, ndl, offsets, exps, _
                              noffsets, nexps)
                offsets := oer.offsetdata
                exps := oer.expdata
                -- add__slots is wrong in case of change of leading exponent
                -- add__slots(odl, rstate)
                ncc := #exps quo nvars
                rstate := empty(ncc::NonNegativeInteger, p)$VMR

            if ndl ~= [] then
                -- expand coeffs
                n0 := #coeffs
                nn := #ndl
                n1 := n0 + nn
                ncoeffs := new(n1, 0)$PA
                i : Integer := 0
                jl := first ndl
                for j in 0..(n1 - 1) repeat
                    j = jl =>
                        ncoeffs(j) := 0
                        ndl := rest ndl
                        jl :=
                            empty?(ndl) => n1
                            first ndl
                    ncoeffs(j) := coeffs(i)
                    i := i + 1
                coeffs := ncoeffs

            -- normalize
            block__offsets := compute__blocks(offsets, m, nsols)
            n1 := #coeffs
            ok := true
            for i in 1..nsols repeat
                cnum := civ(i)
                ofin := m*(i - 1) + cnum
                ofi := offsets(ofin)
                nofi :=
                    i < nsols or cnum < m => offsets(ofin + 1)
                    n1
                nofi := nofi - 1
                nofi < ofi =>
                    print(civ::OutputForm)
                    print(offsets::OutputForm)
                    error "Internal error: corrupted offsets 1"
                coeffs(nofi) = 0 =>
                    ok := false
                    break
                invc := invmod(coeffs(nofi), p)
                lo := block__offsets(i)
                hi :=
                    i < nsols => block__offsets(i + 1)
                    n1
                for j in lo..(hi - 1) repeat
                    coeffs(j) := Qmul(coeffs(j), invc, p)
            not(ok) => "iterate"
            chinese__update(coeffs, pt, rstate)$VMR

            -- try reconstruction
            pp := reconstruct(rstate, nvars, block__offsets, _
                              offsets, exps)$VMR
            pp case "failed" => "iterate"
            -- if succesful return
            rr := pp::PDR
            return [va, civ, m, rr.offsetdata, _
                    rr.expdata, rr.coeffdata]

    do__poly__integer0(vars : List Symbol, gv0 : PMP, pss : PSS, gen: GEN) _
            : Union(PBRI, "no__solution") ==
        lp : List Integer := []
        rstate : VIR
        exps := empty()$SortedExponentVector
        offsets := empty()$VI
        all__bad := true
        p : Integer := 16
        m := pss.pss__m
        nvars := #vars
        nsols : Integer := m + 1
        repeat
            -- choose point
            ok := false
)if true
            for k in 1..100 while not(ok) repeat
                p := nextPrime(random(200000) + 200000 _
                              )$IntegerPrimesPackage(Integer)
                member?(p, lp) => "iterate"
                lp := cons(p, lp)
                ok := true
            not(ok) => error "Run out of primes"
            -- print("Using prime"::OutputForm)
            -- print(p::OutputForm)
)else
            p := nextPrime(p+1)$IntegerPrimesPackage(Integer)
)endif
            pss.prime := p

            -- eval and solve reduced system
            ngv0p := eval3s(gv0, p)
            ngv0p case "failed" => "iterate"
            ngv0 := ngv0p::PMP
            pprp := do__poly__modular(vars, ngv0, pss, gen)

            pprp case "no__solution" => return "no__solution"
            pprp case "failed" => "iterate"
            ppr := pprp::PBR

            -- check for bad reduction and other loosage
            va := ppr.defects
            civ := ppr.cinds
            nexps := ppr.expdata
            noffsets := ppr.offsetdata
            coeffs := ppr.coeffdata
            chk__ress := check__defects(va, civ, pss)
            chk__ress case "failed" => "iterate"
            if chk__ress case "all__bad" then
                all__bad := true
            if all__bad then
                nsols := #va
                pss.sol__cnt := nsols
                pss.oldva := va
                pss.oldciv := civ
                exps := nexps
                offsets := noffsets
                rstate := empty(#coeffs)$VIR
            all__bad := false

            -- merge exponents
            dl := merge__exponents(nvars + 1, offsets, exps, noffsets, nexps)
            odl := dl(1)
            ndl := dl(2)
            if odl ~= [] then
                oer := merge2(nvars + 1, odl, ndl, offsets, exps, _
                              noffsets, nexps)
                offsets := oer.offsetdata
                exps := oer.expdata
                -- add__slots is wrong in case of change of leading exponent
                -- add__slots(odl, rstate)
                ncc := #exps quo (nvars + 1)
                -- print("resetting rstate"::OutputForm)
                rstate := empty(ncc::NonNegativeInteger)$VIR

            if ndl ~= [] then
                -- expand coeffs
                n0 := #coeffs
                nn := #ndl
                n1 := n0 + nn
                ncoeffs := new(n1, 0)$PA
                i : Integer := 0
                jl := first ndl
                for j in 0..(n1 - 1) repeat
                    j = jl =>
                        ncoeffs(j) := 0
                        ndl := rest ndl
                        jl :=
                            empty?(ndl) => n1
                            first ndl
                    ncoeffs(j) := coeffs(i)
                    i := i + 1
                coeffs := ncoeffs

            -- normalize
            block__offsets := compute__blocks(offsets, m, nsols)
            n1 := #coeffs
            ok := true
            for i in 1..nsols repeat
                cnum := civ(i)
                ofin := m*(i - 1) + cnum
                ofi := offsets(ofin)
                nofi :=
                    i < nsols or cnum < m => offsets(ofin + 1)
                    n1
                nofi := nofi - 1
                nofi < ofi =>
                    print(civ::OutputForm)
                    print(offsets::OutputForm)
                    error "Internal error: corrupted offsets"
                coeffs(nofi) = 0 =>
                    ok := false
                    break
                invc := invmod(coeffs(nofi), p)
                lo := block__offsets(i)
                hi :=
                    i < nsols => block__offsets(i + 1)
                    n1
                for j in lo..(hi - 1) repeat
                    coeffs(j) := Qmul(coeffs(j), invc, p)
            not(ok) => "iterate"
            chinese__update(coeffs, p, rstate)$VIR

            -- try reconstruction
            pp := reconstruct(rstate, block__offsets)$VIR
            pp case "failed" => "iterate"
            -- if succesful return
            return [va, civ, m, offsets, _
                    exps, pp::PAI]

    do__poly__integer(vars : List Symbol, gv0 : PMP, ve : Vector Integer, _
                      sigma : NonNegativeInteger, pts : PA, kind : Symbol, _
                      qvar : Symbol, gen: GEN) : Union(PBRI, "no__solution") ==
        pss := [ve, sigma, pts, qvar, 0, 0, kind, empty()$VI, _
                empty()$VI, #ve, #ve + 1, _
                new(10, 0)$PA,
                new(10, 0)$SortedExponentVector]@PSS
        return do__poly__integer0(vars, gv0, pss, gen)
@

\section{Specialized modular solvers}

<<package MODHP ModularHermitePade>>=
)abbrev package MODHP ModularHermitePade
++ Description: This package provides modular Hermite-Pade solvers
++  for a few rings.  Solver over integers is implemented in this
++  package.  Also it contains interfaces to solver over $Z_p$ and
++  solver over ring of integer polynomials.
K1 ==> SingleInteger
-- K2 ==> SingleInteger
MP ==> Polynomial Integer
PAN ==> SparseUnivariatePolynomial AlgebraicNumber
PPF ==> SparseUnivariatePolynomial Integer
PFI ==> SparseUnivariatePolynomial Fraction Integer
PFPI ==> SparseUnivariatePolynomial Fraction Polynomial Integer
PFPA ==> SparseUnivariatePolynomial Fraction Polynomial AlgebraicNumber
PK  ==> SparseUnivariatePolynomial K1
LPI ==> List PFI
LPPI ==> List PFPI
LPAN ==> List PAN
LPPA ==> List PFPA
LPPF ==> List PPF
NNI ==> NonNegativeInteger
MPI ==> Matrix SparseUnivariatePolynomial Integer
MPAN ==> Matrix PAN
MPPI ==> Matrix SparseUnivariatePolynomial Polynomial Integer
MPPA ==> Matrix SparseUnivariatePolynomial Polynomial AlgebraicNumber
PA ==> U32Vector
VPA ==> Vector PA
VI ==> Vector Integer
PAF ==> PrimitiveArray Fraction MP
VPAF ==> Vector PAF
PAI ==> PrimitiveArray Integer

PBRI ==> Record(defects : VI, cinds : VI, _
               rowlen : Integer, offsetdata : VI, _
               expdata : SortedExponentVector, _
               coeffdata : PAI)

MPA ==> TwoDimensionalArray PA
NBR ==> Record(basis : MPA, defects : VI, cinds : VI)

GEN ==> (U32Vector, Integer, Integer) -> Vector U32Vector
CHKR ==> Union("good", "reject", "no__solution")
SUP ==> SparseUnivariatePolynomial
ModularHermitePade(): with
   HP__solve__I : (List Fraction(Integer), List NNI, Symbol, NNI, _
                   GEN, (List SUP Integer) -> CHKR) -> Union(MPI, Boolean)
     ++ implements  HP__solve over integers.

   HP__solve__A : (List AlgebraicNumber, List NNI, Symbol, NNI, GEN, _
                    (List SUP AlgebraicNumber) -> CHKR) -> Union(MPAN, Boolean)
     ++ Fake solver over algebraic numbers.

   HP__solve__P : (List Fraction(MP), List NNI, Symbol, Symbol, NNI, GEN,
                    (List SUP MP) -> CHKR) -> Union(MPPI, Boolean)
     ++ implements  HP__solve over integer polynomials.

   HP__solve__PA : (List Fraction(Polynomial(AlgebraicNumber)), List NNI, _
                      Symbol, Symbol, NNI, GEN,
                     ((List SUP Polynomial(AlgebraicNumber))) -> CHKR) _
                    -> Union(MPPA, Boolean)
     ++ Fake solver over polynomials having algebraic coefficients.

   HP__solve__M : (List Integer, List NNI, Symbol, Integer, NNI, GEN) _
                  -> Union(MPI, Boolean)
     ++ implements  HP__solve over $Z_p$ with machine-sized $p$.

   check__sol1a : (VPA, PA, GEN, Integer, Integer, Integer) -> PA
     ++ one round of modular Monte Carlo check for solutions.

   VSUPI__to__VPA : (Vector SUP(Integer), Integer) -> VPA
     ++ evaluation routine

   VSUPPI__to__VPA : (Vector SUP(MP), List Symbol, List Integer, Integer) _
                   -> VPA
     ++ evaluation routine

   LFI__to__PA : (List Fraction(Integer), Integer, Integer)
                 -> Union(PA, "failed")
     ++ evaluation routine

   LFPI__to__PA : (List Fraction(MP), Integer, List Symbol, List Integer, _
                   Integer) -> Union(PA, "failed")
     ++ evaluation routine

   get__variables : (List Fraction(MP), Symbol, Symbol) -> List Symbol

  == add

   import PrintPackage
   import OutputForm
   Qmul ==> QSMULMOD32$Lisp

   SUPI__to__PA(poli : SparseUnivariatePolynomial(Integer), _
                p : Integer) : PA ==
       n := degree(poli)
       pa := new(n + 1, 0)$PA
       while not(zero? poli) repeat
           m := degree poli
           nlc := positiveRemainder(leadingCoefficient(poli), p)
           pa(m) := nlc
           poli := reductum poli
       pa

   VSUPI__to__VPA(vps : Vector SparseUnivariatePolynomial(Integer), _
                  p : Integer) : VPA ==
       m := #vps
       vpa := new(m, empty()$PA)$VPA
       for i in 1..m repeat
           vpa(i) := SUPI__to__PA(vps(i), p)
       vpa

   SUPPI__to__PA(poli : SUP(MP), vars : List Symbol, _
                 pts : List Integer, p : Integer) : PA ==
       n := degree(poli)
       pa := new(n + 1, 0)$PA
       while not(zero? poli) repeat
           m := degree poli
           nlc := modpeval(leadingCoefficient(poli), vars, pts,
                           p)$InnerModularHermitePade
           pa(m) := nlc
           poli := reductum poli
       pa

   VSUPPI__to__VPA(vps : Vector SUP(MP), vars : List Symbol, _
                   pts : List Integer, p : Integer) : VPA ==
       m := #vps
       vpa := new(m, empty()$PA)$VPA
       for i in 1..m repeat
           vpa(i) := SUPPI__to__PA(vps(i), vars, pts, p)
       vpa

   LFI__to__PA(lfi : List Fraction(Integer), n : Integer, _
               prime : Integer) : Union(PA, "failed") ==
       pa := new(n pretend NonNegativeInteger, 0)$PA
       for j in 0..(n - 1) for el in lfi repeat
           nm := positiveRemainder(numer(el), prime)
           dm := positiveRemainder(denom(el), prime)
           dm = 0 => return "failed"
           dms := dm pretend K1
           nlc := Qmul(nm, invmod(dms, prime pretend K1), prime)
           pa(j) := nlc pretend K1
       pa

   LFPI__to__PA(lfi : List Fraction(MP), n : Integer, _
               vars : List Symbol, pts : List Integer, _
               prime : Integer) : Union(PA, "failed") ==
       pa := new(n pretend NonNegativeInteger, 0)$PA
       for j in 0..(n - 1) for el in lfi repeat
           nm := modpeval(numer(el), vars, pts, prime)$InnerModularHermitePade
           dm := modpeval(denom(el), vars, pts, prime)$InnerModularHermitePade
           dm = 0 => return "failed"
           dms := dm pretend K1
           nlc := Qmul(nm, invmod(dms, prime pretend K1), prime)
           pa(j) := nlc pretend K1
       pa

   PPFtoPA(pfi : PPF, sigma : NNI, psi : K1) : Union(PA, "failed") ==
       pa := new(sigma, 0)$PA
       prime := psi :: Integer
       while not(zero? pfi) repeat
           m := degree pfi
           if m < sigma then
               nlcq := leadingCoefficient(pfi)
               nc := positiveRemainder(nlcq, prime)
               pa(m) := nc pretend K1
           pfi := reductum pfi
       pa

   LPPFtoVPA(lpi : LPPF, sigma : NNI, psi : K1) : Union(VPA, "failed") ==
       m := #lpi
       vpa := new(m, empty()$PA)$VPA
       for i in 1..m for p in lpi repeat
           vpp := PPFtoPA(p, sigma, psi)
           vpp case "failed" => return "failed"
           vpa(i) := vpp::PA
       vpa

   intpoly__to__PFI(p : SparseUnivariatePolynomial(Integer)) : PFI ==
       map((x : Integer) : Fraction(Integer) +-> x::Fraction(Integer), _
           p)$SparseUnivariatePolynomialFunctions2(Integer, Fraction(Integer))

   check__sol1a(nres : VPA, _
                gv0 : PA, gen : GEN, _
                sigma : Integer, qval : Integer, p : Integer) : PA ==
       m := #nres;
       gvp := gen(gv0, p, qval)
       res := new(sigma pretend NonNegativeInteger, 0)$PA
       for i in 1..m repeat
           truncated__mul__add(gvp(i), nres(i), res, sigma - 1, _
                           p)$U32VectorPolynomialOperations
       res

   RR ==> Record(numers : PrimitiveArray Integer, _
                 denoms : PrimitiveArray Integer)

   HP__solve__I(list : List Fraction(Integer), degs: List NNI, kind: Symbol, _
                sigma: NNI, gen: GEN, check : (List SUP Integer) -> CHKR) _
               : Union(MPI, Boolean) ==
       lp := []@List(Integer)
       kind = 'qdiffHP or kind = 'qshiftHP => true
       m := #degs
       degs__sum := reduce(_+, degs) + m
       ve: Vector Integer := vector [d::Integer for d in degs]
       pts :=
           kind = 'diffHP => empty()$PA
           kind = 'shiftHP =>
               pts0 := new(sigma, 0)$PA
               for i in 0..(sigma - 1) repeat
                   pts0(i) := i
               pts0
       vi := new(m, [])$Vector(List Integer)
       rv : U32Vector
       rstate : VectorIntegerReconstructor
       nsols : Integer := -1
       maxd : Integer := -1
       gv : VPA
       prime : Integer
       nprimes : Integer := 0
       nsols : Integer := m + 1
       oldva : Vector(Integer)
       oldciv : Vector(Integer)
       repeat
           ok := false
           for k in 1..100 while not(ok) repeat
               prime := nextPrime(random(2000000) + 2000000_
                                     )$IntegerPrimesPackage(Integer)
               member?(prime, lp) => "iterate"
               lp := cons(prime, lp)
               ok := true
           not(ok) => error "Run out of primes"
           nprimes := nprimes + 1
           psi := prime::K1
           gv0p := LFI__to__PA(list, #list, psi)
           gv0p case "failed" => "iterate"
           gv0 := gv0p::PA
           gv2 := gen(gv0, prime, 1)

           blr := do__modular__solve(gv2, ve, sigma, pts, prime, _
                     kind)$InnerModularHermitePade
           blr case "no__solution" => return false
           rblr := blr::NBR
           bm := rblr.basis
           va := rblr.defects
           civ := rblr.cinds
           -- Check for bad reduction
           #va > nsols => "iterate"
           is__bad : Boolean := false
           all__bad : Boolean := #va < nsols
           if #va = nsols then
               for i in 1..nsols repeat
                   va(i) < oldva(i) =>
                       all__bad := true
                       break
                   va(i) > oldva(i) =>
                       is__bad := true
                       break
                   civ(i) < oldciv(i) =>
                       all__bad := true
                       break
                   civ(i) > oldciv(i) =>
                       is__bad := true
                       break
           is__bad => "iterate"
           if all__bad then
               -- (Re-)initialize
               nsols := #va
               oldva := va
               oldciv := civ
               rstate := empty(nsols*degs__sum)
               rv := new((nsols::PositiveInteger)*degs__sum, 0)$U32Vector

           k : Integer := 0
           if positiveRemainder(nprimes, 100) = 0 then
               print("number of primes"::OutputForm)
               print(nprimes::OutputForm)
           for i in 1..nsols repeat
               for j in 1..m repeat
                   mm := ve(j)
                   cp := bm(i, j)
                   for l in 0..mm repeat
                       rv(k) := cp(l)
                       k := k + 1
           chinese__update(rv, prime, rstate)
           pp := rational__reconstruction(rstate)
           pp case "failed" =>
               "iterate"
           ppr := pp::RR
           nums := ppr.numers
           dens := pp.denoms
           cden := lcm entries dens
           k := 0
           resv :=  new(nsols::NonNegativeInteger, _
                        empty()$Vector(SparseUnivariatePolynomial Integer) _
                       )$Vector(Vector(SparseUnivariatePolynomial Integer))
           ii : Integer := 1
           sol__ok := true
           for i in 1..nsols repeat
               resvi := new(m, 0)$Vector(SparseUnivariatePolynomial Integer)
               for j in 1..m repeat
                   mm := ve(j)
                   s : SparseUnivariatePolynomial(Integer) := 0
                   for l in 0..mm repeat
                       cc := nums(k) * ((cden exquo dens(k))::Integer)
                       s := s + monomial(cc, l_
                            )$SparseUnivariatePolynomial(Integer)
                       k := k + 1
                   resvi(j) := s
               sol__okp := check(entries resvi)
               sol__okp case "reject" => "iterate"
               sol__okp case "no__solution" =>
                   sol__ok := false
                   break
               resv(ii) := resvi
               ii := ii + 1
           sol__ok =>
               mress := new(m, (ii - 1)::NonNegativeInteger, 0)$MPI
               for i in 1..(ii - 1) repeat
                   for l in 1..m repeat
                       mress(l, i) := resv(i)(l)
               return mress
       return true

   get__variables2(lpi : List(Fraction(MP))) : List(Symbol) ==
       res := []@List(Symbol)
       for p in lpi repeat
           res := setUnion(res, variables(numer(p)))
           res := setUnion(res, variables(denom(p)))
       res

   unpack__poly(vars : List Symbol, exps : SortedExponentVector, _
                coeffs : PAI, lo : Integer, hi : Integer) _
               : SparseUnivariatePolynomial(MP) ==
       res : SparseUnivariatePolynomial(MP) := 0
       nvars := #vars
       nn := nvars + 1
       vars := reverse(vars)
       j : Integer := -1
       i := lo*(nn)
       term : MP
       term1 : MP
       for i0 in lo..hi repeat
           jj := exps(i)
           jj < j =>
               error "Internal error: inconsistent exponent vector"
           if jj > j then
               if j >= 0 then
                   res := res + monomial(term, j::NNI _
                      )$SparseUnivariatePolynomial(MP)
               j := jj
               term := 0
           term1 := coeffs(i0)::MP
           for k in 1..nvars for var in vars repeat
               term1 := term1*monomial(1, var, exps(i + k)::NNI)$MP
           term := term1 + term
           i := i + nn
       if j >= 0 then
           res := res + monomial(term, j::NNI)$SparseUnivariatePolynomial(MP)
       res

   intpoly__to__PFPI(p : SparseUnivariatePolynomial(MP)) : PFPI ==
       map((x : MP) : Fraction(MP) +-> x::Fraction(MP), _
           p)$SparseUnivariatePolynomialFunctions2(MP, Fraction(MP))


   PFPI__to__PFI(p : PFPI) : PFI ==
       res : PFI := 0
       while not(zero? p) repeat
           m := degree p
           q := leadingCoefficient(p)
           p := reductum(p)
           iq := retract(q)@Fraction(Integer)
           res := monomial(iq, m)$PFI + res
       res

   PI__to__PPI(p : SparseUnivariatePolynomial Integer) _
              : SparseUnivariatePolynomial(MP) ==
       res : SparseUnivariatePolynomial(MP) := 0
       while not(zero? p) repeat
           m := degree p
           q := leadingCoefficient(p)
           p := reductum(p)
           mq := q::MP
           res := monomial(mq, m)$SparseUnivariatePolynomial(MP) + res
       res

   LPI__to__LPPI(lp : List SUP Integer) : List SUP MP ==
       [PI__to__PPI(p) for p in lp]

   trivial__poly__solve(list : List Fraction(MP), degs : List NNI,
                        kind : Symbol, sigma : NNI, gen: GEN,
                        check : (List SUP MP) -> CHKR) : Union(MPPI, Boolean) ==
        kind = 'qshiftHP => return true
        if kind = 'qdiffHP then kind := 'diffHP
        nlist := [retract(q)@Fraction(Integer) for q in list]
        pres := HP__solve__I(nlist, degs, kind, sigma, gen,
                             (x : List SUP Integer) : CHKR
                                +-> check(LPI__to__LPPI(x)))
        pres case Boolean => return pres::Boolean
        resi := pres::MPI
        nr := nrows(resi)
        nc := ncols(resi)
        res := new(nr, nc, 0)$MPPI
        for i in 1..nr repeat
            for j in 1..nc repeat
                res(i, j) := PI__to__PPI(resi(i, j))
        res

   get__variables(list, kind, qvar) ==
       vars := get__variables2(list)
       if kind = 'qdiffHP or kind = 'qshiftHP or kind = 'qmixed then
           vars :=
               member?(qvar, vars) => vars
               cons(qvar, vars)
       reverse sort(vars)

   HP__solve__P(list, degs, kind, qvar, sigma, gen, check) ==
       lp := []@List(Integer)
       -- print(sigma::OutputForm)
       m := #degs
       ve: Vector Integer := vector [d::Integer for d in degs]
       pts :=
           kind = 'diffHP or kind = 'qdiffHP => empty()$PA
           kind = 'shiftHP or kind = 'qmixed =>
               pts0 := new(sigma, 0)$PA
               for i in 0..(sigma - 1) repeat
                   pts0(i) := i
               pts0
           kind = 'qshiftHP =>  new(sigma, 0)$PA
       vars := get__variables2(list)
       -- print(vars::OutputForm)
       if kind = 'qdiffHP or kind = 'qshiftHP or kind = 'qmixed then
           vars :=
               member?(qvar, vars) => vars
               cons(qvar, vars)
       empty?(vars) =>
           trivial__poly__solve(list, degs, kind, sigma, gen, check)
       gv0 := construct(list)$PrimitiveArray(Fraction MP)
       repeat
           pp := do__poly__integer(vars, gv0, ve, sigma, pts, _
                     kind, qvar, gen)$InnerModularHermitePade
           pp case "no__solution" => return false
           ppr := pp :: PBRI
           offsets := ppr.offsetdata
           oc := #offsets
           exps := ppr.expdata
           coeffs := ppr.coeffdata
           cc := #coeffs
           nsols := #offsets quo m
           ok := true
           kk : Integer := 1
           ohi := offsets(1)
           lo : Integer
           resv :=  new(nsols::NonNegativeInteger, _
                        empty()$Vector(SparseUnivariatePolynomial(MP))_
                       )$Vector(Vector(SparseUnivariatePolynomial(MP)))
           ii : Integer := 1
           for i in 1..nsols repeat
               resvi := new(m, 0)$Vector(SparseUnivariatePolynomial(MP))
               for j in 1..m repeat
                   lo := ohi
                   ohi :=
                       kk := kk + 1
                       kk <= oc => offsets(kk)
                       cc
                   hi := ohi - 1
                   resvi(j) := unpack__poly(vars, exps, coeffs, lo, hi)
               sol__okp  := check(entries resvi)
               sol__okp case "reject" => "iterate"
               sol__okp case "no__solution" =>
                   ok := false
                   break
               resv(ii) := resvi
               ii := ii + 1
           ok =>
               mress := new(m, (ii - 1)::NonNegativeInteger, 0
                           )$Matrix(SparseUnivariatePolynomial(MP))
               for i in 1..(ii - 1) repeat
                   for l in 1..m repeat
                       mress(l, i) := resv(i)(l)
               -- print("found solution"::OutputForm)
               return mress
           print("check__sol__poly rejected solution"::OutputForm)
           print(resvi::OutputForm)
           error "giving up"

   HP__solve__M(list, degs, kind, prime, sigma, gen) ==
       lp := []@List(Integer)
       kind = 'qdiffHP or kind = 'qshiftHP => true
       -- print(sigma::OutputForm)
       m := #degs
       ve: Vector Integer := vector [d::Integer for d in degs]
       pts :=
           kind = 'diffHP => empty()$PA
           kind = 'shiftHP =>
               pts0 := new(sigma, 0)$PA
               for i in 0..(sigma - 1) repeat
                   pts0(i) := i
               pts0
       gv0 := construct(list)$PA
       gv := gen(gv0, prime, 1)
       blr := do__modular__solve(gv, ve, sigma, pts, prime, _
                  kind)$InnerModularHermitePade
       blr case "no__solution" => return false
       rblr := blr::NBR
       bm := rblr.basis
       va := rblr.defects
       nsols := #va
       resv :=  new(nsols::NonNegativeInteger, _
                    empty()$Vector(SparseUnivariatePolynomial Integer) _
                    )$Vector(Vector(SparseUnivariatePolynomial Integer))
       for i in 1..nsols repeat
           resvi := new(m, 0)$Vector(SparseUnivariatePolynomial Integer)
           for j in 1..m repeat
                mm := ve(j)
                bmij := bm(i, j)
                s : SparseUnivariatePolynomial(Integer) := 0
                for l in 0..mm repeat
                    s := s + monomial(bmij(l), l _
                            )$SparseUnivariatePolynomial(Integer)
                resvi(j) := s
           resv(i) := resvi
       mress := new(m, nsols::NonNegativeInteger, 0)$MPI
       for i in 1..nsols repeat
            for l in 1..m repeat
                 mress(l, i) := resv(i)(l)
       return mress

   HP__solve__A(list, degs, kind, sigma, gen, check) ==
       -- print("modularCheckA"::OutputForm)
       true

   HP__solve__PA(list, degs, kind, qvar, sigma, gen, check) ==
       -- print("modularCheckPA"::OutputForm)
       true
@

\section{Generic interface to modular solver}

<<package MODHPS ModularHermitePadeSolver>>=

)abbrev package MODHPS ModularHermitePadeSolver
++ Description: This package provides generic interface to modular
++  Hermite-Pade solver.
ModularHermitePadeSolver(F: CommutativeRing, S: CommutativeRing)_
                      : Exports == Implementation where

    PA ==> U32Vector
    VPA ==> Vector PA
    GEN ==> (PA, Integer, Integer) -> VPA
    NNI ==> NonNegativeInteger
    CHKR ==> Union("good", "reject", "no__solution")
    SUP ==> SparseUnivariatePolynomial
    CHKT ==> (List SUP S) -> CHKR
    MPS ==> Matrix SparseUnivariatePolynomial S

    Exports ==>
        with
            HP__solve : (List F, List NNI, Symbol, Symbol, NNI, GEN, CHKT) _
                         -> Union(MPS, Boolean)
              ++ HP__solve(l, degs, kind, sigma, gen check) finds a sigma
              ++ basis with degree bounds given by degs.  It returns false
              ++ if there is no interpolating vector that is correct up to
              ++ (and including) z^(sigma-1) with sigma >= |degs+[1,1,...,1]|
              ++ or if check rejects all solutions.
              ++ It returns true if it can not handle given problem.
            gen__Monte__Carlo__check : (CHKT, List F, Symbol, Symbol, _
                                        NNI, GEN) -> CHKT
              ++ gen__Monte__Carlo__check(check, l, kind, qvar, sigma, gen)
              ++ returns Monte Carlo check for solutions to guessing problem.
              ++ If Monte Carlo check is unavailable returns check.

            LF__to__PA : (List(F), Integer, List Symbol, List Integer, _
                          Integer) -> Union(PA, "failed")
              ++ modular reduction
            VSUPS__to__VPA : (Vector(SUP S), List Symbol, List Integer, _
                          Integer) -> VPA
              ++ modular reduction

    Implementation ==> add

        import ModularHermitePade()

        check__sol__mod__diff : (Vector(SUP S), List(F), Integer, _
               GEN, Symbol, List Symbol _
               ) -> Union("good", "reject", "no__solution")

        if F is Fraction Integer and S is Integer then
            HP__solve(l, degs, kind, qvar, sigma, gen, check) ==
                HP__solve__I(l, degs, kind, sigma, gen, check)
            LF__to__PA(l, sigma, vars, points, p) == LFI__to__PA(l, sigma, p)
            VSUPS__to__VPA(v, vars, points, p) == VSUPI__to__VPA(v, p)
            gen__Monte__Carlo__check(check, l, kind, qvar, sigma, gen) ==
                kind ~= 'diffHP => check
                x +-> check__sol__mod__diff(vector x, l, sigma, gen, _
                                  'dummy, [])
        else if F is Fraction Polynomial Integer and _
                        S is Polynomial Integer then
            HP__solve(l, degs, kind, qvar, sigma, gen, check) ==
                HP__solve__P(l, degs, kind, qvar, sigma, gen, check)
            LF__to__PA(l, sigma, vars, points, p) ==
                LFPI__to__PA(l, sigma, vars, points, p)
            VSUPS__to__VPA(v, vars, points, p) ==
                VSUPPI__to__VPA(v, vars, points, p)
            gen__Monte__Carlo__check(check, l, kind, qvar, sigma, gen) ==
                not(kind = 'diffHP or kind = 'qdiffHP or kind = 'qmixed) =>
                    check
                vars :=  get__variables(l, kind, qvar)
                x +-> check__sol__mod__diff(vector x, l, sigma, gen, _
                           qvar, vars)
        else if F is AlgebraicNumber and S is AlgebraicNumber then
            HP__solve(l, degs, kind, qvar, sigma, gen, check) ==
                HP__solve__A(l, degs, kind, sigma, gen, check)
            gen__Monte__Carlo__check(check, l, kind, qvar, sigma, gen) ==
                check
        else if F is Fraction Polynomial AlgebraicNumber and _
                        S is Polynomial AlgebraicNumber then
            HP__solve(l, degs, kind, qvar, sigma, gen, check) ==
                HP__solve__PA(l, degs, kind, qvar, sigma, gen, check)
            gen__Monte__Carlo__check(check, l, kind, qvar, sigma, gen) ==
                check
        else
            p := characteristic()$F
            if p > 0 and p < 32000000 and F is PrimeField(p::PositiveInteger) then
                HP__solve(l, degs, kind, qvar, sigma, gen, check) ==
                    pp := HP__solve__M(l pretend List Integer,
                                        degs, kind, p, sigma,
                                        gen)
                    pp case Matrix SUP Integer =>
                        return (pp::Matrix(SUP Integer) pretend Matrix(SUP S))
                    return (pp::Boolean)
            else
                HP__solve(l, degs, kind, qvar, sigma, gen, check) == true
            gen__Monte__Carlo__check(check, l, kind, qvar, sigma, gen) ==
                check

        -- chhh

        check__sol__mod__diff(resv, list, sigma, gen, qvar, vars) _
               : Union("good", "reject", "no__solution") ==
            n0 := #list
            sigma0 := n0 + 2
            min__ord := sigma0
            delta := sigma0 - sigma
            -- print("check__sol__mod__diff, delta is"::OutputForm)
            -- print(delta::OutputForm)
            delta >= sigma =>
                error "delta too big"
            for ii in 1..20 repeat
                p : Integer := nextPrime(random(2000000)+2000000 _
                                        )$IntegerPrimesPackage(Integer)
                lpt : List Integer := []
                qval : Integer := 0
                for var in vars repeat
                    lpt := cons(random(p), lpt)
                    if var = qvar then qval := first(lpt)
                lpt := reverse!(lpt)
                gv0p := LF__to__PA(list, n0 + delta, vars, lpt, p)
                gv0p case "failed" => "iterate"
                gv0 := gv0p::PA
                nres := VSUPS__to__VPA(resv, vars, lpt, p)
                pa := check__sol1a(nres, gv0, gen, sigma0, qval, p)
                ord := sigma0
                for i in 0..(sigma0 - 1) repeat
                    if pa(i) ~= 0 then
                        ord := i
                        break
                ord < sigma => return "no__solution"
                ord < sigma0 =>
                    c0 := pa(ord)
                    for j in 0..(delta -1) repeat
                        gv0(n0 + j) := 1
                        pa := check__sol1a(nres, gv0, gen, sigma0, qval, p)
                        pa(ord) ~= c0 =>
                            -- print("decreasig delta"::OutputForm)
                            sigma0 := ord
                            delta := sigma0 - sigma
                            break
                        gv0(n0 + j) := 0
                    if ord < min__ord then min__ord := ord
                -- print(p::OutputForm)
            min__ord < sigma0 => return "reject"
            return "good"
@

\end{document}
