)abbrev package FSUPFACT FunctionSpaceUnivariatePolynomialFactor
++ Used internally by IR2F
++ Author: Manuel Bronstein
++ Date Created: 12 May 1988
++ Date Last Updated: 22 September 1993
++ Keywords: function, space, polynomial, factoring
FunctionSpaceUnivariatePolynomialFactor(R, F, UP):
 Exports == Implementation where
  R : Join(IntegralDomain, Comparable, RetractableTo Integer)
  F : FunctionSpace R
  UP : UnivariatePolynomialCategory F

  Q   ==> Fraction Integer
  K   ==> Kernel F
  AN  ==> AlgebraicNumber
  PQ  ==> SparseMultivariatePolynomial(Q, K)
  PR  ==> SparseMultivariatePolynomial(R, K)
  UPQ ==> SparseUnivariatePolynomial Q
  UPA ==> SparseUnivariatePolynomial AN
  FR  ==> Factored UP
  FRQ ==> Factored UPQ
  FRA ==> Factored UPA

  Exports ==> with
    ffactor : UP -> FR
      ++ ffactor(p) tries to factor a univariate polynomial p over F
    ffactor : (UP, List F) -> FR
      ++ ffactor(p, [a1, ..., an]) tries to factor a univariate polynomial
      ++ p over F in extension generated by coefficients of p and a1, ..., an.
    qfactor : UP -> Union(FRQ, "failed")
      ++ qfactor(p) tries to factor p over fractions of integers,
      ++ returning "failed" if it cannot
    UP2ifCan : UP  -> Union(overq : UPQ, overan : UPA, failed : Boolean)
      ++ UP2ifCan(x) should be local but conditional.
    ffactor1 : (UP, List F) -> FR
      ++ ffactor1(p, la) should be local but conditional.
    if F has RetractableTo AN then
      anfactor : UP -> Union(FRA, "failed")
        ++ anfactor(p) tries to factor p over algebraic numbers,
        ++ returning "failed" if it cannot

  Implementation ==> add
    import from AlgFactor(UPA)
    import from RationalFactorize(UPQ)

    P2QifCan : PR  -> Union(PQ, "failed")
    UPQ2UP   : (SparseUnivariatePolynomial PQ, F) -> UP
    PQ2F     : (PQ, F) -> F
    ffactor0 : UP -> FR

    dummy := kernel(new()$Symbol)$K

    -- FIXME: Complicated and incomplete, but for now has to do...

    if R is Complex(Integer) and F is Expression(R) and
       UP is SparseUnivariatePolynomial(F) then

        subst_mp_ni(p : PR, ni : F) : F ==
            map((c : R) : R +-> real(c)::R, p)::F +
              ni*map((c : R) : R +-> imag(c)::R, p)::F

        subst_f_ni(c : F, ni : F) : F ==
            subst_mp_ni(numer(c), ni)/subst_mp_ni(denom(c), ni)

        subst_up(p : UP, k : K, a : F) : UP ==
            map((c : F) : F +-> subst(c, [k], [a]), p)

        handle_imaginary(p : UP, al : List(F)) : FR ==
            p0 := monomial(1, 2)$UP + 1$UP
            nif := rootOf(p0)
            ni := retract(nif)@K
            nvr := (complex(0, 1)$Complex(Integer)) pretend R
            nv := nvr::F
            p1 := map((c : F) : F +-> subst_f_ni(c, nif), p)
            al1 := map((c : F) : F +-> subst_f_ni(c, nif), al)
            res1 := ffactor1(p1, al1)
            map((pp : UP) : UP +-> subst_up(pp, ni, nv), res1)

        ffactor(p, al) == handle_imaginary(p, al)

        ffactor(p) == handle_imaginary(p, [])

    else

        ffactor(p, al) == ffactor1(p, al)

        ffactor(p) == ffactor1(p, [])


    if F has RetractableTo AN then
      UPAN2F : UPA -> UP
      UPQ2AN : UPQ -> UPA

      UPAN2F p ==
        map(x +-> x::F, p)$UnivariatePolynomialCategoryFunctions2(AN, UPA, F, UP)

      UPQ2AN p ==
        map(x +-> x::AN, p)$UnivariatePolynomialCategoryFunctions2(Q, UPQ, AN, UPA)

      ffactor2(p : UP) : FR ==
        (pq := anfactor p) case FRA =>
                         map(UPAN2F, pq::FRA)$FactoredFunctions2(UPA, UP)
        ffactor0 p

      ffactor1(p : UP, la : List(F)) ==
          la1 : List(AN) := []
          empty?(la) => ffactor2(p)
          for a in la repeat
              a1u := retractIfCan(a)@Union(AN, "failed")
              a1u case "failed" => return ffactor2(p)
              la1 := cons(a1u::AN, la1)
          pa : UPA := 0
          p1 := p
          while p1 ~= 0 repeat
              a1u := retractIfCan(leadingCoefficient(p1))@Union(AN, "failed")
              a1u case "failed" => return ffactor0(p)
              pa := pa + monomial(a1u::AN, degree p1)$UPA
              p1 := reductum p1
          ff1 := factor(pa, la1)
          map(UPAN2F, ff1)$FactoredFunctions2(UPA, UP)

      anfactor p ==
        (q := UP2ifCan p) case overq =>
                     map(UPQ2AN, factor(q.overq))$FactoredFunctions2(UPQ, UPA)
        q case overan => factor(q.overan)
        "failed"

      UP2ifCan p ==
        ansq := 0$UPQ ; ansa := 0$UPA
        goforq? := true
        while p ~= 0 repeat
          if goforq? then
            rq := retractIfCan(leadingCoefficient p)@Union(Q, "failed")
            if rq case Q then
              ansq := ansq + monomial(rq::Q, degree p)
              ansa := ansa + monomial(rq::Q::AN, degree p)
            else
              goforq? := false
              ra := retractIfCan(leadingCoefficient p)@Union(AN, "failed")
              if ra case AN then ansa := ansa + monomial(ra::AN, degree p)
                            else return [true]
          else
            ra := retractIfCan(leadingCoefficient p)@Union(AN, "failed")
            if ra case AN then ansa := ansa + monomial(ra::AN, degree p)
                          else return [true]
          p := reductum p
        goforq? => [ansq]
        [ansa]

    else
      UPQ2F : UPQ -> UP

      UPQ2F p ==
        map(x +-> x::F, p)$UnivariatePolynomialCategoryFunctions2(Q, UPQ, F, UP)

      ffactor3 : UP -> FR

      ffactor1(p : UP, la : List(F)) == ffactor3(p)

      ffactor3(p) ==
        (pq := qfactor p) case FRQ =>
                         map(UPQ2F, pq::FRQ)$FactoredFunctions2(UPQ, UP)
        ffactor0 p

      UP2ifCan p ==
        ansq := 0$UPQ
        while p ~= 0 repeat
          rq := retractIfCan(leadingCoefficient p)@Union(Q, "failed")
          if rq case Q then ansq := ansq + monomial(rq::Q, degree p)
                       else return [true]
          p := reductum p
        [ansq]

    ffactor0 p ==
      smp := numer(ep := p(dummy::F))
      (q := P2QifCan smp) case "failed" => p::FR
      map(x +-> UPQ2UP(univariate(x, dummy), denom(ep)::F), factor(q::PQ
             )$MRationalFactorize(IndexedExponents K, K, Integer,
                  PQ))$FactoredFunctions2(PQ, UP)

    UPQ2UP(p, d) ==
      map(x +-> PQ2F(x, d), p)$UnivariatePolynomialCategoryFunctions2(PQ,
                                   SparseUnivariatePolynomial PQ, F, UP)

    PQ2F(p, d) ==
      map((x : K) : F +-> x::F, (x : Q) : F +-> x::F,
           p)$PolynomialCategoryLifting(IndexedExponents K, K, Q, PQ, F) / d

    qfactor p ==
      (q := UP2ifCan p) case overq => factor(q.overq)
      "failed"

    P2QifCan p ==
      and/[retractIfCan(c::F)@Union(Q, "failed") case Q
           for c in coefficients p] =>
            map(x +-> x::PQ, x +-> retract(x::F)@Q :: PQ,
              p)$PolynomialCategoryLifting(IndexedExponents K, K, R, PR, PQ)
      "failed"

--Copyright (c) 1991-2002, The Numerical ALgorithms Group Ltd.
--All rights reserved.
--
--Redistribution and use in source and binary forms, with or without
--modification, are permitted provided that the following conditions are
--met:
--
--    - Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--
--    - Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in
--      the documentation and/or other materials provided with the
--      distribution.
--
--    - Neither the name of The Numerical ALgorithms Group Ltd. nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
--THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
--IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
--TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
--PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
--OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
--EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
--PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
--PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
--LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
--NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
--SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

