 
; )package "BOOTTRAN"
 
(IN-PACKAGE "BOOTTRAN")
 
; bpFirstToken()==
;       $stok:=
;           if null $inputStream
;           then shoeTokConstruct("ERROR","NOMORE",shoeTokPosn $stok)
;           else CAR $inputStream
;       $ttok:=shoeTokPart $stok
;       true
 
(DEFUN |bpFirstToken| ()
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok| |$inputStream|))
    (RETURN
      (PROGN
        (SETQ |$stok|
              (COND
                ((NULL |$inputStream|)
                 (|shoeTokConstruct| 'ERROR 'NOMORE
                     (|shoeTokPosn| |$stok|)))
                ('T (CAR |$inputStream|))))
        (SETQ |$ttok| (|shoeTokPart| |$stok|))
        T))))
 
; bpFirstTok()==
;       $stok:=
;           if null $inputStream
;           then shoeTokConstruct("ERROR","NOMORE",shoeTokPosn $stok)
;           else CAR $inputStream
;       $ttok:=shoeTokPart $stok
;       $bpParenCount>0 and EQCAR($stok,"KEY") =>
;              EQ($ttok,"SETTAB")=>
;                 $bpCount:=$bpCount+1
;                 bpNext()
;              EQ($ttok,"BACKTAB")=>
;                 $bpCount:=$bpCount-1
;                 bpNext()
;              EQ($ttok,"BACKSET")=>
;                 bpNext()
;              true
;       true
 
(DEFUN |bpFirstTok| ()
  (PROG ()
    (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$ttok| |$stok|
                      |$inputStream|))
    (RETURN
      (PROGN
        (SETQ |$stok|
              (COND
                ((NULL |$inputStream|)
                 (|shoeTokConstruct| 'ERROR 'NOMORE
                     (|shoeTokPosn| |$stok|)))
                ('T (CAR |$inputStream|))))
        (SETQ |$ttok| (|shoeTokPart| |$stok|))
        (COND
          ((AND (< 0 |$bpParenCount|) (EQCAR |$stok| 'KEY))
           (COND
             ((EQ |$ttok| 'SETTAB)
              (PROGN (SETQ |$bpCount| (+ |$bpCount| 1)) (|bpNext|)))
             ((EQ |$ttok| 'BACKTAB)
              (PROGN (SETQ |$bpCount| (- |$bpCount| 1)) (|bpNext|)))
             ((EQ |$ttok| 'BACKSET) (|bpNext|))
             (#0='T T)))
          (#0# T))))))
 
; bpNext() ==
;      $inputStream := CDR($inputStream)
;      bpFirstTok()
 
(DEFUN |bpNext| ()
  (PROG ()
    (DECLARE (SPECIAL |$inputStream|))
    (RETURN
      (PROGN
        (SETQ |$inputStream| (CDR |$inputStream|))
        (|bpFirstTok|)))))
 
; bpNextToken() ==
;      $inputStream := CDR($inputStream)
;      bpFirstToken()
 
(DEFUN |bpNextToken| ()
  (PROG ()
    (DECLARE (SPECIAL |$inputStream|))
    (RETURN
      (PROGN
        (SETQ |$inputStream| (CDR |$inputStream|))
        (|bpFirstToken|)))))
 
; bpState()== [$inputStream,$stack,$bpParenCount,$bpCount]
 
(DEFUN |bpState| ()
  (PROG ()
    (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$stack|
                      |$inputStream|))
    (RETURN (LIST |$inputStream| |$stack| |$bpParenCount| |$bpCount|))))
 
; bpRestore(x)==
;       $inputStream:=CAR x
;       bpFirstToken()
;       $stack:=CADR x
;       $bpParenCount:=CADDR x
;       $bpCount:=CADDDR x
;       true
 
(DEFUN |bpRestore| (|x|)
  (PROG ()
    (DECLARE (SPECIAL |$bpCount| |$bpParenCount| |$stack|
                      |$inputStream|))
    (RETURN
      (PROGN
        (SETQ |$inputStream| (CAR |x|))
        (|bpFirstToken|)
        (SETQ |$stack| (CADR |x|))
        (SETQ |$bpParenCount| (CADDR |x|))
        (SETQ |$bpCount| (CADDDR |x|))
        T))))
 
; bpPush x==$stack:=CONS(x,$stack)
 
(DEFUN |bpPush| (|x|)
  (PROG ()
    (DECLARE (SPECIAL |$stack|))
    (RETURN (SETQ |$stack| (CONS |x| |$stack|)))))
 
; bpPushId()==
;    $stack:=CONS(bfReName $ttok,$stack)
 
(DEFUN |bpPushId| ()
  (PROG ()
    (DECLARE (SPECIAL |$stack| |$ttok|))
    (RETURN (SETQ |$stack| (CONS (|bfReName| |$ttok|) |$stack|)))))
 
; bpPop1()==
;        a:=CAR $stack
;        $stack:=CDR $stack
;        a
 
(DEFUN |bpPop1| ()
  (PROG (|a|)
    (DECLARE (SPECIAL |$stack|))
    (RETURN
      (PROGN
        (SETQ |a| (CAR |$stack|))
        (SETQ |$stack| (CDR |$stack|))
        |a|))))
 
; bpPop2()==
;        a:=CADR $stack
;        RPLACD($stack,CDDR $stack)
;        a
 
(DEFUN |bpPop2| ()
  (PROG (|a|)
    (DECLARE (SPECIAL |$stack|))
    (RETURN
      (PROGN
        (SETQ |a| (CADR |$stack|))
        (RPLACD |$stack| (CDDR |$stack|))
        |a|))))
 
; bpPop3()==
;        a:=CADDR $stack
;        RPLACD(CDR $stack,CDDDR $stack)
;        a
 
(DEFUN |bpPop3| ()
  (PROG (|a|)
    (DECLARE (SPECIAL |$stack|))
    (RETURN
      (PROGN
        (SETQ |a| (CADDR |$stack|))
        (RPLACD (CDR |$stack|) (CDDDR |$stack|))
        |a|))))
 
; bpIndentParenthesized f==
;     $bpCount:local:=0
;     a:=$stok
;     if bpEqPeek "OPAREN"
;     then
;       $bpParenCount:=$bpParenCount+1
;       bpNext()
;       if APPLY(f,nil) and bpFirstTok() and
;               (bpEqPeek "CPAREN" or bpParenTrap(a))
;       then
;             $bpParenCount:=$bpParenCount-1
;             bpNextToken()
;             $bpCount=0 => true
;             $inputStream:=append( bpAddTokens $bpCount,$inputStream)
;             bpFirstToken()
;             $bpParenCount=0 =>
;                      bpCancel()
;                      true
;             true
;       else if bpEqPeek "CPAREN"
;            then
;               bpPush  bfTuple []
;               $bpParenCount:=$bpParenCount-1
;               bpNextToken()
;               true
;            else bpParenTrap(a)
;     else false
 
(DEFUN |bpIndentParenthesized| (|f|)
  (PROG (|$bpCount| |a|)
    (DECLARE (SPECIAL |$inputStream| |$bpCount| |$bpParenCount|
                      |$stok|))
    (RETURN
      (PROGN
        (SETQ |$bpCount| 0)
        (SETQ |a| |$stok|)
        (COND
          ((|bpEqPeek| 'OPAREN)
           (SETQ |$bpParenCount| (+ |$bpParenCount| 1)) (|bpNext|)
           (COND
             ((AND (APPLY |f| NIL) (|bpFirstTok|)
                   (OR (|bpEqPeek| 'CPAREN) (|bpParenTrap| |a|)))
              (SETQ |$bpParenCount| (- |$bpParenCount| 1))
              (|bpNextToken|)
              (COND
                ((EQL |$bpCount| 0) T)
                (#0='T
                 (PROGN
                   (SETQ |$inputStream|
                         (APPEND (|bpAddTokens| |$bpCount|)
                                 |$inputStream|))
                   (|bpFirstToken|)
                   (COND
                     ((EQL |$bpParenCount| 0) (PROGN (|bpCancel|) T))
                     (#0# T))))))
             ((|bpEqPeek| 'CPAREN) (|bpPush| (|bfTuple| NIL))
              (SETQ |$bpParenCount| (- |$bpParenCount| 1))
              (|bpNextToken|) T)
             (#1='T (|bpParenTrap| |a|))))
          (#1# NIL))))))
 
; bpParenthesized f==
;     a:=$stok
;     if bpEqKey "OPAREN"
;     then
;       if APPLY(f,nil) and (bpEqKey "CPAREN" or bpParenTrap(a))
;       then true
;       else if bpEqKey "CPAREN"
;            then
;               bpPush  bfTuple []
;               true
;            else bpParenTrap(a)
;     else false
 
(DEFUN |bpParenthesized| (|f|)
  (PROG (|a|)
    (DECLARE (SPECIAL |$stok|))
    (RETURN
      (PROGN
        (SETQ |a| |$stok|)
        (COND
          ((|bpEqKey| 'OPAREN)
           (COND
             ((AND (APPLY |f| NIL)
                   (OR (|bpEqKey| 'CPAREN) (|bpParenTrap| |a|)))
              T)
             ((|bpEqKey| 'CPAREN) (|bpPush| (|bfTuple| NIL)) T)
             (#0='T (|bpParenTrap| |a|))))
          (#0# NIL))))))
 
; bpBracket f==
;     a:=$stok
;     if bpEqKey "OBRACK"
;     then
;       if APPLY(f,nil) and (bpEqKey "CBRACK" or bpBrackTrap(a))
;       then bpPush bfBracket bpPop1 ()
;       else if bpEqKey "CBRACK"
;            then bpPush  []
;            else bpBrackTrap(a)
;     else false
 
(DEFUN |bpBracket| (|f|)
  (PROG (|a|)
    (DECLARE (SPECIAL |$stok|))
    (RETURN
      (PROGN
        (SETQ |a| |$stok|)
        (COND
          ((|bpEqKey| 'OBRACK)
           (COND
             ((AND (APPLY |f| NIL)
                   (OR (|bpEqKey| 'CBRACK) (|bpBrackTrap| |a|)))
              (|bpPush| (|bfBracket| (|bpPop1|))))
             ((|bpEqKey| 'CBRACK) (|bpPush| NIL))
             (#0='T (|bpBrackTrap| |a|))))
          (#0# NIL))))))
 
; bpPileBracketed f==
;               if bpEqKey "SETTAB"
;               then if bpEqKey "BACKTAB"
;                    then true
;                    else if APPLY(f,nil) and
;                             (bpEqKey "BACKTAB" or bpPileTrap())
;                         then bpPush bfPile bpPop1()
;                         else false
;               else false
 
(DEFUN |bpPileBracketed| (|f|)
  (PROG ()
    (RETURN
      (COND
        ((|bpEqKey| 'SETTAB)
         (COND
           ((|bpEqKey| 'BACKTAB) T)
           ((AND (APPLY |f| NIL)
                 (OR (|bpEqKey| 'BACKTAB) (|bpPileTrap|)))
            (|bpPush| (|bfPile| (|bpPop1|))))
           (#0='T NIL)))
        (#0# NIL)))))
 
; bpListof(f,str1,g)==
;     if APPLY(f,nil)
;     then
;         if bpEqKey str1 and (APPLY(f,nil) or bpTrap())
;         then
;           a:=$stack
;           $stack:=nil
;           while bpEqKey str1 and (APPLY(f,nil) or bpTrap()) repeat 0
;           $stack:=cons(NREVERSE $stack,a)
;           bpPush FUNCALL(g, [bpPop3(),bpPop2(),:bpPop1()])
;         else
;           true
;     else false
 
(DEFUN |bpListof| (|f| |str1| |g|)
  (PROG (|a|)
    (DECLARE (SPECIAL |$stack|))
    (RETURN
      (COND
        ((APPLY |f| NIL)
         (COND
           ((AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|)))
            (SETQ |a| |$stack|) (SETQ |$stack| NIL)
            ((LAMBDA ()
               (LOOP
                 (COND
                   ((NOT (AND (|bpEqKey| |str1|)
                              (OR (APPLY |f| NIL) (|bpTrap|))))
                    (RETURN NIL))
                   ('T 0)))))
            (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
            (|bpPush|
                (FUNCALL |g|
                         (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|))))))
           (#0='T T)))
        (#0# NIL)))))
 
; bpListofFun(f,h,g)==
;     if APPLY(f,nil)
;     then
;         if APPLY(h,nil) and (APPLY(f,nil) or bpTrap())
;         then
;           a:=$stack
;           $stack:=nil
;           while APPLY(h,nil) and (APPLY(f,nil) or bpTrap()) repeat 0
;           $stack:=cons(NREVERSE $stack,a)
;           bpPush FUNCALL(g, bfListOf [bpPop3(),bpPop2(),:bpPop1()])
;         else
;           true
;     else false
 
(DEFUN |bpListofFun| (|f| |h| |g|)
  (PROG (|a|)
    (DECLARE (SPECIAL |$stack|))
    (RETURN
      (COND
        ((APPLY |f| NIL)
         (COND
           ((AND (APPLY |h| NIL) (OR (APPLY |f| NIL) (|bpTrap|)))
            (SETQ |a| |$stack|) (SETQ |$stack| NIL)
            ((LAMBDA ()
               (LOOP
                 (COND
                   ((NOT (AND (APPLY |h| NIL)
                              (OR (APPLY |f| NIL) (|bpTrap|))))
                    (RETURN NIL))
                   ('T 0)))))
            (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
            (|bpPush|
                (FUNCALL |g|
                         (|bfListOf|
                             (CONS (|bpPop3|)
                                   (CONS (|bpPop2|) (|bpPop1|)))))))
           (#0='T T)))
        (#0# NIL)))))
 
; bpList(f,str1,g)==
;     if APPLY(f,nil)
;     then
;         if bpEqKey str1 and (APPLY(f,nil) or bpTrap())
;         then
;           a:=$stack
;           $stack:=nil
;           while bpEqKey str1 and (APPLY(f,nil) or bpTrap()) repeat 0
;           $stack:=cons(NREVERSE $stack,a)
;           bpPush FUNCALL(g,  [bpPop3(),bpPop2(),:bpPop1()])
;         else
;           bpPush FUNCALL(g, [bpPop1()])
;     else bpPush FUNCALL(g, [])
 
(DEFUN |bpList| (|f| |str1| |g|)
  (PROG (|a|)
    (DECLARE (SPECIAL |$stack|))
    (RETURN
      (COND
        ((APPLY |f| NIL)
         (COND
           ((AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|)))
            (SETQ |a| |$stack|) (SETQ |$stack| NIL)
            ((LAMBDA ()
               (LOOP
                 (COND
                   ((NOT (AND (|bpEqKey| |str1|)
                              (OR (APPLY |f| NIL) (|bpTrap|))))
                    (RETURN NIL))
                   ('T 0)))))
            (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
            (|bpPush|
                (FUNCALL |g|
                         (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|))))))
           (#0='T (|bpPush| (FUNCALL |g| (LIST (|bpPop1|)))))))
        (#0# (|bpPush| (FUNCALL |g| NIL)))))))
 
; bpOneOrMore f==
;        APPLY(f,nil)=>
;          a:=$stack
;          $stack:=nil
;          while APPLY(f,nil) repeat 0
;          $stack:=cons(NREVERSE $stack,a)
;          bpPush cons(bpPop2(),bpPop1())
;        false
 
(DEFUN |bpOneOrMore| (|f|)
  (PROG (|a|)
    (DECLARE (SPECIAL |$stack|))
    (RETURN
      (COND
        ((APPLY |f| NIL)
         (PROGN
           (SETQ |a| |$stack|)
           (SETQ |$stack| NIL)
           ((LAMBDA ()
              (LOOP
                (COND ((NOT (APPLY |f| NIL)) (RETURN NIL)) ('T 0)))))
           (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
           (|bpPush| (CONS (|bpPop2|) (|bpPop1|)))))
        ('T NIL)))))
 
; bpAnyNo s==
;      while APPLY(s,nil) repeat 0
;      true
 
(DEFUN |bpAnyNo| (|s|)
  (PROG ()
    (RETURN
      (PROGN
        ((LAMBDA ()
           (LOOP (COND ((NOT (APPLY |s| NIL)) (RETURN NIL)) ('T 0)))))
        T))))
 
; bpAndOr(keyword,p,f)==
;    bpEqKey keyword and (APPLY(p,nil) or bpTrap())
;           and bpPush FUNCALL(f, bpPop1())
 
(DEFUN |bpAndOr| (|keyword| |p| |f|)
  (PROG ()
    (RETURN
      (AND (|bpEqKey| |keyword|) (OR (APPLY |p| NIL) (|bpTrap|))
           (|bpPush| (FUNCALL |f| (|bpPop1|)))))))
 
; bpConditional f==
;   if  bpEqKey "IF" and (bpWhere() or bpTrap()) and
;                    (bpEqKey "BACKSET" or true)
;   then
;            if bpEqKey "SETTAB"
;            then if bpEqKey "THEN"
;                 then  (APPLY(f,nil) or bpTrap()) and bpElse(f) and bpEqKey "BACKTAB"
;                 else  bpMissing "THEN"
;            else if bpEqKey "THEN"
;                 then (APPLY(f,nil) or bpTrap()) and bpElse(f)
;                 else bpMissing "then"
;   else false
 
(DEFUN |bpConditional| (|f|)
  (PROG ()
    (RETURN
      (COND
        ((AND (|bpEqKey| 'IF) (OR (|bpWhere|) (|bpTrap|))
              (OR (|bpEqKey| 'BACKSET) T))
         (COND
           ((|bpEqKey| 'SETTAB)
            (COND
              ((|bpEqKey| 'THEN)
               (AND (OR (APPLY |f| NIL) (|bpTrap|)) (|bpElse| |f|)
                    (|bpEqKey| 'BACKTAB)))
              (#0='T (|bpMissing| 'THEN))))
           ((|bpEqKey| 'THEN)
            (AND (OR (APPLY |f| NIL) (|bpTrap|)) (|bpElse| |f|)))
           (#0# (|bpMissing| '|then|))))
        (#0# NIL)))))
 
; bpElse(f)==
;            a:=bpState()
;            if bpBacksetElse()
;            then  (APPLY(f,nil) or bpTrap()) and
;                  bpPush bfIf(bpPop3(),bpPop2(),bpPop1())
;            else
;               bpRestore a
;               bpPush bfIfThenOnly(bpPop2(),bpPop1())
 
(DEFUN |bpElse| (|f|)
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|bpState|))
        (COND
          ((|bpBacksetElse|)
           (AND (OR (APPLY |f| NIL) (|bpTrap|))
                (|bpPush| (|bfIf| (|bpPop3|) (|bpPop2|) (|bpPop1|)))))
          ('T (|bpRestore| |a|)
           (|bpPush| (|bfIfThenOnly| (|bpPop2|) (|bpPop1|)))))))))
 
; bpBacksetElse()==
;     if bpEqKey "BACKSET"
;     then bpEqKey "ELSE"
;     else bpEqKey "ELSE"
 
(DEFUN |bpBacksetElse| ()
  (PROG ()
    (RETURN
      (COND
        ((|bpEqKey| 'BACKSET) (|bpEqKey| 'ELSE))
        ('T (|bpEqKey| 'ELSE))))))
 
; bpEqPeek s ==  EQCAR($stok,"KEY") and EQ(s,$ttok)
 
(DEFUN |bpEqPeek| (|s|)
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN (AND (EQCAR |$stok| 'KEY) (EQ |s| |$ttok|)))))
 
; bpEqKey s ==   EQCAR($stok,"KEY") and EQ(s,$ttok) and bpNext()
 
(DEFUN |bpEqKey| (|s|)
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN (AND (EQCAR |$stok| 'KEY) (EQ |s| |$ttok|) (|bpNext|)))))
 
; bpEqKeyNextTok s ==   EQCAR($stok,"KEY") and EQ(s,$ttok) and
;                   bpNextToken()
 
(DEFUN |bpEqKeyNextTok| (|s|)
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (AND (EQCAR |$stok| 'KEY) (EQ |s| |$ttok|) (|bpNextToken|)))))
 
; bpPileTrap()   == bpMissing  "BACKTAB"
 
(DEFUN |bpPileTrap| () (PROG () (RETURN (|bpMissing| 'BACKTAB))))
 
; bpBrackTrap(x) == bpMissingMate("]",x)
 
(DEFUN |bpBrackTrap| (|x|)
  (PROG () (RETURN (|bpMissingMate| '] |x|))))
 
; bpParenTrap(x) == bpMissingMate(")",x)
 
(DEFUN |bpParenTrap| (|x|)
  (PROG () (RETURN (|bpMissingMate| '|)| |x|))))
 
; bpMissingMate(close,open)==
;    bpSpecificErrorAtToken(open, '"possibly missing mate")
;    bpMissing close
 
(DEFUN |bpMissingMate| (|close| |open|)
  (PROG ()
    (RETURN
      (PROGN
        (|bpSpecificErrorAtToken| |open| "possibly missing mate")
        (|bpMissing| |close|)))))
 
; bpMissing s==
;    bpSpecificErrorHere(CONCAT(PNAME s,'" possibly missing"))
;    THROW("TRAPPOINT","TRAPPED")
 
(DEFUN |bpMissing| (|s|)
  (PROG ()
    (RETURN
      (PROGN
        (|bpSpecificErrorHere|
            (CONCAT (PNAME |s|) " possibly missing"))
        (THROW 'TRAPPOINT 'TRAPPED)))))
 
; bpCompMissing s == bpEqKey s or bpMissing s
 
(DEFUN |bpCompMissing| (|s|)
  (PROG () (RETURN (OR (|bpEqKey| |s|) (|bpMissing| |s|)))))
 
; bpTrap()==
;    bpGeneralErrorHere()
;    THROW("TRAPPOINT","TRAPPED")
 
(DEFUN |bpTrap| ()
  (PROG ()
    (RETURN
      (PROGN (|bpGeneralErrorHere|) (THROW 'TRAPPOINT 'TRAPPED)))))
 
; bpRecoverTrap()==
;   bpFirstToken()
;   pos1 := shoeTokPosn $stok
;   bpMoveTo 0
;   pos2 := shoeTokPosn $stok
;   bpIgnoredFromTo(pos1, pos2)
;   bpPush  [['"pile syntax error"]]
 
(DEFUN |bpRecoverTrap| ()
  (PROG (|pos2| |pos1|)
    (DECLARE (SPECIAL |$stok|))
    (RETURN
      (PROGN
        (|bpFirstToken|)
        (SETQ |pos1| (|shoeTokPosn| |$stok|))
        (|bpMoveTo| 0)
        (SETQ |pos2| (|shoeTokPosn| |$stok|))
        (|bpIgnoredFromTo| |pos1| |pos2|)
        (|bpPush| (LIST (LIST "pile syntax error")))))))
 
; bpListAndRecover(f)==
;    a:=$stack
;    b:=nil
;    $stack:=nil
;    done:=false
;    c:=$inputStream
;    while not done repeat
; --   $trapped:local:=false
;      found:=CATCH("TRAPPOINT",APPLY(f,nil))
;      if found="TRAPPED"
;      then
;         $inputStream:=c
;         bpRecoverTrap()
;      else if not found
;           then
;             $inputStream:=c
;             bpGeneralErrorHere()
;             bpRecoverTrap()
;      if bpEqKey "BACKSET"
;      then
;         c:=$inputStream
;      else if bpEqPeek "BACKTAB"  or null $inputStream
;           then
;              done:=true
;           else
;             $inputStream:=c
;             bpGeneralErrorHere()
;             bpRecoverTrap()
;             if bpEqPeek "BACKTAB"  or null $inputStream
;             then done:=true
;             else
;                 bpNext()
;                 c:=$inputStream
;      b:=cons(bpPop1(),b)
;    $stack:=a
;    bpPush NREVERSE b
 
(DEFUN |bpListAndRecover| (|f|)
  (PROG (|found| |c| |done| |b| |a|)
    (DECLARE (SPECIAL |$inputStream| |$stack|))
    (RETURN
      (PROGN
        (SETQ |a| |$stack|)
        (SETQ |b| NIL)
        (SETQ |$stack| NIL)
        (SETQ |done| NIL)
        (SETQ |c| |$inputStream|)
        ((LAMBDA ()
           (LOOP
             (COND
               (|done| (RETURN NIL))
               ('T
                (PROGN
                  (SETQ |found| (CATCH 'TRAPPOINT (APPLY |f| NIL)))
                  (COND
                    ((EQ |found| 'TRAPPED) (SETQ |$inputStream| |c|)
                     (|bpRecoverTrap|))
                    ((NULL |found|) (SETQ |$inputStream| |c|)
                     (|bpGeneralErrorHere|) (|bpRecoverTrap|)))
                  (COND
                    ((|bpEqKey| 'BACKSET) (SETQ |c| |$inputStream|))
                    ((OR (|bpEqPeek| 'BACKTAB) (NULL |$inputStream|))
                     (SETQ |done| T))
                    (#0='T (SETQ |$inputStream| |c|)
                     (|bpGeneralErrorHere|) (|bpRecoverTrap|)
                     (COND
                       ((OR (|bpEqPeek| 'BACKTAB)
                            (NULL |$inputStream|))
                        (SETQ |done| T))
                       (#0# (|bpNext|) (SETQ |c| |$inputStream|)))))
                  (SETQ |b| (CONS (|bpPop1|) |b|))))))))
        (SETQ |$stack| |a|)
        (|bpPush| (NREVERSE |b|))))))
 
; bpMoveTo n==
;      null $inputStream  => true
;      bpEqPeek "BACKTAB" =>
;                 n=0  => true
;                 bpNextToken()
;                 $bpCount:=$bpCount-1
;                 bpMoveTo(n-1)
;      bpEqPeek "BACKSET" =>
;                 n=0  => true
;                 bpNextToken()
;                 bpMoveTo n
;      bpEqPeek "SETTAB"  =>
;                 bpNextToken()
;                 bpMoveTo(n+1)
;      bpEqPeek "OPAREN"  =>
;                 bpNextToken()
;                 $bpParenCount:=$bpParenCount+1
;                 bpMoveTo n
;      bpEqPeek "CPAREN"  =>
;                 bpNextToken()
;                 $bpParenCount:=$bpParenCount-1
;                 bpMoveTo n
;      bpNextToken()
;      bpMoveTo n
 
(DEFUN |bpMoveTo| (|n|)
  (PROG ()
    (DECLARE (SPECIAL |$bpParenCount| |$bpCount| |$inputStream|))
    (RETURN
      (COND
        ((NULL |$inputStream|) T)
        ((|bpEqPeek| 'BACKTAB)
         (COND
           ((EQL |n| 0) T)
           (#0='T
            (PROGN
              (|bpNextToken|)
              (SETQ |$bpCount| (- |$bpCount| 1))
              (|bpMoveTo| (- |n| 1))))))
        ((|bpEqPeek| 'BACKSET)
         (COND
           ((EQL |n| 0) T)
           (#0# (PROGN (|bpNextToken|) (|bpMoveTo| |n|)))))
        ((|bpEqPeek| 'SETTAB)
         (PROGN (|bpNextToken|) (|bpMoveTo| (+ |n| 1))))
        ((|bpEqPeek| 'OPAREN)
         (PROGN
           (|bpNextToken|)
           (SETQ |$bpParenCount| (+ |$bpParenCount| 1))
           (|bpMoveTo| |n|)))
        ((|bpEqPeek| 'CPAREN)
         (PROGN
           (|bpNextToken|)
           (SETQ |$bpParenCount| (- |$bpParenCount| 1))
           (|bpMoveTo| |n|)))
        (#0# (PROGN (|bpNextToken|) (|bpMoveTo| |n|)))))))
 
; bpSpecificErrorAtToken(tok, key) ==
;      a:=shoeTokPosn tok
;      SoftShoeError(a,key)
 
(DEFUN |bpSpecificErrorAtToken| (|tok| |key|)
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|shoeTokPosn| |tok|))
        (|SoftShoeError| |a| |key|)))))
 
; bpGeneralErrorHere() ==  bpSpecificErrorHere('"syntax error")
 
(DEFUN |bpGeneralErrorHere| ()
  (PROG () (RETURN (|bpSpecificErrorHere| "syntax error"))))
 
; bpSpecificErrorHere(key) ==  bpSpecificErrorAtToken($stok, key)
 
(DEFUN |bpSpecificErrorHere| (|key|)
  (PROG ()
    (DECLARE (SPECIAL |$stok|))
    (RETURN (|bpSpecificErrorAtToken| |$stok| |key|))))
 
; bpName() ==
;         if EQCAR( $stok,"ID")
;         then
;            bpPushId()
;            bpNext()
;         else false
 
(DEFUN |bpName| ()
  (PROG ()
    (DECLARE (SPECIAL |$stok|))
    (RETURN
      (COND ((EQCAR |$stok| 'ID) (|bpPushId|) (|bpNext|)) ('T NIL)))))
 
; bpConstTok() ==
;      MEMQ(shoeTokType $stok, '(INTEGER FLOAT)) =>
;           bpPush $ttok
;           bpNext()
;      EQCAR($stok,"LISP")=> bpPush bfReadLisp $ttok and bpNext()
;      EQCAR($stok,"LISPEXP")=> bpPush $ttok and bpNext()
;      EQCAR($stok,"LINE")=> bpPush ["+LINE", $ttok] and bpNext()
;      bpEqPeek "QUOTE" =>
;           bpNext()
;           (bpSexp() or bpTrap()) and
;                bpPush bfSymbol bpPop1()
;      bpString()
 
(DEFUN |bpConstTok| ()
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (COND
        ((MEMQ (|shoeTokType| |$stok|) '(INTEGER FLOAT))
         (PROGN (|bpPush| |$ttok|) (|bpNext|)))
        ((EQCAR |$stok| 'LISP)
         (AND (|bpPush| (|bfReadLisp| |$ttok|)) (|bpNext|)))
        ((EQCAR |$stok| 'LISPEXP) (AND (|bpPush| |$ttok|) (|bpNext|)))
        ((EQCAR |$stok| 'LINE)
         (AND (|bpPush| (LIST '+LINE |$ttok|)) (|bpNext|)))
        ((|bpEqPeek| 'QUOTE)
         (PROGN
           (|bpNext|)
           (AND (OR (|bpSexp|) (|bpTrap|))
                (|bpPush| (|bfSymbol| (|bpPop1|))))))
        ('T (|bpString|))))))
 
; bpCancel()==
;     a:=bpState()
;     if bpEqKeyNextTok  "SETTAB"
;     then if bpCancel()
;          then  if bpEqKeyNextTok  "BACKTAB"
;                then true
;                else
;                    bpRestore a
;                    false
;          else
;            if bpEqKeyNextTok "BACKTAB"
;            then true
;            else
;               bpRestore a
;               false
;     else false
 
(DEFUN |bpCancel| ()
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|bpState|))
        (COND
          ((|bpEqKeyNextTok| 'SETTAB)
           (COND
             ((|bpCancel|)
              (COND
                ((|bpEqKeyNextTok| 'BACKTAB) T)
                (#0='T (|bpRestore| |a|) NIL)))
             ((|bpEqKeyNextTok| 'BACKTAB) T)
             (#0# (|bpRestore| |a|) NIL)))
          (#0# NIL))))))
 
; bpAddTokens n==
;          n=0 => nil
;          n>0=> cons(shoeTokConstruct("KEY","SETTAB",shoeTokPosn $stok),bpAddTokens(n-1))
;          cons(shoeTokConstruct("KEY","BACKTAB",shoeTokPosn $stok),bpAddTokens(n+1))
 
(DEFUN |bpAddTokens| (|n|)
  (PROG ()
    (DECLARE (SPECIAL |$stok|))
    (RETURN
      (COND
        ((EQL |n| 0) NIL)
        ((< 0 |n|)
         (CONS (|shoeTokConstruct| 'KEY 'SETTAB
                   (|shoeTokPosn| |$stok|))
               (|bpAddTokens| (- |n| 1))))
        ('T
         (CONS (|shoeTokConstruct| 'KEY 'BACKTAB
                   (|shoeTokPosn| |$stok|))
               (|bpAddTokens| (+ |n| 1))))))))
 
; bpExceptions()==
;      bpEqPeek "DOT" or bpEqPeek "QUOTE" or
;           bpEqPeek "OPAREN" or bpEqPeek "CPAREN" or
;              bpEqPeek "SETTAB" or bpEqPeek "BACKTAB"
;                 or bpEqPeek "BACKSET"
 
(DEFUN |bpExceptions| ()
  (PROG ()
    (RETURN
      (OR (|bpEqPeek| 'DOT) (|bpEqPeek| 'QUOTE) (|bpEqPeek| 'OPAREN)
          (|bpEqPeek| 'CPAREN) (|bpEqPeek| 'SETTAB)
          (|bpEqPeek| 'BACKTAB) (|bpEqPeek| 'BACKSET)))))
 
; bpSexpKey()==
;       EQCAR( $stok,"KEY") and not bpExceptions()=>
;                a:=GET($ttok,"SHOEINF")
;                null a=>  bpPush $ttok and bpNext()
;                bpPush a and bpNext()
;       false
 
(DEFUN |bpSexpKey| ()
  (PROG (|a|)
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (COND
        ((AND (EQCAR |$stok| 'KEY) (NULL (|bpExceptions|)))
         (PROGN
           (SETQ |a| (GET |$ttok| 'SHOEINF))
           (COND
             ((NULL |a|) (AND (|bpPush| |$ttok|) (|bpNext|)))
             (#0='T (AND (|bpPush| |a|) (|bpNext|))))))
        (#0# NIL)))))
 
; bpAnyId()==
;   bpEqKey "MINUS"  and (EQCAR($stok,"INTEGER") or bpTrap()) and
;           bpPush MINUS $ttok and bpNext() or
;              bpSexpKey() or
;                    MEMQ(shoeTokType $stok, '(ID INTEGER STRING FLOAT))
;                       and  bpPush $ttok and  bpNext()
 
(DEFUN |bpAnyId| ()
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (OR (AND (|bpEqKey| 'MINUS)
               (OR (EQCAR |$stok| 'INTEGER) (|bpTrap|))
               (|bpPush| (- |$ttok|)) (|bpNext|))
          (|bpSexpKey|)
          (AND (MEMQ (|shoeTokType| |$stok|)
                     '(ID INTEGER STRING FLOAT))
               (|bpPush| |$ttok|) (|bpNext|))))))
 
; bpSexp()==
;     bpAnyId() or
;         bpEqKey "QUOTE"  and  (bpSexp() or bpTrap())
;            and bpPush bfSymbol bpPop1() or
;                bpIndentParenthesized function bpSexp1
 
(DEFUN |bpSexp| ()
  (PROG ()
    (RETURN
      (OR (|bpAnyId|)
          (AND (|bpEqKey| 'QUOTE) (OR (|bpSexp|) (|bpTrap|))
               (|bpPush| (|bfSymbol| (|bpPop1|))))
          (|bpIndentParenthesized| #'|bpSexp1|)))))
 
; bpSexp1()== bpFirstTok() and
;     bpSexp() and
;      (bpEqKey "DOT" and bpSexp() and bpPush CONS (bpPop2(),bpPop1())or
;            bpSexp1() and bpPush CONS (bpPop2(),bpPop1())) or
;                bpPush nil
 
(DEFUN |bpSexp1| ()
  (PROG ()
    (RETURN
      (OR (AND (|bpFirstTok|) (|bpSexp|)
               (OR (AND (|bpEqKey| 'DOT) (|bpSexp|)
                        (|bpPush| (CONS (|bpPop2|) (|bpPop1|))))
                   (AND (|bpSexp1|)
                        (|bpPush| (CONS (|bpPop2|) (|bpPop1|))))))
          (|bpPush| NIL)))))
 
; bpPrimary1() ==
;    bpName() or
;     bpDot() or
;       bpConstTok() or
;        bpConstruct() or
;         bpCase() or
;          bpStruct() or
;           bpPDefinition() or
;            bpBPileDefinition()
 
(DEFUN |bpPrimary1| ()
  (PROG ()
    (RETURN
      (OR (|bpName|) (|bpDot|) (|bpConstTok|) (|bpConstruct|)
          (|bpCase|) (|bpStruct|) (|bpPDefinition|)
          (|bpBPileDefinition|)))))
 
; bpPrimary()==  bpFirstTok() and (bpPrimary1() or bpPrefixOperator())
 
(DEFUN |bpPrimary| ()
  (PROG ()
    (RETURN
      (AND (|bpFirstTok|) (OR (|bpPrimary1|) (|bpPrefixOperator|))))))
 
; bpDot()== bpEqKey "DOT" and bpPush bfDot ()
 
(DEFUN |bpDot| ()
  (PROG () (RETURN (AND (|bpEqKey| 'DOT) (|bpPush| (|bfDot|))))))
 
; bpPrefixOperator()==
;    EQCAR( $stok,"KEY") and
;      GET($ttok,"SHOEPRE") and bpPushId() and  bpNext()
 
(DEFUN |bpPrefixOperator| ()
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (AND (EQCAR |$stok| 'KEY) (GET |$ttok| 'SHOEPRE) (|bpPushId|)
           (|bpNext|)))))
 
; bpInfixOperator()==
;   EQCAR( $stok,"KEY") and
;     GET($ttok,"SHOEINF") and bpPushId() and  bpNext()
 
(DEFUN |bpInfixOperator| ()
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (AND (EQCAR |$stok| 'KEY) (GET |$ttok| 'SHOEINF) (|bpPushId|)
           (|bpNext|)))))
 
; bpSelector()==
;             bpEqKey "DOT" and (bpPrimary()
;                and bpPush(bfElt(bpPop2(),bpPop1()))
;                   or bpPush bfSuffixDot bpPop1() )
 
(DEFUN |bpSelector| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'DOT)
           (OR (AND (|bpPrimary|)
                    (|bpPush| (|bfElt| (|bpPop2|) (|bpPop1|))))
               (|bpPush| (|bfSuffixDot| (|bpPop1|))))))))
 
; bpOperator()==   bpPrimary() and bpAnyNo function bpSelector
 
(DEFUN |bpOperator| ()
  (PROG () (RETURN (AND (|bpPrimary|) (|bpAnyNo| #'|bpSelector|)))))
 
; bpApplication()==
;    bpPrimary() and bpAnyNo function bpSelector and
;       (bpApplication() and
;             bpPush(bfApplication(bpPop2(),bpPop1())) or true)
 
(DEFUN |bpApplication| ()
  (PROG ()
    (RETURN
      (AND (|bpPrimary|) (|bpAnyNo| #'|bpSelector|)
           (OR (AND (|bpApplication|)
                    (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|))))
               T)))))
 
; bpTagged()==
;       bpApplication() and
;          (bpEqKey "COLON" and (bpApplication() or bpTrap()) and
;            bpPush bfTagged(bpPop2(),bpPop1()) or true)
 
(DEFUN |bpTagged| ()
  (PROG ()
    (RETURN
      (AND (|bpApplication|)
           (OR (AND (|bpEqKey| 'COLON)
                    (OR (|bpApplication|) (|bpTrap|))
                    (|bpPush| (|bfTagged| (|bpPop2|) (|bpPop1|))))
               T)))))
 
; bpExpt()== bpRightAssoc('(POWER),function bpTagged)
 
(DEFUN |bpExpt| ()
  (PROG () (RETURN (|bpRightAssoc| '(POWER) #'|bpTagged|))))
 
; bpInfKey s==
;  EQCAR( $stok,"KEY") and
;    MEMBER($ttok,s) and bpPushId() and bpNext()
 
(DEFUN |bpInfKey| (|s|)
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (AND (EQCAR |$stok| 'KEY) (MEMBER |$ttok| |s|) (|bpPushId|)
           (|bpNext|)))))
 
; bpInfGeneric s== bpInfKey s and  (bpEqKey "BACKSET" or true)
 
(DEFUN |bpInfGeneric| (|s|)
  (PROG ()
    (RETURN (AND (|bpInfKey| |s|) (OR (|bpEqKey| 'BACKSET) T)))))
 
; bpRightAssoc(o,p)==
;     a:=bpState()
;     if APPLY(p,nil)
;     then
;        while  bpInfGeneric o and (bpRightAssoc(o,p) or bpTrap()) repeat
;              bpPush bfInfApplication(bpPop2(),bpPop2(),bpPop1())
;        true
;     else
;        bpRestore a
;        false
 
(DEFUN |bpRightAssoc| (|o| |p|)
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|bpState|))
        (COND
          ((APPLY |p| NIL)
           ((LAMBDA ()
              (LOOP
                (COND
                  ((NOT (AND (|bpInfGeneric| |o|)
                             (OR (|bpRightAssoc| |o| |p|) (|bpTrap|))))
                   (RETURN NIL))
                  ('T
                   (|bpPush|
                       (|bfInfApplication| (|bpPop2|) (|bpPop2|)
                           (|bpPop1|))))))))
           T)
          ('T (|bpRestore| |a|) NIL))))))
 
; bpLeftAssoc(operations,parser)==
;     if APPLY(parser,nil)
;     then
;        while bpInfGeneric(operations) and
;          (APPLY(parser,nil) or bpTrap())
;            repeat
;              bpPush bfInfApplication(bpPop2(),bpPop2(),bpPop1())
;        true
;     else false
 
(DEFUN |bpLeftAssoc| (|operations| |parser|)
  (PROG ()
    (RETURN
      (COND
        ((APPLY |parser| NIL)
         ((LAMBDA ()
            (LOOP
              (COND
                ((NOT (AND (|bpInfGeneric| |operations|)
                           (OR (APPLY |parser| NIL) (|bpTrap|))))
                 (RETURN NIL))
                ('T
                 (|bpPush|
                     (|bfInfApplication| (|bpPop2|) (|bpPop2|)
                         (|bpPop1|))))))))
         T)
        ('T NIL)))))
 
; bpString()==
;      EQ(shoeTokType $stok,"STRING") and
;          bpPush(["QUOTE",INTERN $ttok]) and bpNext()
 
(DEFUN |bpString| ()
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (AND (EQ (|shoeTokType| |$stok|) 'STRING)
           (|bpPush| (LIST 'QUOTE (INTERN |$ttok|))) (|bpNext|)))))
 
; bpThetaName() ==
;         if EQCAR( $stok,"ID") and GET($ttok,"SHOETHETA")
;         then
;            bpPushId()
;            bpNext()
;         else false
 
(DEFUN |bpThetaName| ()
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (COND
        ((AND (EQCAR |$stok| 'ID) (GET |$ttok| 'SHOETHETA))
         (|bpPushId|) (|bpNext|))
        ('T NIL)))))
 
; bpReduceOperator()==
;          bpInfixOperator() or bpString()
;                 or bpThetaName()
 
(DEFUN |bpReduceOperator| ()
  (PROG ()
    (RETURN (OR (|bpInfixOperator|) (|bpString|) (|bpThetaName|)))))
 
; bpReduce()==
;      a:=bpState()
;      if bpReduceOperator() and bpEqKey "SLASH"
;      then
;         bpEqPeek "OBRACK" => (bpDConstruct() or bpTrap()) and
;                      bpPush bfReduceCollect(bpPop2(),bpPop1())
;         (bpApplication() or bpTrap()) and
;                 bpPush bfReduce(bpPop2(),bpPop1())
;      else
;         bpRestore a
;         false
 
(DEFUN |bpReduce| ()
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|bpState|))
        (COND
          ((AND (|bpReduceOperator|) (|bpEqKey| 'SLASH))
           (COND
             ((|bpEqPeek| 'OBRACK)
              (AND (OR (|bpDConstruct|) (|bpTrap|))
                   (|bpPush| (|bfReduceCollect| (|bpPop2|) (|bpPop1|)))))
             ('T
              (AND (OR (|bpApplication|) (|bpTrap|))
                   (|bpPush| (|bfReduce| (|bpPop2|) (|bpPop1|)))))))
          ('T (|bpRestore| |a|) NIL))))))
 
; bpTimes()==
;     bpReduce() or bpLeftAssoc('(TIMES  SLASH),function bpExpt)
 
(DEFUN |bpTimes| ()
  (PROG ()
    (RETURN
      (OR (|bpReduce|) (|bpLeftAssoc| '(TIMES SLASH) #'|bpExpt|)))))
 
; bpMinus()==
;    bpInfGeneric '(MINUS) and (bpTimes() or bpTrap())
;         and bpPush(bfApplication(bpPop2(),bpPop1()))
;           or bpTimes()
 
(DEFUN |bpMinus| ()
  (PROG ()
    (RETURN
      (OR (AND (|bpInfGeneric| '(MINUS)) (OR (|bpTimes|) (|bpTrap|))
               (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|))))
          (|bpTimes|)))))
 
; bpArith()==bpLeftAssoc('(PLUS MINUS),function bpMinus)
 
(DEFUN |bpArith| ()
  (PROG () (RETURN (|bpLeftAssoc| '(PLUS MINUS) #'|bpMinus|))))
 
; bpIs()==
;      bpArith() and (bpInfKey '(IS ISNT) and (bpPattern() or bpTrap())
;         and bpPush bfISApplication(bpPop2(),bpPop2(),bpPop1())
;            or true)
 
(DEFUN |bpIs| ()
  (PROG ()
    (RETURN
      (AND (|bpArith|)
           (OR (AND (|bpInfKey| '(IS ISNT))
                    (OR (|bpPattern|) (|bpTrap|))
                    (|bpPush|
                        (|bfISApplication| (|bpPop2|) (|bpPop2|)
                            (|bpPop1|))))
               T)))))
 
; bpBracketConstruct(f)==
;         bpBracket f and bpPush bfConstruct bpPop1 ()
 
(DEFUN |bpBracketConstruct| (|f|)
  (PROG ()
    (RETURN
      (AND (|bpBracket| |f|) (|bpPush| (|bfConstruct| (|bpPop1|)))))))
 
; bpCompare()==
;      bpIs() and (bpInfKey  '(SHOEEQ NE LT LE GT GE IN)
;         and (bpIs() or bpTrap())
;            and bpPush bfInfApplication(bpPop2(),bpPop2(),bpPop1())
;                or true)
 
(DEFUN |bpCompare| ()
  (PROG ()
    (RETURN
      (AND (|bpIs|)
           (OR (AND (|bpInfKey| '(SHOEEQ NE LT LE GT GE IN))
                    (OR (|bpIs|) (|bpTrap|))
                    (|bpPush|
                        (|bfInfApplication| (|bpPop2|) (|bpPop2|)
                            (|bpPop1|))))
               T)))))
 
; bpAnd()== bpLeftAssoc('(AND),function bpCompare)
 
(DEFUN |bpAnd| ()
  (PROG () (RETURN (|bpLeftAssoc| '(AND) #'|bpCompare|))))
 
; bpReturn()==
;          (bpEqKey "RETURN" and
;            (bpAnd() or bpTrap()) and
;                 bpPush bfReturnNoName bpPop1()) or bpAnd()
 
(DEFUN |bpReturn| ()
  (PROG ()
    (RETURN
      (OR (AND (|bpEqKey| 'RETURN) (OR (|bpAnd|) (|bpTrap|))
               (|bpPush| (|bfReturnNoName| (|bpPop1|))))
          (|bpAnd|)))))
 
; bpLogical()== bpLeftAssoc('(OR),function bpReturn)
 
(DEFUN |bpLogical| ()
  (PROG () (RETURN (|bpLeftAssoc| '(OR) #'|bpReturn|))))
 
; bpExpression()==
;      bpEqKey "COLON" and (bpLogical() and
;               bpPush bfApplication ("COLON",bpPop1())
;                     or bpTrap()) or bpLogical()
 
(DEFUN |bpExpression| ()
  (PROG ()
    (RETURN
      (OR (AND (|bpEqKey| 'COLON)
               (OR (AND (|bpLogical|)
                        (|bpPush| (|bfApplication| 'COLON (|bpPop1|))))
                   (|bpTrap|)))
          (|bpLogical|)))))
 
; bpStatement()==
;   bpConditional function bpWhere or bpLoop()  or bpExpression()
 
(DEFUN |bpStatement| ()
  (PROG ()
    (RETURN
      (OR (|bpConditional| #'|bpWhere|) (|bpLoop|) (|bpExpression|)))))
 
; bpLoop()==
;      bpIterators() and
;       (bpCompMissing "REPEAT" and
;          (bpWhere() or bpTrap()) and
;             bpPush bfLp(bpPop2(),bpPop1()))
;                 or
;                   bpEqKey "REPEAT" and (bpLogical() or bpTrap()) and
;                        bpPush bfLoop1 bpPop1 ()
 
(DEFUN |bpLoop| ()
  (PROG ()
    (RETURN
      (OR (AND (|bpIterators|) (|bpCompMissing| 'REPEAT)
               (OR (|bpWhere|) (|bpTrap|))
               (|bpPush| (|bfLp| (|bpPop2|) (|bpPop1|))))
          (AND (|bpEqKey| 'REPEAT) (OR (|bpLogical|) (|bpTrap|))
               (|bpPush| (|bfLoop1| (|bpPop1|))))))))
 
; bpSuchThat()==bpAndOr("BAR",function bpWhere,function bfSuchthat)
 
(DEFUN |bpSuchThat| ()
  (PROG () (RETURN (|bpAndOr| 'BAR #'|bpWhere| #'|bfSuchthat|))))
 
; bpWhile()==bpAndOr ("WHILE",function bpLogical,function bfWhile)
 
(DEFUN |bpWhile| ()
  (PROG () (RETURN (|bpAndOr| 'WHILE #'|bpLogical| #'|bfWhile|))))
 
; bpUntil()==bpAndOr ("UNTIL",function bpLogical,function bfUntil)
 
(DEFUN |bpUntil| ()
  (PROG () (RETURN (|bpAndOr| 'UNTIL #'|bpLogical| #'|bfUntil|))))
 
; bpForIn()==
;   bpEqKey "FOR" and (bpVariable() or bpTrap()) and (bpCompMissing "IN")
;       and ((bpSeg()  or bpTrap()) and
;        (bpEqKey "BY" and (bpArith() or bpTrap()) and
;         bpPush bfForInBy(bpPop3(),bpPop2(),bpPop1())) or
;          bpPush bfForin(bpPop2(),bpPop1()))
 
(DEFUN |bpForIn| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'FOR) (OR (|bpVariable|) (|bpTrap|))
           (|bpCompMissing| 'IN)
           (OR (AND (OR (|bpSeg|) (|bpTrap|)) (|bpEqKey| 'BY)
                    (OR (|bpArith|) (|bpTrap|))
                    (|bpPush|
                        (|bfForInBy| (|bpPop3|) (|bpPop2|) (|bpPop1|))))
               (|bpPush| (|bfForin| (|bpPop2|) (|bpPop1|))))))))
 
; bpSeg()==
;    bpArith() and
;       (bpEqKey "SEG" and
;        (bpArith() and bpPush(bfSegment2(bpPop2(),bpPop1()))
;          or bpPush(bfSegment1(bpPop1()))) or true)
 
(DEFUN |bpSeg| ()
  (PROG ()
    (RETURN
      (AND (|bpArith|)
           (OR (AND (|bpEqKey| 'SEG)
                    (OR (AND (|bpArith|)
                             (|bpPush|
                                 (|bfSegment2| (|bpPop2|) (|bpPop1|))))
                        (|bpPush| (|bfSegment1| (|bpPop1|)))))
               T)))))
 
; bpIterator()==
;   bpForIn() or bpSuchThat() or bpWhile() or bpUntil()
 
(DEFUN |bpIterator| ()
  (PROG ()
    (RETURN (OR (|bpForIn|) (|bpSuchThat|) (|bpWhile|) (|bpUntil|)))))
 
; bpIteratorList()==bpOneOrMore function bpIterator
;        and bpPush bfIterators bpPop1 ()
 
(DEFUN |bpIteratorList| ()
  (PROG ()
    (RETURN
      (AND (|bpOneOrMore| #'|bpIterator|)
           (|bpPush| (|bfIterators| (|bpPop1|)))))))
 
; bpCrossBackSet()== bpEqKey "CROSS" and (bpEqKey "BACKSET" or true)
 
(DEFUN |bpCrossBackSet| ()
  (PROG ()
    (RETURN (AND (|bpEqKey| 'CROSS) (OR (|bpEqKey| 'BACKSET) T)))))
 
; bpIterators()==
;          bpListofFun(function bpIteratorList,
;               function bpCrossBackSet,function bfCross)
 
(DEFUN |bpIterators| ()
  (PROG ()
    (RETURN
      (|bpListofFun| #'|bpIteratorList| #'|bpCrossBackSet| #'|bfCross|))))
 
; bpAssign()==
;             a:=bpState()
;             if bpStatement()
;             then
;                  if bpEqPeek "BEC"
;                  then
;                    bpRestore a
;                    bpAssignment() or bpTrap()
;                  else true
;             else
;                  bpRestore a
;                  false
 
(DEFUN |bpAssign| ()
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|bpState|))
        (COND
          ((|bpStatement|)
           (COND
             ((|bpEqPeek| 'BEC) (|bpRestore| |a|)
              (OR (|bpAssignment|) (|bpTrap|)))
             (#0='T T)))
          (#0# (|bpRestore| |a|) NIL))))))
 
; bpAssignment()==
;        bpAssignVariable() and
;          bpEqKey "BEC" and
;            (bpAssign() or bpTrap()) and
;               bpPush bfAssign (bpPop2(),bpPop1())
 
(DEFUN |bpAssignment| ()
  (PROG ()
    (RETURN
      (AND (|bpAssignVariable|) (|bpEqKey| 'BEC)
           (OR (|bpAssign|) (|bpTrap|))
           (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|)))))))
 
; bpExit()==
;      bpAssign() and (bpEqKey "EXIT" and
;          ((bpWhere() or bpTrap()) and
;             bpPush bfExit (bpPop2(),bpPop1()))
;               or true)
 
(DEFUN |bpExit| ()
  (PROG ()
    (RETURN
      (AND (|bpAssign|)
           (OR (AND (|bpEqKey| 'EXIT) (OR (|bpWhere|) (|bpTrap|))
                    (|bpPush| (|bfExit| (|bpPop2|) (|bpPop1|))))
               T)))))
 
; bpDefinition()==
;         a:=bpState()
;         bpExit() =>
;              bpEqPeek "DEF" =>
;                 bpRestore a
;                 bpDef()
;              bpEqPeek "MDEF" =>
;                 bpRestore a
;                 bpMdef()
;              true
;         bpRestore a
;         false
 
(DEFUN |bpDefinition| ()
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|bpState|))
        (COND
          ((|bpExit|)
           (COND
             ((|bpEqPeek| 'DEF) (PROGN (|bpRestore| |a|) (|bpDef|)))
             ((|bpEqPeek| 'MDEF) (PROGN (|bpRestore| |a|) (|bpMdef|)))
             (#0='T T)))
          (#0# (PROGN (|bpRestore| |a|) NIL)))))))
 
; bpStoreName()==
;          $op:=car $stack
;          $wheredefs:=nil
;          $typings:=nil
;          true
 
(DEFUN |bpStoreName| ()
  (PROG ()
    (DECLARE (SPECIAL |$typings| |$wheredefs| |$op| |$stack|))
    (RETURN
      (PROGN
        (SETQ |$op| (CAR |$stack|))
        (SETQ |$wheredefs| NIL)
        (SETQ |$typings| NIL)
        T))))
 
; bpDef() ==  bpName() and bpStoreName()  and
;                bpDefTail() and bpPush bfCompDef bpPop1 ()
 
(DEFUN |bpDef| ()
  (PROG ()
    (RETURN
      (AND (|bpName|) (|bpStoreName|) (|bpDefTail|)
           (|bpPush| (|bfCompDef| (|bpPop1|)))))))
 
; bpDDef() ==  bpName() and bpDefTail()
 
(DEFUN |bpDDef| () (PROG () (RETURN (AND (|bpName|) (|bpDefTail|)))))
 
; bpDefTail()==
;       bpEqKey "DEF" and
;         (bpWhere() or bpTrap())
;           and bpPush bfDefinition1(bpPop2(),bpPop1())
;            or
;              bpVariable()  and
;                bpEqKey "DEF" and (bpWhere() or bpTrap())
;                  and bpPush bfDefinition2(bpPop3(),bpPop2(),bpPop1())
 
(DEFUN |bpDefTail| ()
  (PROG ()
    (RETURN
      (OR (AND (|bpEqKey| 'DEF) (OR (|bpWhere|) (|bpTrap|))
               (|bpPush| (|bfDefinition1| (|bpPop2|) (|bpPop1|))))
          (AND (|bpVariable|) (|bpEqKey| 'DEF)
               (OR (|bpWhere|) (|bpTrap|))
               (|bpPush|
                   (|bfDefinition2| (|bpPop3|) (|bpPop2|) (|bpPop1|))))))))
 
; bpMDefTail()==
;  --   bpEqKey "MDEF" and
;  --   (bpWhere() or bpTrap())
;  --     and bpPush bfMDefinition1(bpPop2(),bpPop1())
;  --      or
;            (bpVariable() or bpTrap()) and
;              bpEqKey "MDEF" and (bpWhere() or bpTrap())
;                  and bpPush bfMDefinition2(bpPop3(),bpPop2(),bpPop1())
 
(DEFUN |bpMDefTail| ()
  (PROG ()
    (RETURN
      (AND (OR (|bpVariable|) (|bpTrap|)) (|bpEqKey| 'MDEF)
           (OR (|bpWhere|) (|bpTrap|))
           (|bpPush|
               (|bfMDefinition2| (|bpPop3|) (|bpPop2|) (|bpPop1|)))))))
 
; bpMdef()== bpName() and bpStoreName() and bpMDefTail()
 
(DEFUN |bpMdef| ()
  (PROG () (RETURN (AND (|bpName|) (|bpStoreName|) (|bpMDefTail|)))))
 
; bpWhere()==
;     bpDefinition() and
;        (bpEqKey "WHERE" and (bpDefinitionItem() or bpTrap())
;            and bpPush bfWhere(bpPop1(),bpPop1()) or true)
 
(DEFUN |bpWhere| ()
  (PROG ()
    (RETURN
      (AND (|bpDefinition|)
           (OR (AND (|bpEqKey| 'WHERE)
                    (OR (|bpDefinitionItem|) (|bpTrap|))
                    (|bpPush| (|bfWhere| (|bpPop1|) (|bpPop1|))))
               T)))))
 
; bpDefinitionItem()==
;           a:=bpState()
;           if bpDDef()
;           then true
;           else
;              bpRestore a
;              if bpBDefinitionPileItems()
;              then true
;              else
;                bpRestore a
;                if bpPDefinitionItems()
;                then true
;                else
;                    bpRestore a
;                    bpWhere()
 
(DEFUN |bpDefinitionItem| ()
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|bpState|))
        (COND
          ((|bpDDef|) T)
          (#0='T (|bpRestore| |a|)
           (COND
             ((|bpBDefinitionPileItems|) T)
             (#0# (|bpRestore| |a|)
              (COND
                ((|bpPDefinitionItems|) T)
                (#0# (|bpRestore| |a|) (|bpWhere|)))))))))))
 
; bpDefinitionPileItems()==
;     bpListAndRecover function bpDefinitionItem
;            and bpPush bfDefSequence bpPop1()
 
(DEFUN |bpDefinitionPileItems| ()
  (PROG ()
    (RETURN
      (AND (|bpListAndRecover| #'|bpDefinitionItem|)
           (|bpPush| (|bfDefSequence| (|bpPop1|)))))))
 
; bpBDefinitionPileItems()== bpPileBracketed function bpDefinitionPileItems
 
(DEFUN |bpBDefinitionPileItems| ()
  (PROG () (RETURN (|bpPileBracketed| #'|bpDefinitionPileItems|))))
 
; bpSemiColonDefinition()==bpSemiListing
;     (function bpDefinitionItem,function bfDefSequence)
 
(DEFUN |bpSemiColonDefinition| ()
  (PROG ()
    (RETURN (|bpSemiListing| #'|bpDefinitionItem| #'|bfDefSequence|))))
 
; bpPDefinitionItems()==bpParenthesized function bpSemiColonDefinition
 
(DEFUN |bpPDefinitionItems| ()
  (PROG () (RETURN (|bpParenthesized| #'|bpSemiColonDefinition|))))
 
; bpComma()== bpTuple function bpWhere
 
(DEFUN |bpComma| () (PROG () (RETURN (|bpTuple| #'|bpWhere|))))
 
; bpTuple(p)==bpListofFun(p,function bpCommaBackSet,function bfTuple)
 
(DEFUN |bpTuple| (|p|)
  (PROG ()
    (RETURN (|bpListofFun| |p| #'|bpCommaBackSet| #'|bfTuple|))))
 
; bpCommaBackSet()== bpEqKey "COMMA" and (bpEqKey "BACKSET" or true)
 
(DEFUN |bpCommaBackSet| ()
  (PROG ()
    (RETURN (AND (|bpEqKey| 'COMMA) (OR (|bpEqKey| 'BACKSET) T)))))
 
; bpSemiColon()==bpSemiListing (function bpComma,function bfSequence)
 
(DEFUN |bpSemiColon| ()
  (PROG () (RETURN (|bpSemiListing| #'|bpComma| #'|bfSequence|))))
 
; bpSemiListing(p,f)==bpListofFun(p,function bpSemiBackSet,f)
 
(DEFUN |bpSemiListing| (|p| |f|)
  (PROG () (RETURN (|bpListofFun| |p| #'|bpSemiBackSet| |f|))))
 
; bpSemiBackSet()== bpEqKey "SEMICOLON" and (bpEqKey "BACKSET" or true)
 
(DEFUN |bpSemiBackSet| ()
  (PROG ()
    (RETURN (AND (|bpEqKey| 'SEMICOLON) (OR (|bpEqKey| 'BACKSET) T)))))
 
; bpPDefinition()==  bpIndentParenthesized function bpSemiColon
 
(DEFUN |bpPDefinition| ()
  (PROG () (RETURN (|bpIndentParenthesized| #'|bpSemiColon|))))
 
; bpPileItems()==
;     bpListAndRecover function bpSemiColon and bpPush bfSequence bpPop1()
 
(DEFUN |bpPileItems| ()
  (PROG ()
    (RETURN
      (AND (|bpListAndRecover| #'|bpSemiColon|)
           (|bpPush| (|bfSequence| (|bpPop1|)))))))
 
; bpBPileDefinition()==  bpPileBracketed function bpPileItems
 
(DEFUN |bpBPileDefinition| ()
  (PROG () (RETURN (|bpPileBracketed| #'|bpPileItems|))))
 
; bpIteratorTail()==
;      (bpEqKey "REPEAT" or true) and bpIterators()
 
(DEFUN |bpIteratorTail| ()
  (PROG () (RETURN (AND (OR (|bpEqKey| 'REPEAT) T) (|bpIterators|)))))
 
; bpConstruct()==bpBracket function bpConstruction
 
(DEFUN |bpConstruct| ()
  (PROG () (RETURN (|bpBracket| #'|bpConstruction|))))
 
; bpConstruction()==
;      bpComma() and
;         (bpIteratorTail() and
;              bpPush bfCollect (bpPop2(),bpPop1()) or
;                 bpPush bfTupleConstruct bpPop1())
 
(DEFUN |bpConstruction| ()
  (PROG ()
    (RETURN
      (AND (|bpComma|)
           (OR (AND (|bpIteratorTail|)
                    (|bpPush| (|bfCollect| (|bpPop2|) (|bpPop1|))))
               (|bpPush| (|bfTupleConstruct| (|bpPop1|))))))))
 
; bpDConstruct()==bpBracket function bpDConstruction
 
(DEFUN |bpDConstruct| ()
  (PROG () (RETURN (|bpBracket| #'|bpDConstruction|))))
 
; bpDConstruction()==
;      bpComma() and
;         (bpIteratorTail() and
;              bpPush bfDCollect (bpPop2(),bpPop1()) or
;                 bpPush bfDTuple bpPop1())
 
(DEFUN |bpDConstruction| ()
  (PROG ()
    (RETURN
      (AND (|bpComma|)
           (OR (AND (|bpIteratorTail|)
                    (|bpPush| (|bfDCollect| (|bpPop2|) (|bpPop1|))))
               (|bpPush| (|bfDTuple| (|bpPop1|))))))))
 
; bpPattern()== bpBracketConstruct function bpPatternL
;                 or bpName() or bpConstTok()
 
(DEFUN |bpPattern| ()
  (PROG ()
    (RETURN
      (OR (|bpBracketConstruct| #'|bpPatternL|) (|bpName|)
          (|bpConstTok|)))))
 
; bpEqual()==
;    bpEqKey "SHOEEQ" and (bpApplication() or bpConstTok() or
;                 bpTrap()) and bpPush bfEqual bpPop1()
 
(DEFUN |bpEqual| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'SHOEEQ)
           (OR (|bpApplication|) (|bpConstTok|) (|bpTrap|))
           (|bpPush| (|bfEqual| (|bpPop1|)))))))
 
; bpRegularPatternItem() ==
;    bpEqual() or
;      bpConstTok() or bpDot() or
;       bpName() and
;          ((bpEqKey "BEC" and (bpPattern() or bpTrap())
;               and bpPush bfAssign(bpPop2(),bpPop1())) or true)
;                     or bpBracketConstruct function bpPatternL
 
(DEFUN |bpRegularPatternItem| ()
  (PROG ()
    (RETURN
      (OR (|bpEqual|) (|bpConstTok|) (|bpDot|)
          (AND (|bpName|)
               (OR (AND (|bpEqKey| 'BEC) (OR (|bpPattern|) (|bpTrap|))
                        (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
                   T))
          (|bpBracketConstruct| #'|bpPatternL|)))))
 
; bpRegularPatternItemL()==
;       bpRegularPatternItem() and bpPush [bpPop1()]
 
(DEFUN |bpRegularPatternItemL| ()
  (PROG ()
    (RETURN
      (AND (|bpRegularPatternItem|) (|bpPush| (LIST (|bpPop1|)))))))
 
; bpRegularList()==
;        bpListof(function bpRegularPatternItemL,"COMMA",function bfAppend)
 
(DEFUN |bpRegularList| ()
  (PROG ()
    (RETURN
      (|bpListof| #'|bpRegularPatternItemL| 'COMMA #'|bfAppend|))))
 
; bpPatternColon()==
;      bpEqKey "COLON" and (bpRegularPatternItem() or bpTrap())
;               and bpPush [bfColon bpPop1()]
 
(DEFUN |bpPatternColon| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'COLON) (OR (|bpRegularPatternItem|) (|bpTrap|))
           (|bpPush| (LIST (|bfColon| (|bpPop1|))))))))
 
; bpPatternL() == bpPatternList() and bpPush bfTuple bpPop1()
 
(DEFUN |bpPatternL| ()
  (PROG ()
    (RETURN (AND (|bpPatternList|) (|bpPush| (|bfTuple| (|bpPop1|)))))))
 
; bpPatternList()==
;      if bpRegularPatternItemL()
;      then
;         while (bpEqKey  "COMMA" and (bpRegularPatternItemL() or
;             (bpPatternTail()
;               and bpPush append(bpPop2(),bpPop1())
;                 or bpTrap();false) )) repeat
;                   bpPush append(bpPop2(),bpPop1())
;         true
;      else bpPatternTail()
 
(DEFUN |bpPatternList| ()
  (PROG ()
    (RETURN
      (COND
        ((|bpRegularPatternItemL|)
         ((LAMBDA ()
            (LOOP
              (COND
                ((NOT (AND (|bpEqKey| 'COMMA)
                           (OR (|bpRegularPatternItemL|)
                               (PROGN
                                 (OR (AND (|bpPatternTail|)
                                      (|bpPush|
                                       (APPEND (|bpPop2|) (|bpPop1|))))
                                     (|bpTrap|))
                                 NIL))))
                 (RETURN NIL))
                ('T (|bpPush| (APPEND (|bpPop2|) (|bpPop1|))))))))
         T)
        ('T (|bpPatternTail|))))))
 
; bpPatternTail()==
;      bpPatternColon() and
;          (bpEqKey "COMMA" and (bpRegularList() or bpTrap())
;               and bpPush append (bpPop2(),bpPop1()) or true)
 
(DEFUN |bpPatternTail| ()
  (PROG ()
    (RETURN
      (AND (|bpPatternColon|)
           (OR (AND (|bpEqKey| 'COMMA)
                    (OR (|bpRegularList|) (|bpTrap|))
                    (|bpPush| (APPEND (|bpPop2|) (|bpPop1|))))
               T)))))
 
; bpRegularBVItem() ==
;   bpBVString() or
;      bpConstTok() or
;       (bpName() and
;          (bpEqKey "BEC" and (bpPattern() or bpTrap())
;               and bpPush bfAssign(bpPop2(),bpPop1()) or
;                (bpEqKey "IS" and (bpPattern() or bpTrap())
;                   and bpPush bfAssign(bpPop2(),bpPop1())) or true))
;                     or bpBracketConstruct function bpPatternL
 
(DEFUN |bpRegularBVItem| ()
  (PROG ()
    (RETURN
      (OR (|bpBVString|) (|bpConstTok|)
          (AND (|bpName|)
               (OR (AND (|bpEqKey| 'BEC) (OR (|bpPattern|) (|bpTrap|))
                        (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
                   (AND (|bpEqKey| 'IS) (OR (|bpPattern|) (|bpTrap|))
                        (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
                   T))
          (|bpBracketConstruct| #'|bpPatternL|)))))
 
; bpBVString()==
;      EQ(shoeTokType $stok,"STRING") and
;          bpPush(["BVQUOTE",INTERN $ttok]) and bpNext()
 
(DEFUN |bpBVString| ()
  (PROG ()
    (DECLARE (SPECIAL |$ttok| |$stok|))
    (RETURN
      (AND (EQ (|shoeTokType| |$stok|) 'STRING)
           (|bpPush| (LIST 'BVQUOTE (INTERN |$ttok|))) (|bpNext|)))))
 
; bpRegularBVItemL() ==
;       bpRegularBVItem() and bpPush [bpPop1()]
 
(DEFUN |bpRegularBVItemL| ()
  (PROG ()
    (RETURN (AND (|bpRegularBVItem|) (|bpPush| (LIST (|bpPop1|)))))))
 
; bpColonName()==
;      bpEqKey "COLON" and (bpName() or bpBVString() or bpTrap())
 
(DEFUN |bpColonName| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'COLON)
           (OR (|bpName|) (|bpBVString|) (|bpTrap|))))))
 
; bpBoundVariablelist()==
;      if bpRegularBVItemL()
;      then
;         while (bpEqKey  "COMMA" and (bpRegularBVItemL() or
;             (bpColonName()
;               and bpPush  bfColonAppend(bpPop2(),bpPop1())
;                 or bpTrap();false) )) repeat
;                    bpPush append(bpPop2(),bpPop1())
;         true
;      else bpColonName() and bpPush bfColonAppend(nil,bpPop1())
 
(DEFUN |bpBoundVariablelist| ()
  (PROG ()
    (RETURN
      (COND
        ((|bpRegularBVItemL|)
         ((LAMBDA ()
            (LOOP
              (COND
                ((NOT (AND (|bpEqKey| 'COMMA)
                           (OR (|bpRegularBVItemL|)
                               (PROGN
                                 (OR (AND (|bpColonName|)
                                      (|bpPush|
                                       (|bfColonAppend| (|bpPop2|)
                                        (|bpPop1|))))
                                     (|bpTrap|))
                                 NIL))))
                 (RETURN NIL))
                ('T (|bpPush| (APPEND (|bpPop2|) (|bpPop1|))))))))
         T)
        ('T
         (AND (|bpColonName|)
              (|bpPush| (|bfColonAppend| NIL (|bpPop1|)))))))))
 
; bpVariable()==
;     bpParenthesized function bpBoundVariablelist
;        and bpPush bfTupleIf bpPop1()
;          or bpBracketConstruct function bpPatternL
;                 or bpName() or bpConstTok()
 
(DEFUN |bpVariable| ()
  (PROG ()
    (RETURN
      (OR (AND (|bpParenthesized| #'|bpBoundVariablelist|)
               (|bpPush| (|bfTupleIf| (|bpPop1|))))
          (|bpBracketConstruct| #'|bpPatternL|) (|bpName|)
          (|bpConstTok|)))))
 
; bpAssignVariable()==
;       bpBracketConstruct function bpPatternL or bpAssignLHS()
 
(DEFUN |bpAssignVariable| ()
  (PROG ()
    (RETURN
      (OR (|bpBracketConstruct| #'|bpPatternL|) (|bpAssignLHS|)))))
 
; bpAssignLHS()==
;    bpName() and (bpEqKey "COLON" and (bpApplication() or bpTrap())
;      and bpPush bfLocal(bpPop2(),bpPop1())
;         or bpEqKey "DOT" and bpList(function bpPrimary,"DOT",
;               function bfListOf)
;           and bpChecknull() and
;             bpPush bfTuple(cons(bpPop2(),bpPop1()))
;                  or true)
 
(DEFUN |bpAssignLHS| ()
  (PROG ()
    (RETURN
      (AND (|bpName|)
           (OR (AND (|bpEqKey| 'COLON)
                    (OR (|bpApplication|) (|bpTrap|))
                    (|bpPush| (|bfLocal| (|bpPop2|) (|bpPop1|))))
               (AND (|bpEqKey| 'DOT)
                    (|bpList| #'|bpPrimary| 'DOT #'|bfListOf|)
                    (|bpChecknull|)
                    (|bpPush| (|bfTuple| (CONS (|bpPop2|) (|bpPop1|)))))
               T)))))
 
; bpChecknull()==
;       a:=bpPop1()
;       if null a
;       then bpTrap()
;       else bpPush a
 
(DEFUN |bpChecknull| ()
  (PROG (|a|)
    (RETURN
      (PROGN
        (SETQ |a| (|bpPop1|))
        (COND ((NULL |a|) (|bpTrap|)) ('T (|bpPush| |a|)))))))
 
; bpStruct()==
;    bpEqKey "STRUCTURE" and
;       (bpName() or bpTrap()) and
;         (bpEqKey "DEF" or bpTrap()) and
;            bpTypeList() and bpPush bfStruct(bpPop2(),bpPop1())
 
(DEFUN |bpStruct| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'STRUCTURE) (OR (|bpName|) (|bpTrap|))
           (OR (|bpEqKey| 'DEF) (|bpTrap|)) (|bpTypeList|)
           (|bpPush| (|bfStruct| (|bpPop2|) (|bpPop1|)))))))
 
; bpTypeList() == bpPileBracketed function bpTypeItemList
;        or bpTerm() and bpPush [bpPop1()]
 
(DEFUN |bpTypeList| ()
  (PROG ()
    (RETURN
      (OR (|bpPileBracketed| #'|bpTypeItemList|)
          (AND (|bpTerm|) (|bpPush| (LIST (|bpPop1|))))))))
 
; bpTypeItemList() ==  bpListAndRecover function bpTerm
 
(DEFUN |bpTypeItemList| ()
  (PROG () (RETURN (|bpListAndRecover| #'|bpTerm|))))
 
; bpTerm() ==
;           (bpName() or bpTrap()) and
;             ((bpParenthesized function bpIdList and
;               bpPush bfNameArgs (bpPop2(),bpPop1()))
;                 or bpName() and bpPush bfNameArgs(bpPop2(),bpPop1()))
;                  or bpPush(bfNameOnly bpPop1())
 
(DEFUN |bpTerm| ()
  (PROG ()
    (RETURN
      (OR (AND (OR (|bpName|) (|bpTrap|))
               (OR (AND (|bpParenthesized| #'|bpIdList|)
                        (|bpPush| (|bfNameArgs| (|bpPop2|) (|bpPop1|))))
                   (AND (|bpName|)
                        (|bpPush| (|bfNameArgs| (|bpPop2|) (|bpPop1|))))))
          (|bpPush| (|bfNameOnly| (|bpPop1|)))))))
 
; bpIdList()== bpTuple function bpName
 
(DEFUN |bpIdList| () (PROG () (RETURN (|bpTuple| #'|bpName|))))
 
; bpCase()==
;       bpEqKey "CASE" and
;         (bpWhere() or bpTrap()) and
;            (bpEqKey "OF" or bpMissing "OF") and
;                  bpPiledCaseItems()
 
(DEFUN |bpCase| ()
  (PROG ()
    (RETURN
      (AND (|bpEqKey| 'CASE) (OR (|bpWhere|) (|bpTrap|))
           (OR (|bpEqKey| 'OF) (|bpMissing| 'OF)) (|bpPiledCaseItems|)))))
 
; bpPiledCaseItems()==
;    bpPileBracketed function bpCaseItemList and
;        bpPush bfCase(bpPop2(),bpPop1())
 
(DEFUN |bpPiledCaseItems| ()
  (PROG ()
    (RETURN
      (AND (|bpPileBracketed| #'|bpCaseItemList|)
           (|bpPush| (|bfCase| (|bpPop2|) (|bpPop1|)))))))
 
; bpCaseItemList()==
;    bpListAndRecover function bpCaseItem
 
(DEFUN |bpCaseItemList| ()
  (PROG () (RETURN (|bpListAndRecover| #'|bpCaseItem|))))
 
; bpCaseItem()==
;     (bpTerm() or bpTrap()) and
;        (bpEqKey "EXIT" or bpTrap()) and
;          (bpWhere() or bpTrap()) and
;             bpPush bfCaseItem (bpPop2(),bpPop1())
 
(DEFUN |bpCaseItem| ()
  (PROG ()
    (RETURN
      (AND (OR (|bpTerm|) (|bpTrap|)) (OR (|bpEqKey| 'EXIT) (|bpTrap|))
           (OR (|bpWhere|) (|bpTrap|))
           (|bpPush| (|bfCaseItem| (|bpPop2|) (|bpPop1|)))))))
