 
; )package "BOOTTRAN"
 
(IN-PACKAGE "BOOTTRAN")
 
; DEFVAR($bpCount)
 
(DEFVAR |$bpCount|)
 
; DEFVAR($bpParenCount)
 
(DEFVAR |$bpParenCount|)
 
; DEFVAR($inputStream)
 
(DEFVAR |$inputStream|)
 
; DEFVAR($op)
 
(DEFVAR |$op|)
 
; DEFVAR($stack)
 
(DEFVAR |$stack|)
 
; DEFVAR($stok)
 
(DEFVAR |$stok|)
 
; DEFVAR($ttok)
 
(DEFVAR |$ttok|)
 
; bpFirstToken()==
;       $stok:=
;           if null $inputStream
;           then shoeTokConstruct("ERROR","NOMORE",shoeTokPosn $stok)
;           else CAR $inputStream
;       $ttok:=shoeTokPart $stok
;       true
 
(DEFUN |bpFirstToken| #1=()
  (PROG #1#
    (RETURN
     (PROGN
      (SETQ |$stok|
              (COND
               ((NULL |$inputStream|)
                (|shoeTokConstruct| 'ERROR 'NOMORE (|shoeTokPosn| |$stok|)))
               ('T (CAR |$inputStream|))))
      (SETQ |$ttok| (|shoeTokPart| |$stok|))
      T))))
 
; bpFirstTok()==
;       $stok:=
;           if null $inputStream
;           then shoeTokConstruct("ERROR","NOMORE",shoeTokPosn $stok)
;           else CAR $inputStream
;       $ttok:=shoeTokPart $stok
;       $bpParenCount>0 and EQCAR($stok,"KEY") =>
;              EQ($ttok,"SETTAB")=>
;                 $bpCount:=$bpCount+1
;                 bpNext()
;              EQ($ttok,"BACKTAB")=>
;                 $bpCount:=$bpCount-1
;                 bpNext()
;              EQ($ttok,"BACKSET")=>
;                 bpNext()
;              true
;       true
 
(DEFUN |bpFirstTok| #1=()
  (PROG #1#
    (RETURN
     (PROGN
      (SETQ |$stok|
              (COND
               ((NULL |$inputStream|)
                (|shoeTokConstruct| 'ERROR 'NOMORE (|shoeTokPosn| |$stok|)))
               (#2='T (CAR |$inputStream|))))
      (SETQ |$ttok| (|shoeTokPart| |$stok|))
      (COND
       ((AND (< 0 |$bpParenCount|) (EQCAR |$stok| 'KEY))
        (COND
         ((EQ |$ttok| 'SETTAB)
          (PROGN (SETQ |$bpCount| (+ |$bpCount| 1)) (|bpNext|)))
         ((EQ |$ttok| 'BACKTAB)
          (PROGN (SETQ |$bpCount| (- |$bpCount| 1)) (|bpNext|)))
         ((EQ |$ttok| 'BACKSET) (|bpNext|)) (#2# T)))
       (#2# T))))))
 
; bpNext() ==
;      $inputStream := CDR($inputStream)
;      bpFirstTok()
 
(DEFUN |bpNext| #1=()
  (PROG #1#
    (RETURN (PROGN (SETQ |$inputStream| (CDR |$inputStream|)) (|bpFirstTok|)))))
 
; bpNextToken() ==
;      $inputStream := CDR($inputStream)
;      bpFirstToken()
 
(DEFUN |bpNextToken| #1=()
  (PROG #1#
    (RETURN
     (PROGN (SETQ |$inputStream| (CDR |$inputStream|)) (|bpFirstToken|)))))
 
; bpState()== [$inputStream,$stack,$bpParenCount,$bpCount]
 
(DEFUN |bpState| #1=()
  (PROG #1# (RETURN (LIST |$inputStream| |$stack| |$bpParenCount| |$bpCount|))))
 
; bpRestore(x)==
;       $inputStream:=CAR x
;       bpFirstToken()
;       $stack:=CADR x
;       $bpParenCount:=CADDR x
;       $bpCount:=CADDDR x
;       true
 
(DEFUN |bpRestore| (|x|)
  (PROG ()
    (RETURN
     (PROGN
      (SETQ |$inputStream| (CAR |x|))
      (|bpFirstToken|)
      (SETQ |$stack| (CADR |x|))
      (SETQ |$bpParenCount| (CADDR |x|))
      (SETQ |$bpCount| (CADDDR |x|))
      T))))
 
; bpPush x==$stack:=CONS(x,$stack)
 
(DEFUN |bpPush| (|x|) (PROG () (RETURN (SETQ |$stack| (CONS |x| |$stack|)))))
 
; bpPushId()==
;    $stack:=CONS(bfReName $ttok,$stack)
 
(DEFUN |bpPushId| #1=()
  (PROG #1# (RETURN (SETQ |$stack| (CONS (|bfReName| |$ttok|) |$stack|)))))
 
; bpPop1()==
;        a:=CAR $stack
;        $stack:=CDR $stack
;        a
 
(DEFUN |bpPop1| ()
  (PROG (|a|)
    (RETURN
     (PROGN (SETQ |a| (CAR |$stack|)) (SETQ |$stack| (CDR |$stack|)) |a|))))
 
; bpPop2()==
;        a:=CADR $stack
;        RPLACD($stack,CDDR $stack)
;        a
 
(DEFUN |bpPop2| ()
  (PROG (|a|)
    (RETURN
     (PROGN (SETQ |a| (CADR |$stack|)) (RPLACD |$stack| (CDDR |$stack|)) |a|))))
 
; bpPop3()==
;        a:=CADDR $stack
;        RPLACD(CDR $stack,CDDDR $stack)
;        a
 
(DEFUN |bpPop3| ()
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (CADDR |$stack|))
      (RPLACD (CDR |$stack|) (CDDDR |$stack|))
      |a|))))
 
; bpIndentParenthesized f==
;     $bpCount:local:=0
;     a:=$stok
;     if bpEqPeek "OPAREN"
;     then
;       $bpParenCount:=$bpParenCount+1
;       bpNext()
;       if APPLY(f,nil) and bpFirstTok() and
;               (bpEqPeek "CPAREN" or bpParenTrap(a))
;       then
;             $bpParenCount:=$bpParenCount-1
;             bpNextToken()
;             $bpCount=0 => true
;             $inputStream:=append( bpAddTokens $bpCount,$inputStream)
;             bpFirstToken()
;             $bpParenCount=0 =>
;                      bpCancel()
;                      true
;             true
;       else if bpEqPeek "CPAREN"
;            then
;               bpPush  bfTuple []
;               $bpParenCount:=$bpParenCount-1
;               bpNextToken()
;               true
;            else bpParenTrap(a)
;     else false
 
(DEFUN |bpIndentParenthesized| (|f|)
  (PROG (|$bpCount| |a|)
    (DECLARE (SPECIAL |$bpCount|))
    (RETURN
     (PROGN
      (SETQ |$bpCount| 0)
      (SETQ |a| |$stok|)
      (COND
       ((|bpEqPeek| 'OPAREN) (SETQ |$bpParenCount| (+ |$bpParenCount| 1))
        (|bpNext|)
        (COND
         ((AND (APPLY |f| NIL) (|bpFirstTok|)
               (OR (|bpEqPeek| 'CPAREN) (|bpParenTrap| |a|)))
          (SETQ |$bpParenCount| (- |$bpParenCount| 1)) (|bpNextToken|)
          (COND ((EQL |$bpCount| 0) T)
                (#1='T
                 (PROGN
                  (SETQ |$inputStream|
                          (APPEND (|bpAddTokens| |$bpCount|) |$inputStream|))
                  (|bpFirstToken|)
                  (COND ((EQL |$bpParenCount| 0) (PROGN (|bpCancel|) T))
                        (#1# T))))))
         ((|bpEqPeek| 'CPAREN) (|bpPush| (|bfTuple| NIL))
          (SETQ |$bpParenCount| (- |$bpParenCount| 1)) (|bpNextToken|) T)
         (#1# (|bpParenTrap| |a|))))
       (#1# NIL))))))
 
; bpParenthesized f==
;     a:=$stok
;     if bpEqKey "OPAREN"
;     then
;       if APPLY(f,nil) and (bpEqKey "CPAREN" or bpParenTrap(a))
;       then true
;       else if bpEqKey "CPAREN"
;            then
;               bpPush  bfTuple []
;               true
;            else bpParenTrap(a)
;     else false
 
(DEFUN |bpParenthesized| (|f|)
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| |$stok|)
      (COND
       ((|bpEqKey| 'OPAREN)
        (COND
         ((AND (APPLY |f| NIL) (OR (|bpEqKey| 'CPAREN) (|bpParenTrap| |a|))) T)
         ((|bpEqKey| 'CPAREN) (|bpPush| (|bfTuple| NIL)) T)
         (#1='T (|bpParenTrap| |a|))))
       (#1# NIL))))))
 
; bpBracket f==
;     a:=$stok
;     if bpEqKey "OBRACK"
;     then
;       if APPLY(f,nil) and (bpEqKey "CBRACK" or bpBrackTrap(a))
;       then bpPush bfBracket bpPop1 ()
;       else if bpEqKey "CBRACK"
;            then bpPush  []
;            else bpBrackTrap(a)
;     else false
 
(DEFUN |bpBracket| (|f|)
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| |$stok|)
      (COND
       ((|bpEqKey| 'OBRACK)
        (COND
         ((AND (APPLY |f| NIL) (OR (|bpEqKey| 'CBRACK) (|bpBrackTrap| |a|)))
          (|bpPush| (|bfBracket| (|bpPop1|))))
         ((|bpEqKey| 'CBRACK) (|bpPush| NIL)) (#1='T (|bpBrackTrap| |a|))))
       (#1# NIL))))))
 
; bpPileBracketed f==
;               if bpEqKey "SETTAB"
;               then if bpEqKey "BACKTAB"
;                    then true
;                    else if APPLY(f,nil) and
;                             (bpEqKey "BACKTAB" or bpPileTrap())
;                         then bpPush bfPile bpPop1()
;                         else false
;               else false
 
(DEFUN |bpPileBracketed| (|f|)
  (PROG ()
    (RETURN
     (COND
      ((|bpEqKey| 'SETTAB)
       (COND ((|bpEqKey| 'BACKTAB) T)
             ((AND (APPLY |f| NIL) (OR (|bpEqKey| 'BACKTAB) (|bpPileTrap|)))
              (|bpPush| (|bfPile| (|bpPop1|))))
             (#1='T NIL)))
      (#1# NIL)))))
 
; bpListof(f,str1,g)==
;     if APPLY(f,nil)
;     then
;         if bpEqKey str1 and (APPLY(f,nil) or bpTrap())
;         then
;           a:=$stack
;           $stack:=nil
;           while bpEqKey str1 and (APPLY(f,nil) or bpTrap()) repeat 0
;           $stack:=cons(NREVERSE $stack,a)
;           bpPush FUNCALL(g, [bpPop3(),bpPop2(),:bpPop1()])
;         else
;           true
;     else false
 
(DEFUN |bpListof| (|f| |str1| |g|)
  (PROG (|a|)
    (RETURN
     (COND
      ((APPLY |f| NIL)
       (COND
        ((AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|)))
         (SETQ |a| |$stack|) (SETQ |$stack| NIL)
         ((LAMBDA ()
            (LOOP
             (COND
              ((NOT (AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|))))
               (RETURN NIL))
              (#1='T 0)))))
         (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
         (|bpPush|
          (FUNCALL |g| (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|))))))
        (#1# T)))
      (#1# NIL)))))
 
; bpListofFun(f,h,g)==
;     if APPLY(f,nil)
;     then
;         if APPLY(h,nil) and (APPLY(f,nil) or bpTrap())
;         then
;           a:=$stack
;           $stack:=nil
;           while APPLY(h,nil) and (APPLY(f,nil) or bpTrap()) repeat 0
;           $stack:=cons(NREVERSE $stack,a)
;           bpPush FUNCALL(g, bfListOf [bpPop3(),bpPop2(),:bpPop1()])
;         else
;           true
;     else false
 
(DEFUN |bpListofFun| (|f| |h| |g|)
  (PROG (|a|)
    (RETURN
     (COND
      ((APPLY |f| NIL)
       (COND
        ((AND (APPLY |h| NIL) (OR (APPLY |f| NIL) (|bpTrap|)))
         (SETQ |a| |$stack|) (SETQ |$stack| NIL)
         ((LAMBDA ()
            (LOOP
             (COND
              ((NOT (AND (APPLY |h| NIL) (OR (APPLY |f| NIL) (|bpTrap|))))
               (RETURN NIL))
              (#1='T 0)))))
         (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
         (|bpPush|
          (FUNCALL |g|
                   (|bfListOf|
                    (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|)))))))
        (#1# T)))
      (#1# NIL)))))
 
; bpList(f,str1,g)==
;     if APPLY(f,nil)
;     then
;         if bpEqKey str1 and (APPLY(f,nil) or bpTrap())
;         then
;           a:=$stack
;           $stack:=nil
;           while bpEqKey str1 and (APPLY(f,nil) or bpTrap()) repeat 0
;           $stack:=cons(NREVERSE $stack,a)
;           bpPush FUNCALL(g,  [bpPop3(),bpPop2(),:bpPop1()])
;         else
;           bpPush FUNCALL(g, [bpPop1()])
;     else bpPush FUNCALL(g, [])
 
(DEFUN |bpList| (|f| |str1| |g|)
  (PROG (|a|)
    (RETURN
     (COND
      ((APPLY |f| NIL)
       (COND
        ((AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|)))
         (SETQ |a| |$stack|) (SETQ |$stack| NIL)
         ((LAMBDA ()
            (LOOP
             (COND
              ((NOT (AND (|bpEqKey| |str1|) (OR (APPLY |f| NIL) (|bpTrap|))))
               (RETURN NIL))
              (#1='T 0)))))
         (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
         (|bpPush|
          (FUNCALL |g| (CONS (|bpPop3|) (CONS (|bpPop2|) (|bpPop1|))))))
        (#1# (|bpPush| (FUNCALL |g| (LIST (|bpPop1|)))))))
      (#1# (|bpPush| (FUNCALL |g| NIL)))))))
 
; bpOneOrMore f==
;        APPLY(f,nil)=>
;          a:=$stack
;          $stack:=nil
;          while APPLY(f,nil) repeat 0
;          $stack:=cons(NREVERSE $stack,a)
;          bpPush cons(bpPop2(),bpPop1())
;        false
 
(DEFUN |bpOneOrMore| (|f|)
  (PROG (|a|)
    (RETURN
     (COND
      ((APPLY |f| NIL)
       (PROGN
        (SETQ |a| |$stack|)
        (SETQ |$stack| NIL)
        ((LAMBDA ()
           (LOOP (COND ((NOT (APPLY |f| NIL)) (RETURN NIL)) (#1='T 0)))))
        (SETQ |$stack| (CONS (NREVERSE |$stack|) |a|))
        (|bpPush| (CONS (|bpPop2|) (|bpPop1|)))))
      (#1# NIL)))))
 
; bpAnyNo s==
;      while APPLY(s,nil) repeat 0
;      true
 
(DEFUN |bpAnyNo| (|s|)
  (PROG #1=()
    (RETURN
     (PROGN
      ((LAMBDA #1# (LOOP (COND ((NOT (APPLY |s| NIL)) (RETURN NIL)) ('T 0)))))
      T))))
 
; bpAndOr(keyword,p,f)==
;    bpEqKey keyword and (APPLY(p,nil) or bpTrap())
;           and bpPush FUNCALL(f, bpPop1())
 
(DEFUN |bpAndOr| (|keyword| |p| |f|)
  (PROG ()
    (RETURN
     (AND (|bpEqKey| |keyword|) (OR (APPLY |p| NIL) (|bpTrap|))
          (|bpPush| (FUNCALL |f| (|bpPop1|)))))))
 
; bpConditional f==
;   if  bpEqKey "IF" and (bpWhere() or bpTrap()) and
;                    (bpEqKey "BACKSET" or true)
;   then
;            if bpEqKey "SETTAB"
;            then if bpEqKey "THEN"
;                 then  (APPLY(f,nil) or bpTrap()) and bpElse(f) and bpEqKey "BACKTAB"
;                 else  bpMissing "THEN"
;            else if bpEqKey "THEN"
;                 then (APPLY(f,nil) or bpTrap()) and bpElse(f)
;                 else bpMissing "then"
;   else false
 
(DEFUN |bpConditional| (|f|)
  (PROG ()
    (RETURN
     (COND
      ((AND (|bpEqKey| 'IF) (OR (|bpWhere|) (|bpTrap|))
            (OR (|bpEqKey| 'BACKSET) T))
       (COND
        ((|bpEqKey| 'SETTAB)
         (COND
          ((|bpEqKey| 'THEN)
           (AND (OR (APPLY |f| NIL) (|bpTrap|)) (|bpElse| |f|)
                (|bpEqKey| 'BACKTAB)))
          (#1='T (|bpMissing| 'THEN))))
        ((|bpEqKey| 'THEN)
         (AND (OR (APPLY |f| NIL) (|bpTrap|)) (|bpElse| |f|)))
        (#1# (|bpMissing| '|then|))))
      (#1# NIL)))))
 
; bpElse(f)==
;            a:=bpState()
;            if bpBacksetElse()
;            then  (APPLY(f,nil) or bpTrap()) and
;                  bpPush bfIf(bpPop3(),bpPop2(),bpPop1())
;            else
;               bpRestore a
;               bpPush bfIfThenOnly(bpPop2(),bpPop1())
 
(DEFUN |bpElse| (|f|)
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (|bpState|))
      (COND
       ((|bpBacksetElse|)
        (AND (OR (APPLY |f| NIL) (|bpTrap|))
             (|bpPush| (|bfIf| (|bpPop3|) (|bpPop2|) (|bpPop1|)))))
       ('T (|bpRestore| |a|)
        (|bpPush| (|bfIfThenOnly| (|bpPop2|) (|bpPop1|)))))))))
 
; bpBacksetElse()==
;     if bpEqKey "BACKSET"
;     then bpEqKey "ELSE"
;     else bpEqKey "ELSE"
 
(DEFUN |bpBacksetElse| #1=()
  (PROG #1#
    (RETURN
     (COND ((|bpEqKey| 'BACKSET) (|bpEqKey| 'ELSE)) ('T (|bpEqKey| 'ELSE))))))
 
; bpEqPeek s ==  EQCAR($stok,"KEY") and EQ(s,$ttok)
 
(DEFUN |bpEqPeek| (|s|)
  (PROG () (RETURN (AND (EQCAR |$stok| 'KEY) (EQ |s| |$ttok|)))))
 
; bpEqKey s ==   EQCAR($stok,"KEY") and EQ(s,$ttok) and bpNext()
 
(DEFUN |bpEqKey| (|s|)
  (PROG () (RETURN (AND (EQCAR |$stok| 'KEY) (EQ |s| |$ttok|) (|bpNext|)))))
 
; bpEqKeyNextTok s ==   EQCAR($stok,"KEY") and EQ(s,$ttok) and
;                   bpNextToken()
 
(DEFUN |bpEqKeyNextTok| (|s|)
  (PROG ()
    (RETURN (AND (EQCAR |$stok| 'KEY) (EQ |s| |$ttok|) (|bpNextToken|)))))
 
; bpPileTrap()   == bpMissing  "BACKTAB"
 
(DEFUN |bpPileTrap| #1=() (PROG #1# (RETURN (|bpMissing| 'BACKTAB))))
 
; bpBrackTrap(x) == bpMissingMate("]",x)
 
(DEFUN |bpBrackTrap| (|x|) (PROG () (RETURN (|bpMissingMate| '] |x|))))
 
; bpParenTrap(x) == bpMissingMate(")",x)
 
(DEFUN |bpParenTrap| (|x|) (PROG () (RETURN (|bpMissingMate| '|)| |x|))))
 
; bpMissingMate(close,open)==
;    bpSpecificErrorAtToken(open, '"possibly missing mate")
;    bpMissing close
 
(DEFUN |bpMissingMate| (|close| |open|)
  (PROG ()
    (RETURN
     (PROGN
      (|bpSpecificErrorAtToken| |open| "possibly missing mate")
      (|bpMissing| |close|)))))
 
; bpMissing s==
;    bpSpecificErrorHere(CONCAT(PNAME s,'" possibly missing"))
;    THROW("TRAPPOINT","TRAPPED")
 
(DEFUN |bpMissing| (|s|)
  (PROG ()
    (RETURN
     (PROGN
      (|bpSpecificErrorHere| (CONCAT (PNAME |s|) " possibly missing"))
      (THROW 'TRAPPOINT 'TRAPPED)))))
 
; bpCompMissing s == bpEqKey s or bpMissing s
 
(DEFUN |bpCompMissing| (|s|)
  (PROG () (RETURN (OR (|bpEqKey| |s|) (|bpMissing| |s|)))))
 
; bpTrap()==
;    bpGeneralErrorHere()
;    THROW("TRAPPOINT","TRAPPED")
 
(DEFUN |bpTrap| #1=()
  (PROG #1#
    (RETURN (PROGN (|bpGeneralErrorHere|) (THROW 'TRAPPOINT 'TRAPPED)))))
 
; bpRecoverTrap()==
;   bpFirstToken()
;   pos1 := shoeTokPosn $stok
;   bpMoveTo 0
;   pos2 := shoeTokPosn $stok
;   bpIgnoredFromTo(pos1, pos2)
;   bpPush  [['"pile syntax error"]]
 
(DEFUN |bpRecoverTrap| ()
  (PROG (|pos2| |pos1|)
    (RETURN
     (PROGN
      (|bpFirstToken|)
      (SETQ |pos1| (|shoeTokPosn| |$stok|))
      (|bpMoveTo| 0)
      (SETQ |pos2| (|shoeTokPosn| |$stok|))
      (|bpIgnoredFromTo| |pos1| |pos2|)
      (|bpPush| (LIST (LIST "pile syntax error")))))))
 
; bpListAndRecover(f)==
;    a:=$stack
;    b:=nil
;    $stack:=nil
;    done:=false
;    c:=$inputStream
;    while not done repeat
; --   $trapped:local:=false
;      found:=CATCH("TRAPPOINT",APPLY(f,nil))
;      if found="TRAPPED"
;      then
;         $inputStream:=c
;         bpRecoverTrap()
;      else if not found
;           then
;             $inputStream:=c
;             bpGeneralErrorHere()
;             bpRecoverTrap()
;      if bpEqKey "BACKSET"
;      then
;         c:=$inputStream
;      else if bpEqPeek "BACKTAB"  or null $inputStream
;           then
;              done:=true
;           else
;             $inputStream:=c
;             bpGeneralErrorHere()
;             bpRecoverTrap()
;             if bpEqPeek "BACKTAB"  or null $inputStream
;             then done:=true
;             else
;                 bpNext()
;                 c:=$inputStream
;      b:=cons(bpPop1(),b)
;    $stack:=a
;    bpPush NREVERSE b
 
(DEFUN |bpListAndRecover| (|f|)
  (PROG (|a| |b| |done| |c| |found|)
    (RETURN
     (PROGN
      (SETQ |a| |$stack|)
      (SETQ |b| NIL)
      (SETQ |$stack| NIL)
      (SETQ |done| NIL)
      (SETQ |c| |$inputStream|)
      ((LAMBDA ()
         (LOOP
          (COND (|done| (RETURN NIL))
                (#1='T
                 (PROGN
                  (SETQ |found| (CATCH 'TRAPPOINT (APPLY |f| NIL)))
                  (COND
                   ((EQ |found| 'TRAPPED) (SETQ |$inputStream| |c|)
                    (|bpRecoverTrap|))
                   ((NULL |found|) (SETQ |$inputStream| |c|)
                    (|bpGeneralErrorHere|) (|bpRecoverTrap|)))
                  (COND ((|bpEqKey| 'BACKSET) (SETQ |c| |$inputStream|))
                        ((OR (|bpEqPeek| 'BACKTAB) (NULL |$inputStream|))
                         (SETQ |done| T))
                        (#1# (SETQ |$inputStream| |c|) (|bpGeneralErrorHere|)
                         (|bpRecoverTrap|)
                         (COND
                          ((OR (|bpEqPeek| 'BACKTAB) (NULL |$inputStream|))
                           (SETQ |done| T))
                          (#1# (|bpNext|) (SETQ |c| |$inputStream|)))))
                  (SETQ |b| (CONS (|bpPop1|) |b|))))))))
      (SETQ |$stack| |a|)
      (|bpPush| (NREVERSE |b|))))))
 
; bpMoveTo n==
;      null $inputStream  => true
;      bpEqPeek "BACKTAB" =>
;                 n=0  => true
;                 bpNextToken()
;                 $bpCount:=$bpCount-1
;                 bpMoveTo(n-1)
;      bpEqPeek "BACKSET" =>
;                 n=0  => true
;                 bpNextToken()
;                 bpMoveTo n
;      bpEqPeek "SETTAB"  =>
;                 bpNextToken()
;                 bpMoveTo(n+1)
;      bpEqPeek "OPAREN"  =>
;                 bpNextToken()
;                 $bpParenCount:=$bpParenCount+1
;                 bpMoveTo n
;      bpEqPeek "CPAREN"  =>
;                 bpNextToken()
;                 $bpParenCount:=$bpParenCount-1
;                 bpMoveTo n
;      bpNextToken()
;      bpMoveTo n
 
(DEFUN |bpMoveTo| (|n|)
  (PROG ()
    (RETURN
     (COND ((NULL |$inputStream|) T)
           ((|bpEqPeek| 'BACKTAB)
            (COND ((EQL |n| 0) T)
                  (#1='T
                   (PROGN
                    (|bpNextToken|)
                    (SETQ |$bpCount| (- |$bpCount| 1))
                    (|bpMoveTo| (- |n| 1))))))
           ((|bpEqPeek| 'BACKSET)
            (COND ((EQL |n| 0) T)
                  (#1# (PROGN (|bpNextToken|) (|bpMoveTo| |n|)))))
           ((|bpEqPeek| 'SETTAB)
            (PROGN (|bpNextToken|) (|bpMoveTo| (+ |n| 1))))
           ((|bpEqPeek| 'OPAREN)
            (PROGN
             (|bpNextToken|)
             (SETQ |$bpParenCount| (+ |$bpParenCount| 1))
             (|bpMoveTo| |n|)))
           ((|bpEqPeek| 'CPAREN)
            (PROGN
             (|bpNextToken|)
             (SETQ |$bpParenCount| (- |$bpParenCount| 1))
             (|bpMoveTo| |n|)))
           (#1# (PROGN (|bpNextToken|) (|bpMoveTo| |n|)))))))
 
; bpSpecificErrorAtToken(tok, key) ==
;      a:=shoeTokPosn tok
;      SoftShoeError(a,key)
 
(DEFUN |bpSpecificErrorAtToken| (|tok| |key|)
  (PROG (|a|)
    (RETURN
     (PROGN (SETQ |a| (|shoeTokPosn| |tok|)) (|SoftShoeError| |a| |key|)))))
 
; bpGeneralErrorHere() ==  bpSpecificErrorHere('"syntax error")
 
(DEFUN |bpGeneralErrorHere| #1=()
  (PROG #1# (RETURN (|bpSpecificErrorHere| "syntax error"))))
 
; bpSpecificErrorHere(key) ==  bpSpecificErrorAtToken($stok, key)
 
(DEFUN |bpSpecificErrorHere| (|key|)
  (PROG () (RETURN (|bpSpecificErrorAtToken| |$stok| |key|))))
 
; bpName() ==
;         if EQCAR( $stok,"ID")
;         then
;            bpPushId()
;            bpNext()
;         else false
 
(DEFUN |bpName| #1=()
  (PROG #1#
    (RETURN (COND ((EQCAR |$stok| 'ID) (|bpPushId|) (|bpNext|)) ('T NIL)))))
 
; bpConstTok() ==
;      MEMQ(shoeTokType $stok, '(INTEGER FLOAT)) =>
;           bpPush $ttok
;           bpNext()
;      EQCAR($stok,"LISP")=> bpPush bfReadLisp $ttok and bpNext()
;      EQCAR($stok,"LISPEXP")=> bpPush $ttok and bpNext()
;      EQCAR($stok,"LINE")=> bpPush ["+LINE", $ttok] and bpNext()
;      bpEqPeek "QUOTE" =>
;           bpNext()
;           (bpSexp() or bpTrap()) and
;                bpPush bfSymbol bpPop1()
;      bpString()
 
(DEFUN |bpConstTok| #1=()
  (PROG #1#
    (RETURN
     (COND
      ((MEMQ (|shoeTokType| |$stok|) '(INTEGER FLOAT))
       (PROGN (|bpPush| |$ttok|) (|bpNext|)))
      ((EQCAR |$stok| 'LISP)
       (AND (|bpPush| (|bfReadLisp| |$ttok|)) (|bpNext|)))
      ((EQCAR |$stok| 'LISPEXP) (AND (|bpPush| |$ttok|) (|bpNext|)))
      ((EQCAR |$stok| 'LINE) (AND (|bpPush| (LIST '+LINE |$ttok|)) (|bpNext|)))
      ((|bpEqPeek| 'QUOTE)
       (PROGN
        (|bpNext|)
        (AND (OR (|bpSexp|) (|bpTrap|)) (|bpPush| (|bfSymbol| (|bpPop1|))))))
      ('T (|bpString|))))))
 
; bpCancel()==
;     a:=bpState()
;     if bpEqKeyNextTok  "SETTAB"
;     then if bpCancel()
;          then  if bpEqKeyNextTok  "BACKTAB"
;                then true
;                else
;                    bpRestore a
;                    false
;          else
;            if bpEqKeyNextTok "BACKTAB"
;            then true
;            else
;               bpRestore a
;               false
;     else false
 
(DEFUN |bpCancel| ()
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (|bpState|))
      (COND
       ((|bpEqKeyNextTok| 'SETTAB)
        (COND
         ((|bpCancel|)
          (COND ((|bpEqKeyNextTok| 'BACKTAB) T) (#1='T (|bpRestore| |a|) NIL)))
         ((|bpEqKeyNextTok| 'BACKTAB) T) (#1# (|bpRestore| |a|) NIL)))
       (#1# NIL))))))
 
; bpAddTokens n==
;          n=0 => nil
;          n>0=> cons(shoeTokConstruct("KEY","SETTAB",shoeTokPosn $stok),bpAddTokens(n-1))
;          cons(shoeTokConstruct("KEY","BACKTAB",shoeTokPosn $stok),bpAddTokens(n+1))
 
(DEFUN |bpAddTokens| (|n|)
  (PROG ()
    (RETURN
     (COND ((EQL |n| 0) NIL)
           ((< 0 |n|)
            (CONS (|shoeTokConstruct| 'KEY 'SETTAB (|shoeTokPosn| |$stok|))
                  (|bpAddTokens| (- |n| 1))))
           ('T
            (CONS (|shoeTokConstruct| 'KEY 'BACKTAB (|shoeTokPosn| |$stok|))
                  (|bpAddTokens| (+ |n| 1))))))))
 
; bpExceptions()==
;      bpEqPeek "DOT" or bpEqPeek "QUOTE" or
;           bpEqPeek "OPAREN" or bpEqPeek "CPAREN" or
;              bpEqPeek "SETTAB" or bpEqPeek "BACKTAB"
;                 or bpEqPeek "BACKSET"
 
(DEFUN |bpExceptions| #1=()
  (PROG #1#
    (RETURN
     (OR (|bpEqPeek| 'DOT) (|bpEqPeek| 'QUOTE) (|bpEqPeek| 'OPAREN)
         (|bpEqPeek| 'CPAREN) (|bpEqPeek| 'SETTAB) (|bpEqPeek| 'BACKTAB)
         (|bpEqPeek| 'BACKSET)))))
 
; bpSexpKey()==
;       EQCAR( $stok,"KEY") and not bpExceptions()=>
;                a:=GET($ttok,"SHOEINF")
;                null a=>  bpPush $ttok and bpNext()
;                bpPush a and bpNext()
;       false
 
(DEFUN |bpSexpKey| ()
  (PROG (|a|)
    (RETURN
     (COND
      ((AND (EQCAR |$stok| 'KEY) (NULL (|bpExceptions|)))
       (PROGN
        (SETQ |a| (GET |$ttok| 'SHOEINF))
        (COND ((NULL |a|) (AND (|bpPush| |$ttok|) (|bpNext|)))
              (#1='T (AND (|bpPush| |a|) (|bpNext|))))))
      (#1# NIL)))))
 
; bpAnyId()==
;   bpEqKey "MINUS"  and (EQCAR($stok,"INTEGER") or bpTrap()) and
;           bpPush MINUS $ttok and bpNext() or
;              bpSexpKey() or
;                    MEMQ(shoeTokType $stok, '(ID INTEGER STRING FLOAT))
;                       and  bpPush $ttok and  bpNext()
 
(DEFUN |bpAnyId| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (|bpEqKey| 'MINUS) (OR (EQCAR |$stok| 'INTEGER) (|bpTrap|))
           (|bpPush| (- |$ttok|)) (|bpNext|))
      (|bpSexpKey|)
      (AND (MEMQ (|shoeTokType| |$stok|) '(ID INTEGER STRING FLOAT))
           (|bpPush| |$ttok|) (|bpNext|))))))
 
; bpSexp()==
;     bpAnyId() or
;         bpEqKey "QUOTE"  and  (bpSexp() or bpTrap())
;            and bpPush bfSymbol bpPop1() or
;                bpIndentParenthesized function bpSexp1
 
(DEFUN |bpSexp| #1=()
  (PROG #1#
    (RETURN
     (OR (|bpAnyId|)
         (AND (|bpEqKey| 'QUOTE) (OR (|bpSexp|) (|bpTrap|))
              (|bpPush| (|bfSymbol| (|bpPop1|))))
         (|bpIndentParenthesized| #'|bpSexp1|)))))
 
; bpSexp1()== bpFirstTok() and
;     bpSexp() and
;      (bpEqKey "DOT" and bpSexp() and bpPush CONS (bpPop2(),bpPop1())or
;            bpSexp1() and bpPush CONS (bpPop2(),bpPop1())) or
;                bpPush nil
 
(DEFUN |bpSexp1| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (|bpFirstTok|) (|bpSexp|)
           (OR
            (AND (|bpEqKey| 'DOT) (|bpSexp|)
                 (|bpPush| (CONS (|bpPop2|) (|bpPop1|))))
            (AND (|bpSexp1|) (|bpPush| (CONS (|bpPop2|) (|bpPop1|))))))
      (|bpPush| NIL)))))
 
; bpPrimary1() ==
;    bpName() or
;     bpDot() or
;       bpConstTok() or
;        bpConstruct() or
;         bpCase() or
;          bpStruct() or
;           bpPDefinition() or
;            bpBPileDefinition()
 
(DEFUN |bpPrimary1| #1=()
  (PROG #1#
    (RETURN
     (OR (|bpName|) (|bpDot|) (|bpConstTok|) (|bpConstruct|) (|bpCase|)
         (|bpStruct|) (|bpPDefinition|) (|bpBPileDefinition|)))))
 
; bpPrimary()==  bpFirstTok() and (bpPrimary1() or bpPrefixOperator())
 
(DEFUN |bpPrimary| #1=()
  (PROG #1#
    (RETURN (AND (|bpFirstTok|) (OR (|bpPrimary1|) (|bpPrefixOperator|))))))
 
; bpDot()== bpEqKey "DOT" and bpPush bfDot ()
 
(DEFUN |bpDot| #1=()
  (PROG #1# (RETURN (AND (|bpEqKey| 'DOT) (|bpPush| (|bfDot|))))))
 
; bpPrefixOperator()==
;    EQCAR( $stok,"KEY") and
;      GET($ttok,"SHOEPRE") and bpPushId() and  bpNext()
 
(DEFUN |bpPrefixOperator| #1=()
  (PROG #1#
    (RETURN
     (AND (EQCAR |$stok| 'KEY) (GET |$ttok| 'SHOEPRE) (|bpPushId|)
          (|bpNext|)))))
 
; bpInfixOperator()==
;   EQCAR( $stok,"KEY") and
;     GET($ttok,"SHOEINF") and bpPushId() and  bpNext()
 
(DEFUN |bpInfixOperator| #1=()
  (PROG #1#
    (RETURN
     (AND (EQCAR |$stok| 'KEY) (GET |$ttok| 'SHOEINF) (|bpPushId|)
          (|bpNext|)))))
 
; bpSelector()==
;             bpEqKey "DOT" and (bpPrimary()
;                and bpPush(bfElt(bpPop2(),bpPop1()))
;                   or bpPush bfSuffixDot bpPop1() )
 
(DEFUN |bpSelector| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpEqKey| 'DOT)
          (OR (AND (|bpPrimary|) (|bpPush| (|bfElt| (|bpPop2|) (|bpPop1|))))
              (|bpPush| (|bfSuffixDot| (|bpPop1|))))))))
 
; bpOperator()==   bpPrimary() and bpAnyNo function bpSelector
 
(DEFUN |bpOperator| #1=()
  (PROG #1# (RETURN (AND (|bpPrimary|) (|bpAnyNo| #'|bpSelector|)))))
 
; bpApplication()==
;    bpPrimary() and bpAnyNo function bpSelector and
;       (bpApplication() and
;             bpPush(bfApplication(bpPop2(),bpPop1())) or true)
 
(DEFUN |bpApplication| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpPrimary|) (|bpAnyNo| #'|bpSelector|)
          (OR
           (AND (|bpApplication|)
                (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|))))
           T)))))
 
; bpTagged()==
;       bpApplication() and
;          (bpEqKey "COLON" and (bpApplication() or bpTrap()) and
;            bpPush bfTagged(bpPop2(),bpPop1()) or true)
 
(DEFUN |bpTagged| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpApplication|)
          (OR
           (AND (|bpEqKey| 'COLON) (OR (|bpApplication|) (|bpTrap|))
                (|bpPush| (|bfTagged| (|bpPop2|) (|bpPop1|))))
           T)))))
 
; bpExpt()== bpRightAssoc('(POWER),function bpTagged)
 
(DEFUN |bpExpt| #1=()
  (PROG #1# (RETURN (|bpRightAssoc| '(POWER) #'|bpTagged|))))
 
; bpInfKey s==
;  EQCAR( $stok,"KEY") and
;    MEMBER($ttok,s) and bpPushId() and bpNext()
 
(DEFUN |bpInfKey| (|s|)
  (PROG ()
    (RETURN
     (AND (EQCAR |$stok| 'KEY) (MEMBER |$ttok| |s|) (|bpPushId|) (|bpNext|)))))
 
; bpInfGeneric s== bpInfKey s and  (bpEqKey "BACKSET" or true)
 
(DEFUN |bpInfGeneric| (|s|)
  (PROG () (RETURN (AND (|bpInfKey| |s|) (OR (|bpEqKey| 'BACKSET) T)))))
 
; bpRightAssoc(o,p)==
;     a:=bpState()
;     if APPLY(p,nil)
;     then
;        while  bpInfGeneric o and (bpRightAssoc(o,p) or bpTrap()) repeat
;              bpPush bfInfApplication(bpPop2(),bpPop2(),bpPop1())
;        true
;     else
;        bpRestore a
;        false
 
(DEFUN |bpRightAssoc| (|o| |p|)
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (|bpState|))
      (COND
       ((APPLY |p| NIL)
        ((LAMBDA ()
           (LOOP
            (COND
             ((NOT
               (AND (|bpInfGeneric| |o|)
                    (OR (|bpRightAssoc| |o| |p|) (|bpTrap|))))
              (RETURN NIL))
             (#1='T
              (|bpPush|
               (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|))))))))
        T)
       (#1# (|bpRestore| |a|) NIL))))))
 
; bpLeftAssoc(operations,parser)==
;     if APPLY(parser,nil)
;     then
;        while bpInfGeneric(operations) and
;          (APPLY(parser,nil) or bpTrap())
;            repeat
;              bpPush bfInfApplication(bpPop2(),bpPop2(),bpPop1())
;        true
;     else false
 
(DEFUN |bpLeftAssoc| (|operations| |parser|)
  (PROG #1=()
    (RETURN
     (COND
      ((APPLY |parser| NIL)
       ((LAMBDA #1#
          (LOOP
           (COND
            ((NOT
              (AND (|bpInfGeneric| |operations|)
                   (OR (APPLY |parser| NIL) (|bpTrap|))))
             (RETURN NIL))
            (#2='T
             (|bpPush|
              (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|))))))))
       T)
      (#2# NIL)))))
 
; bpString()==
;      EQ(shoeTokType $stok,"STRING") and
;          bpPush(["QUOTE",INTERN $ttok]) and bpNext()
 
(DEFUN |bpString| #1=()
  (PROG #1#
    (RETURN
     (AND (EQ (|shoeTokType| |$stok|) 'STRING)
          (|bpPush| (LIST 'QUOTE (INTERN |$ttok|))) (|bpNext|)))))
 
; bpThetaName() ==
;         if EQCAR( $stok,"ID") and GET($ttok,"SHOETHETA")
;         then
;            bpPushId()
;            bpNext()
;         else false
 
(DEFUN |bpThetaName| #1=()
  (PROG #1#
    (RETURN
     (COND
      ((AND (EQCAR |$stok| 'ID) (GET |$ttok| 'SHOETHETA)) (|bpPushId|)
       (|bpNext|))
      ('T NIL)))))
 
; bpReduceOperator()==
;          bpInfixOperator() or bpString()
;                 or bpThetaName()
 
(DEFUN |bpReduceOperator| #1=()
  (PROG #1# (RETURN (OR (|bpInfixOperator|) (|bpString|) (|bpThetaName|)))))
 
; bpReduce()==
;      a:=bpState()
;      if bpReduceOperator() and bpEqKey "SLASH"
;      then
;         bpEqPeek "OBRACK" => (bpDConstruct() or bpTrap()) and
;                      bpPush bfReduceCollect(bpPop2(),bpPop1())
;         (bpApplication() or bpTrap()) and
;                 bpPush bfReduce(bpPop2(),bpPop1())
;      else
;         bpRestore a
;         false
 
(DEFUN |bpReduce| ()
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (|bpState|))
      (COND
       ((AND (|bpReduceOperator|) (|bpEqKey| 'SLASH))
        (COND
         ((|bpEqPeek| 'OBRACK)
          (AND (OR (|bpDConstruct|) (|bpTrap|))
               (|bpPush| (|bfReduceCollect| (|bpPop2|) (|bpPop1|)))))
         (#1='T
          (AND (OR (|bpApplication|) (|bpTrap|))
               (|bpPush| (|bfReduce| (|bpPop2|) (|bpPop1|)))))))
       (#1# (|bpRestore| |a|) NIL))))))
 
; bpTimes()==
;     bpReduce() or bpLeftAssoc('(TIMES  SLASH),function bpExpt)
 
(DEFUN |bpTimes| #1=()
  (PROG #1#
    (RETURN (OR (|bpReduce|) (|bpLeftAssoc| '(TIMES SLASH) #'|bpExpt|)))))
 
; bpMinus()==
;    bpInfGeneric '(MINUS) and (bpTimes() or bpTrap())
;         and bpPush(bfApplication(bpPop2(),bpPop1()))
;           or bpTimes()
 
(DEFUN |bpMinus| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (|bpInfGeneric| '(MINUS)) (OR (|bpTimes|) (|bpTrap|))
           (|bpPush| (|bfApplication| (|bpPop2|) (|bpPop1|))))
      (|bpTimes|)))))
 
; bpArith()==bpLeftAssoc('(PLUS MINUS),function bpMinus)
 
(DEFUN |bpArith| #1=()
  (PROG #1# (RETURN (|bpLeftAssoc| '(PLUS MINUS) #'|bpMinus|))))
 
; bpIs()==
;      bpArith() and (bpInfKey '(IS ISNT) and (bpPattern() or bpTrap())
;         and bpPush bfISApplication(bpPop2(),bpPop2(),bpPop1())
;            or true)
 
(DEFUN |bpIs| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpArith|)
          (OR
           (AND (|bpInfKey| '(IS ISNT)) (OR (|bpPattern|) (|bpTrap|))
                (|bpPush|
                 (|bfISApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|))))
           T)))))
 
; bpBracketConstruct(f)==
;         bpBracket f and bpPush bfConstruct bpPop1 ()
 
(DEFUN |bpBracketConstruct| (|f|)
  (PROG ()
    (RETURN (AND (|bpBracket| |f|) (|bpPush| (|bfConstruct| (|bpPop1|)))))))
 
; bpCompare()==
;      bpIs() and (bpInfKey  '(SHOEEQ SHOENE LT LE GT GE IN)
;         and (bpIs() or bpTrap())
;            and bpPush bfInfApplication(bpPop2(),bpPop2(),bpPop1())
;                or true)
 
(DEFUN |bpCompare| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpIs|)
          (OR
           (AND (|bpInfKey| '(SHOEEQ SHOENE LT LE GT GE IN))
                (OR (|bpIs|) (|bpTrap|))
                (|bpPush|
                 (|bfInfApplication| (|bpPop2|) (|bpPop2|) (|bpPop1|))))
           T)))))
 
; bpAnd()== bpLeftAssoc('(AND),function bpCompare)
 
(DEFUN |bpAnd| #1=() (PROG #1# (RETURN (|bpLeftAssoc| '(AND) #'|bpCompare|))))
 
; bpReturn()==
;          (bpEqKey "RETURN" and
;            (bpAnd() or bpTrap()) and
;                 bpPush bfReturnNoName bpPop1()) or bpAnd()
 
(DEFUN |bpReturn| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (|bpEqKey| 'RETURN) (OR (|bpAnd|) (|bpTrap|))
           (|bpPush| (|bfReturnNoName| (|bpPop1|))))
      (|bpAnd|)))))
 
; bpLogical()== bpLeftAssoc('(OR),function bpReturn)
 
(DEFUN |bpLogical| #1=() (PROG #1# (RETURN (|bpLeftAssoc| '(OR) #'|bpReturn|))))
 
; bpExpression()==
;      bpEqKey "COLON" and (bpLogical() and
;               bpPush bfApplication ("COLON",bpPop1())
;                     or bpTrap()) or bpLogical()
 
(DEFUN |bpExpression| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (|bpEqKey| 'COLON)
           (OR
            (AND (|bpLogical|) (|bpPush| (|bfApplication| 'COLON (|bpPop1|))))
            (|bpTrap|)))
      (|bpLogical|)))))
 
; bpStatement()==
;   bpConditional function bpWhere or bpLoop()  or bpExpression()
 
(DEFUN |bpStatement| #1=()
  (PROG #1#
    (RETURN (OR (|bpConditional| #'|bpWhere|) (|bpLoop|) (|bpExpression|)))))
 
; bpLoop()==
;      bpIterators() and
;       (bpCompMissing "REPEAT" and
;          (bpWhere() or bpTrap()) and
;             bpPush bfLp(bpPop2(),bpPop1()))
;                 or
;                   bpEqKey "REPEAT" and (bpLogical() or bpTrap()) and
;                        bpPush bfLoop1 bpPop1 ()
 
(DEFUN |bpLoop| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (|bpIterators|) (|bpCompMissing| 'REPEAT)
           (OR (|bpWhere|) (|bpTrap|))
           (|bpPush| (|bfLp| (|bpPop2|) (|bpPop1|))))
      (AND (|bpEqKey| 'REPEAT) (OR (|bpLogical|) (|bpTrap|))
           (|bpPush| (|bfLoop1| (|bpPop1|))))))))
 
; bpSuchThat()==bpAndOr("BAR",function bpWhere,function bfSuchthat)
 
(DEFUN |bpSuchThat| #1=()
  (PROG #1# (RETURN (|bpAndOr| 'BAR #'|bpWhere| #'|bfSuchthat|))))
 
; bpWhile()==bpAndOr ("WHILE",function bpLogical,function bfWhile)
 
(DEFUN |bpWhile| #1=()
  (PROG #1# (RETURN (|bpAndOr| 'WHILE #'|bpLogical| #'|bfWhile|))))
 
; bpUntil()==bpAndOr ("UNTIL",function bpLogical,function bfUntil)
 
(DEFUN |bpUntil| #1=()
  (PROG #1# (RETURN (|bpAndOr| 'UNTIL #'|bpLogical| #'|bfUntil|))))
 
; bpForIn()==
;   bpEqKey "FOR" and (bpVariable() or bpTrap()) and (bpCompMissing "IN")
;       and ((bpSeg()  or bpTrap()) and
;        (bpEqKey "BY" and (bpArith() or bpTrap()) and
;         bpPush bfForInBy(bpPop3(),bpPop2(),bpPop1())) or
;          bpPush bfForin(bpPop2(),bpPop1()))
 
(DEFUN |bpForIn| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpEqKey| 'FOR) (OR (|bpVariable|) (|bpTrap|)) (|bpCompMissing| 'IN)
          (OR
           (AND (OR (|bpSeg|) (|bpTrap|)) (|bpEqKey| 'BY)
                (OR (|bpArith|) (|bpTrap|))
                (|bpPush| (|bfForInBy| (|bpPop3|) (|bpPop2|) (|bpPop1|))))
           (|bpPush| (|bfForin| (|bpPop2|) (|bpPop1|))))))))
 
; bpSeg()==
;    bpArith() and
;       (bpEqKey "SEG" and
;        (bpArith() and bpPush(bfSegment2(bpPop2(),bpPop1()))
;          or bpPush(bfSegment1(bpPop1()))) or true)
 
(DEFUN |bpSeg| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpArith|)
          (OR
           (AND (|bpEqKey| 'SEG)
                (OR
                 (AND (|bpArith|)
                      (|bpPush| (|bfSegment2| (|bpPop2|) (|bpPop1|))))
                 (|bpPush| (|bfSegment1| (|bpPop1|)))))
           T)))))
 
; bpIterator()==
;   bpForIn() or bpSuchThat() or bpWhile() or bpUntil()
 
(DEFUN |bpIterator| #1=()
  (PROG #1# (RETURN (OR (|bpForIn|) (|bpSuchThat|) (|bpWhile|) (|bpUntil|)))))
 
; bpIteratorList()==bpOneOrMore function bpIterator
;        and bpPush bfIterators bpPop1 ()
 
(DEFUN |bpIteratorList| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpOneOrMore| #'|bpIterator|)
          (|bpPush| (|bfIterators| (|bpPop1|)))))))
 
; bpCrossBackSet()== bpEqKey "CROSS" and (bpEqKey "BACKSET" or true)
 
(DEFUN |bpCrossBackSet| #1=()
  (PROG #1# (RETURN (AND (|bpEqKey| 'CROSS) (OR (|bpEqKey| 'BACKSET) T)))))
 
; bpIterators()==
;          bpListofFun(function bpIteratorList,
;               function bpCrossBackSet,function bfCross)
 
(DEFUN |bpIterators| #1=()
  (PROG #1#
    (RETURN (|bpListofFun| #'|bpIteratorList| #'|bpCrossBackSet| #'|bfCross|))))
 
; bpAssign()==
;             a:=bpState()
;             if bpStatement()
;             then
;                  if bpEqPeek "BEC"
;                  then
;                    bpRestore a
;                    bpAssignment() or bpTrap()
;                  else true
;             else
;                  bpRestore a
;                  false
 
(DEFUN |bpAssign| ()
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (|bpState|))
      (COND
       ((|bpStatement|)
        (COND
         ((|bpEqPeek| 'BEC) (|bpRestore| |a|) (OR (|bpAssignment|) (|bpTrap|)))
         (#1='T T)))
       (#1# (|bpRestore| |a|) NIL))))))
 
; bpAssignment()==
;        bpAssignVariable() and
;          bpEqKey "BEC" and
;            (bpAssign() or bpTrap()) and
;               bpPush bfAssign (bpPop2(),bpPop1())
 
(DEFUN |bpAssignment| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpAssignVariable|) (|bpEqKey| 'BEC) (OR (|bpAssign|) (|bpTrap|))
          (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|)))))))
 
; bpExit()==
;      bpAssign() and (bpEqKey "EXIT" and
;          ((bpWhere() or bpTrap()) and
;             bpPush bfExit (bpPop2(),bpPop1()))
;               or true)
 
(DEFUN |bpExit| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpAssign|)
          (OR
           (AND (|bpEqKey| 'EXIT) (OR (|bpWhere|) (|bpTrap|))
                (|bpPush| (|bfExit| (|bpPop2|) (|bpPop1|))))
           T)))))
 
; bpDefinition()==
;         a:=bpState()
;         bpExit() =>
;              bpEqPeek "DEF" =>
;                 bpRestore a
;                 bpDef()
;              bpEqPeek "MDEF" =>
;                 bpRestore a
;                 bpMdef()
;              true
;         bpRestore a
;         false
 
(DEFUN |bpDefinition| ()
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (|bpState|))
      (COND
       ((|bpExit|)
        (COND ((|bpEqPeek| 'DEF) (PROGN (|bpRestore| |a|) (|bpDef|)))
              ((|bpEqPeek| 'MDEF) (PROGN (|bpRestore| |a|) (|bpMdef|)))
              (#1='T T)))
       (#1# (PROGN (|bpRestore| |a|) NIL)))))))
 
; bpStoreName()==
;          $op:=car $stack
;          $wheredefs:=nil
;          $typings:=nil
;          true
 
(DEFUN |bpStoreName| #1=()
  (PROG #1#
    (RETURN
     (PROGN
      (SETQ |$op| (CAR |$stack|))
      (SETQ |$wheredefs| NIL)
      (SETQ |$typings| NIL)
      T))))
 
; bpDef() ==  bpName() and bpStoreName()  and
;                bpDefTail() and bpPush bfCompDef bpPop1 ()
 
(DEFUN |bpDef| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpName|) (|bpStoreName|) (|bpDefTail|)
          (|bpPush| (|bfCompDef| (|bpPop1|)))))))
 
; bpDDef() ==  bpName() and bpDefTail()
 
(DEFUN |bpDDef| #1=() (PROG #1# (RETURN (AND (|bpName|) (|bpDefTail|)))))
 
; bpDefTail()==
;       bpEqKey "DEF" and
;         (bpWhere() or bpTrap())
;           and bpPush bfDefinition1(bpPop2(),bpPop1())
;            or
;              bpVariable()  and
;                bpEqKey "DEF" and (bpWhere() or bpTrap())
;                  and bpPush bfDefinition2(bpPop3(),bpPop2(),bpPop1())
 
(DEFUN |bpDefTail| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (|bpEqKey| 'DEF) (OR (|bpWhere|) (|bpTrap|))
           (|bpPush| (|bfDefinition1| (|bpPop2|) (|bpPop1|))))
      (AND (|bpVariable|) (|bpEqKey| 'DEF) (OR (|bpWhere|) (|bpTrap|))
           (|bpPush| (|bfDefinition2| (|bpPop3|) (|bpPop2|) (|bpPop1|))))))))
 
; bpMDefTail()==
;  --   bpEqKey "MDEF" and
;  --   (bpWhere() or bpTrap())
;  --     and bpPush bfMDefinition1(bpPop2(),bpPop1())
;  --      or
;            (bpVariable() or bpTrap()) and
;              bpEqKey "MDEF" and (bpWhere() or bpTrap())
;                  and bpPush bfMDefinition2(bpPop3(),bpPop2(),bpPop1())
 
(DEFUN |bpMDefTail| #1=()
  (PROG #1#
    (RETURN
     (AND (OR (|bpVariable|) (|bpTrap|)) (|bpEqKey| 'MDEF)
          (OR (|bpWhere|) (|bpTrap|))
          (|bpPush| (|bfMDefinition2| (|bpPop3|) (|bpPop2|) (|bpPop1|)))))))
 
; bpMdef()== bpName() and bpStoreName() and bpMDefTail()
 
(DEFUN |bpMdef| #1=()
  (PROG #1# (RETURN (AND (|bpName|) (|bpStoreName|) (|bpMDefTail|)))))
 
; bpWhere()==
;     bpDefinition() and
;        (bpEqKey "WHERE" and (bpDefinitionItem() or bpTrap())
;            and bpPush bfWhere(bpPop1(),bpPop1()) or true)
 
(DEFUN |bpWhere| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpDefinition|)
          (OR
           (AND (|bpEqKey| 'WHERE) (OR (|bpDefinitionItem|) (|bpTrap|))
                (|bpPush| (|bfWhere| (|bpPop1|) (|bpPop1|))))
           T)))))
 
; bpDefinitionItem()==
;           a:=bpState()
;           if bpDDef()
;           then true
;           else
;              bpRestore a
;              if bpBDefinitionPileItems()
;              then true
;              else
;                bpRestore a
;                if bpPDefinitionItems()
;                then true
;                else
;                    bpRestore a
;                    bpWhere()
 
(DEFUN |bpDefinitionItem| ()
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (|bpState|))
      (COND ((|bpDDef|) T)
            (#1='T (|bpRestore| |a|)
             (COND ((|bpBDefinitionPileItems|) T)
                   (#1# (|bpRestore| |a|)
                    (COND ((|bpPDefinitionItems|) T)
                          (#1# (|bpRestore| |a|) (|bpWhere|)))))))))))
 
; bpDefinitionPileItems()==
;     bpListAndRecover function bpDefinitionItem
;            and bpPush bfDefSequence bpPop1()
 
(DEFUN |bpDefinitionPileItems| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpListAndRecover| #'|bpDefinitionItem|)
          (|bpPush| (|bfDefSequence| (|bpPop1|)))))))
 
; bpBDefinitionPileItems()== bpPileBracketed function bpDefinitionPileItems
 
(DEFUN |bpBDefinitionPileItems| #1=()
  (PROG #1# (RETURN (|bpPileBracketed| #'|bpDefinitionPileItems|))))
 
; bpSemiColonDefinition()==bpSemiListing
;     (function bpDefinitionItem,function bfDefSequence)
 
(DEFUN |bpSemiColonDefinition| #1=()
  (PROG #1# (RETURN (|bpSemiListing| #'|bpDefinitionItem| #'|bfDefSequence|))))
 
; bpPDefinitionItems()==bpParenthesized function bpSemiColonDefinition
 
(DEFUN |bpPDefinitionItems| #1=()
  (PROG #1# (RETURN (|bpParenthesized| #'|bpSemiColonDefinition|))))
 
; bpComma()== bpTuple function bpWhere
 
(DEFUN |bpComma| #1=() (PROG #1# (RETURN (|bpTuple| #'|bpWhere|))))
 
; bpTuple(p)==bpListofFun(p,function bpCommaBackSet,function bfTuple)
 
(DEFUN |bpTuple| (|p|)
  (PROG () (RETURN (|bpListofFun| |p| #'|bpCommaBackSet| #'|bfTuple|))))
 
; bpCommaBackSet()== bpEqKey "COMMA" and (bpEqKey "BACKSET" or true)
 
(DEFUN |bpCommaBackSet| #1=()
  (PROG #1# (RETURN (AND (|bpEqKey| 'COMMA) (OR (|bpEqKey| 'BACKSET) T)))))
 
; bpSemiColon()==bpSemiListing (function bpComma,function bfSequence)
 
(DEFUN |bpSemiColon| #1=()
  (PROG #1# (RETURN (|bpSemiListing| #'|bpComma| #'|bfSequence|))))
 
; bpSemiListing(p,f)==bpListofFun(p,function bpSemiBackSet,f)
 
(DEFUN |bpSemiListing| (|p| |f|)
  (PROG () (RETURN (|bpListofFun| |p| #'|bpSemiBackSet| |f|))))
 
; bpSemiBackSet()== bpEqKey "SEMICOLON" and (bpEqKey "BACKSET" or true)
 
(DEFUN |bpSemiBackSet| #1=()
  (PROG #1# (RETURN (AND (|bpEqKey| 'SEMICOLON) (OR (|bpEqKey| 'BACKSET) T)))))
 
; bpPDefinition()==  bpIndentParenthesized function bpSemiColon
 
(DEFUN |bpPDefinition| #1=()
  (PROG #1# (RETURN (|bpIndentParenthesized| #'|bpSemiColon|))))
 
; bpPileItems()==
;     bpListAndRecover function bpSemiColon and bpPush bfSequence bpPop1()
 
(DEFUN |bpPileItems| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpListAndRecover| #'|bpSemiColon|)
          (|bpPush| (|bfSequence| (|bpPop1|)))))))
 
; bpBPileDefinition()==  bpPileBracketed function bpPileItems
 
(DEFUN |bpBPileDefinition| #1=()
  (PROG #1# (RETURN (|bpPileBracketed| #'|bpPileItems|))))
 
; bpIteratorTail()==
;      (bpEqKey "REPEAT" or true) and bpIterators()
 
(DEFUN |bpIteratorTail| #1=()
  (PROG #1# (RETURN (AND (OR (|bpEqKey| 'REPEAT) T) (|bpIterators|)))))
 
; bpConstruct()==bpBracket function bpConstruction
 
(DEFUN |bpConstruct| #1=() (PROG #1# (RETURN (|bpBracket| #'|bpConstruction|))))
 
; bpConstruction()==
;      bpComma() and
;         (bpIteratorTail() and
;              bpPush bfCollect (bpPop2(),bpPop1()) or
;                 bpPush bfTupleConstruct bpPop1())
 
(DEFUN |bpConstruction| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpComma|)
          (OR
           (AND (|bpIteratorTail|)
                (|bpPush| (|bfCollect| (|bpPop2|) (|bpPop1|))))
           (|bpPush| (|bfTupleConstruct| (|bpPop1|))))))))
 
; bpDConstruct()==bpBracket function bpDConstruction
 
(DEFUN |bpDConstruct| #1=()
  (PROG #1# (RETURN (|bpBracket| #'|bpDConstruction|))))
 
; bpDConstruction()==
;      bpComma() and
;         (bpIteratorTail() and
;              bpPush bfDCollect (bpPop2(),bpPop1()) or
;                 bpPush bfDTuple bpPop1())
 
(DEFUN |bpDConstruction| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpComma|)
          (OR
           (AND (|bpIteratorTail|)
                (|bpPush| (|bfDCollect| (|bpPop2|) (|bpPop1|))))
           (|bpPush| (|bfDTuple| (|bpPop1|))))))))
 
; bpPattern()== bpBracketConstruct function bpPatternL
;                 or bpName() or bpConstTok()
 
(DEFUN |bpPattern| #1=()
  (PROG #1#
    (RETURN
     (OR (|bpBracketConstruct| #'|bpPatternL|) (|bpName|) (|bpConstTok|)))))
 
; bpEqual()==
;    bpEqKey "SHOEEQ" and (bpApplication() or bpConstTok() or
;                 bpTrap()) and bpPush bfEqual bpPop1()
 
(DEFUN |bpEqual| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpEqKey| 'SHOEEQ) (OR (|bpApplication|) (|bpConstTok|) (|bpTrap|))
          (|bpPush| (|bfEqual| (|bpPop1|)))))))
 
; bpRegularPatternItem() ==
;    bpEqual() or
;      bpConstTok() or bpDot() or
;       bpName() and
;          ((bpEqKey "BEC" and (bpPattern() or bpTrap())
;               and bpPush bfAssign(bpPop2(),bpPop1())) or true)
;                     or bpBracketConstruct function bpPatternL
 
(DEFUN |bpRegularPatternItem| #1=()
  (PROG #1#
    (RETURN
     (OR (|bpEqual|) (|bpConstTok|) (|bpDot|)
         (AND (|bpName|)
              (OR
               (AND (|bpEqKey| 'BEC) (OR (|bpPattern|) (|bpTrap|))
                    (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
               T))
         (|bpBracketConstruct| #'|bpPatternL|)))))
 
; bpRegularPatternItemL()==
;       bpRegularPatternItem() and bpPush [bpPop1()]
 
(DEFUN |bpRegularPatternItemL| #1=()
  (PROG #1#
    (RETURN (AND (|bpRegularPatternItem|) (|bpPush| (LIST (|bpPop1|)))))))
 
; bpRegularList()==
;        bpListof(function bpRegularPatternItemL,"COMMA",function bfAppend)
 
(DEFUN |bpRegularList| #1=()
  (PROG #1#
    (RETURN (|bpListof| #'|bpRegularPatternItemL| 'COMMA #'|bfAppend|))))
 
; bpPatternColon()==
;      bpEqKey "COLON" and (bpRegularPatternItem() or bpTrap())
;               and bpPush [bfColon bpPop1()]
 
(DEFUN |bpPatternColon| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpEqKey| 'COLON) (OR (|bpRegularPatternItem|) (|bpTrap|))
          (|bpPush| (LIST (|bfColon| (|bpPop1|))))))))
 
; bpPatternL() == bpPatternList() and bpPush bfTuple bpPop1()
 
(DEFUN |bpPatternL| #1=()
  (PROG #1# (RETURN (AND (|bpPatternList|) (|bpPush| (|bfTuple| (|bpPop1|)))))))
 
; bpPatternList()==
;      if bpRegularPatternItemL()
;      then
;         while (bpEqKey  "COMMA" and (bpRegularPatternItemL() or
;             (bpPatternTail()
;               and bpPush append(bpPop2(),bpPop1())
;                 or bpTrap();false) )) repeat
;                   bpPush append(bpPop2(),bpPop1())
;         true
;      else bpPatternTail()
 
(DEFUN |bpPatternList| #1=()
  (PROG #1#
    (RETURN
     (COND
      ((|bpRegularPatternItemL|)
       ((LAMBDA #1#
          (LOOP
           (COND
            ((NOT
              (AND (|bpEqKey| 'COMMA)
                   (OR (|bpRegularPatternItemL|)
                       (PROGN
                        (OR
                         (AND (|bpPatternTail|)
                              (|bpPush| (APPEND (|bpPop2|) (|bpPop1|))))
                         (|bpTrap|))
                        NIL))))
             (RETURN NIL))
            (#2='T (|bpPush| (APPEND (|bpPop2|) (|bpPop1|))))))))
       T)
      (#2# (|bpPatternTail|))))))
 
; bpPatternTail()==
;      bpPatternColon() and
;          (bpEqKey "COMMA" and (bpRegularList() or bpTrap())
;               and bpPush append (bpPop2(),bpPop1()) or true)
 
(DEFUN |bpPatternTail| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpPatternColon|)
          (OR
           (AND (|bpEqKey| 'COMMA) (OR (|bpRegularList|) (|bpTrap|))
                (|bpPush| (APPEND (|bpPop2|) (|bpPop1|))))
           T)))))
 
; bpRegularBVItem() ==
;   bpBVString() or
;      bpConstTok() or
;       (bpName() and
;          (bpEqKey "BEC" and (bpPattern() or bpTrap())
;               and bpPush bfAssign(bpPop2(),bpPop1()) or
;                (bpEqKey "IS" and (bpPattern() or bpTrap())
;                   and bpPush bfAssign(bpPop2(),bpPop1())) or true))
;                     or bpBracketConstruct function bpPatternL
 
(DEFUN |bpRegularBVItem| #1=()
  (PROG #1#
    (RETURN
     (OR (|bpBVString|) (|bpConstTok|)
         (AND (|bpName|)
              (OR
               (AND (|bpEqKey| 'BEC) (OR (|bpPattern|) (|bpTrap|))
                    (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
               (AND (|bpEqKey| 'IS) (OR (|bpPattern|) (|bpTrap|))
                    (|bpPush| (|bfAssign| (|bpPop2|) (|bpPop1|))))
               T))
         (|bpBracketConstruct| #'|bpPatternL|)))))
 
; bpBVString()==
;      EQ(shoeTokType $stok,"STRING") and
;          bpPush(["BVQUOTE",INTERN $ttok]) and bpNext()
 
(DEFUN |bpBVString| #1=()
  (PROG #1#
    (RETURN
     (AND (EQ (|shoeTokType| |$stok|) 'STRING)
          (|bpPush| (LIST 'BVQUOTE (INTERN |$ttok|))) (|bpNext|)))))
 
; bpRegularBVItemL() ==
;       bpRegularBVItem() and bpPush [bpPop1()]
 
(DEFUN |bpRegularBVItemL| #1=()
  (PROG #1# (RETURN (AND (|bpRegularBVItem|) (|bpPush| (LIST (|bpPop1|)))))))
 
; bpColonName()==
;      bpEqKey "COLON" and (bpName() or bpBVString() or bpTrap())
 
(DEFUN |bpColonName| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpEqKey| 'COLON) (OR (|bpName|) (|bpBVString|) (|bpTrap|))))))
 
; bpBoundVariablelist()==
;      if bpRegularBVItemL()
;      then
;         while (bpEqKey  "COMMA" and (bpRegularBVItemL() or
;             (bpColonName()
;               and bpPush  bfColonAppend(bpPop2(),bpPop1())
;                 or bpTrap();false) )) repeat
;                    bpPush append(bpPop2(),bpPop1())
;         true
;      else bpColonName() and bpPush bfColonAppend(nil,bpPop1())
 
(DEFUN |bpBoundVariablelist| #1=()
  (PROG #1#
    (RETURN
     (COND
      ((|bpRegularBVItemL|)
       ((LAMBDA #1#
          (LOOP
           (COND
            ((NOT
              (AND (|bpEqKey| 'COMMA)
                   (OR (|bpRegularBVItemL|)
                       (PROGN
                        (OR
                         (AND (|bpColonName|)
                              (|bpPush|
                               (|bfColonAppend| (|bpPop2|) (|bpPop1|))))
                         (|bpTrap|))
                        NIL))))
             (RETURN NIL))
            (#2='T (|bpPush| (APPEND (|bpPop2|) (|bpPop1|))))))))
       T)
      (#2#
       (AND (|bpColonName|) (|bpPush| (|bfColonAppend| NIL (|bpPop1|)))))))))
 
; bpVariable()==
;     bpParenthesized function bpBoundVariablelist
;        and bpPush bfTupleIf bpPop1()
;          or bpBracketConstruct function bpPatternL
;                 or bpName() or bpConstTok()
 
(DEFUN |bpVariable| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (|bpParenthesized| #'|bpBoundVariablelist|)
           (|bpPush| (|bfTupleIf| (|bpPop1|))))
      (|bpBracketConstruct| #'|bpPatternL|) (|bpName|) (|bpConstTok|)))))
 
; bpAssignVariable()==
;       bpBracketConstruct function bpPatternL or bpAssignLHS()
 
(DEFUN |bpAssignVariable| #1=()
  (PROG #1#
    (RETURN (OR (|bpBracketConstruct| #'|bpPatternL|) (|bpAssignLHS|)))))
 
; bpAssignLHS()==
;    bpName() and (bpEqKey "COLON" and (bpApplication() or bpTrap())
;      and bpPush bfLocal(bpPop2(),bpPop1())
;         or bpEqKey "DOT" and bpList(function bpPrimary,"DOT",
;               function bfListOf)
;           and bpChecknull() and
;             bpPush bfTuple(cons(bpPop2(),bpPop1()))
;                  or true)
 
(DEFUN |bpAssignLHS| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpName|)
          (OR
           (AND (|bpEqKey| 'COLON) (OR (|bpApplication|) (|bpTrap|))
                (|bpPush| (|bfLocal| (|bpPop2|) (|bpPop1|))))
           (AND (|bpEqKey| 'DOT) (|bpList| #'|bpPrimary| 'DOT #'|bfListOf|)
                (|bpChecknull|)
                (|bpPush| (|bfTuple| (CONS (|bpPop2|) (|bpPop1|)))))
           T)))))
 
; bpChecknull()==
;       a:=bpPop1()
;       if null a
;       then bpTrap()
;       else bpPush a
 
(DEFUN |bpChecknull| ()
  (PROG (|a|)
    (RETURN
     (PROGN
      (SETQ |a| (|bpPop1|))
      (COND ((NULL |a|) (|bpTrap|)) ('T (|bpPush| |a|)))))))
 
; bpStruct()==
;    bpEqKey "STRUCTURE" and
;       (bpName() or bpTrap()) and
;         (bpEqKey "DEF" or bpTrap()) and
;            bpTypeList() and bpPush bfStruct(bpPop2(),bpPop1())
 
(DEFUN |bpStruct| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpEqKey| 'STRUCTURE) (OR (|bpName|) (|bpTrap|))
          (OR (|bpEqKey| 'DEF) (|bpTrap|)) (|bpTypeList|)
          (|bpPush| (|bfStruct| (|bpPop2|) (|bpPop1|)))))))
 
; bpTypeList() == bpPileBracketed function bpTypeItemList
;        or bpTerm() and bpPush [bpPop1()]
 
(DEFUN |bpTypeList| #1=()
  (PROG #1#
    (RETURN
     (OR (|bpPileBracketed| #'|bpTypeItemList|)
         (AND (|bpTerm|) (|bpPush| (LIST (|bpPop1|))))))))
 
; bpTypeItemList() ==  bpListAndRecover function bpTerm
 
(DEFUN |bpTypeItemList| #1=()
  (PROG #1# (RETURN (|bpListAndRecover| #'|bpTerm|))))
 
; bpTerm() ==
;           (bpName() or bpTrap()) and
;             ((bpParenthesized function bpIdList and
;               bpPush bfNameArgs (bpPop2(),bpPop1()))
;                 or bpName() and bpPush bfNameArgs(bpPop2(),bpPop1()))
;                  or bpPush(bfNameOnly bpPop1())
 
(DEFUN |bpTerm| #1=()
  (PROG #1#
    (RETURN
     (OR
      (AND (OR (|bpName|) (|bpTrap|))
           (OR
            (AND (|bpParenthesized| #'|bpIdList|)
                 (|bpPush| (|bfNameArgs| (|bpPop2|) (|bpPop1|))))
            (AND (|bpName|) (|bpPush| (|bfNameArgs| (|bpPop2|) (|bpPop1|))))))
      (|bpPush| (|bfNameOnly| (|bpPop1|)))))))
 
; bpIdList()== bpTuple function bpName
 
(DEFUN |bpIdList| #1=() (PROG #1# (RETURN (|bpTuple| #'|bpName|))))
 
; bpCase()==
;       bpEqKey "CASE" and
;         (bpWhere() or bpTrap()) and
;            (bpEqKey "OF" or bpMissing "OF") and
;                  bpPiledCaseItems()
 
(DEFUN |bpCase| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpEqKey| 'CASE) (OR (|bpWhere|) (|bpTrap|))
          (OR (|bpEqKey| 'OF) (|bpMissing| 'OF)) (|bpPiledCaseItems|)))))
 
; bpPiledCaseItems()==
;    bpPileBracketed function bpCaseItemList and
;        bpPush bfCase(bpPop2(),bpPop1())
 
(DEFUN |bpPiledCaseItems| #1=()
  (PROG #1#
    (RETURN
     (AND (|bpPileBracketed| #'|bpCaseItemList|)
          (|bpPush| (|bfCase| (|bpPop2|) (|bpPop1|)))))))
 
; bpCaseItemList()==
;    bpListAndRecover function bpCaseItem
 
(DEFUN |bpCaseItemList| #1=()
  (PROG #1# (RETURN (|bpListAndRecover| #'|bpCaseItem|))))
 
; bpCaseItem()==
;     (bpTerm() or bpTrap()) and
;        (bpEqKey "EXIT" or bpTrap()) and
;          (bpWhere() or bpTrap()) and
;             bpPush bfCaseItem (bpPop2(),bpPop1())
 
(DEFUN |bpCaseItem| #1=()
  (PROG #1#
    (RETURN
     (AND (OR (|bpTerm|) (|bpTrap|)) (OR (|bpEqKey| 'EXIT) (|bpTrap|))
          (OR (|bpWhere|) (|bpTrap|))
          (|bpPush| (|bfCaseItem| (|bpPop2|) (|bpPop1|)))))))
